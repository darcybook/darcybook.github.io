[{"id":0,"href":"/fyne/docs/explore/canvas/","title":"Canvas and CanvasObject","section":"Exploring Fyne","content":"In Fyne a Canvas is the area which an application is drawn within. Each window has a canvas which you can access with Window.Canvas() but usually you will find functions on Window that avoid accessing the canvas.\nEverything that can be drawn in Fyne is a type of CanvasObject. The example here opens a new window and then shows different types of primitive graphical element by setting the content of the window canvas. There are many ways that each type of object can be customised as shown with the text and circle examples.\nAs well as changing the content shown using Canvas.SetContent() it is possible to change the content that is currently visible. If, for example, you change the FillColour of a rectangle you can request a refresh of this existing component using rect.Refresh().\npackage main  import ( \t\u0026#34;image/color\u0026#34; \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Canvas\u0026#34;) \tmyCanvas := myWindow.Canvas()  \tblue := color.NRGBA{R: 0, G: 0, B: 180, A: 255} \trect := canvas.NewRectangle(blue) \tmyCanvas.SetContent(rect)  \tgo func() { \ttime.Sleep(time.Second) \tgreen := color.NRGBA{R: 0, G: 180, B: 0, A: 255} \trect.FillColor = green \trect.Refresh() \t}()  \tmyWindow.Resize(fyne.NewSize(100, 100)) \tmyWindow.ShowAndRun() } We can draw many different drawing elements in the same way, such as circle and text.\nfunc setContentToText(c fyne.Canvas) { \tgreen := color.NRGBA{R: 0, G: 180, B: 0, A: 255} \ttext := canvas.NewText(\u0026#34;Text\u0026#34;, green) \ttext.TextStyle.Bold = true \tc.SetContent(text) }  func setContentToCircle(c fyne.Canvas) { \tred := color.NRGBA{R: 0xff, G: 0x33, B: 0x33, A: 0xff} \tcircle := canvas.NewCircle(color.White) \tcircle.StrokeWidth = 4 \tcircle.StrokeColor = red \tc.SetContent(circle) } Widget\r#\r\rA fyne.Widget is a special type of canvas object that has interactive elements associated with it. In widgets the logic is separate from the way that it looks (also called the WidgetRenderer).\nWidgets are also types of CanvasObject and so we can set the content of our window to a single widget. See how we create a new widget.Entry and set it as the content of the window in this example.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Widget\u0026#34;)  \tmyWindow.SetContent(widget.NewEntry()) \tmyWindow.ShowAndRun() } "},{"id":1,"href":"/fyne/docs/started/introduction/","title":"Introduction","section":"Getting Started","content":"Getting Started\r#\r\rUsing the Fyne toolkit to build cross platform applications is very simple but does require some tools to be installed before you can begin. If your computer is set up for development with Go then the following steps may not be required, but we advise reading the tips for your operating system just in case. If later steps in this tutorial fail then you should re-visit the prerequisites below.\nPrerequisites\r#\r\rFyne requires 3 basic elements to be present, the Go tools (at least version 1.12), a C compiler (to connect with system graphics drivers) and an system graphics driver. The instructions vary depending on your operating system, choose the appropriate tab below for installation instructions.\nNote that these steps are just required for development - your Fyne applications will not require any setup or dependency installation for end users!\nwindows\r#\r\r Download Go from the download page and follow instructions Install one of the available C compilers for windows, the following are tested with Go and Fyne:  MSYS2 with MingW-w64 - msys2.org TDM-GCC - tdm-gcc.tdragon.net Cygwin - cygwin.com   In Windows your graphics driver will already be installed, but it is recommended to ensure they are up to date.  The steps for installing with MSYS2 (recommended) are as follows:\n  Install MSYS2 from msys2.org\n  Once installed do not use the MSYS terminal that opens\n  Open \u0026ldquo;MSYS2 MinGW 64-bit\u0026rdquo; from the start menu\n  Execute the following commands (if asked for install options be sure to choose \u0026ldquo;all\u0026rdquo;):\n $ pacman -Syu\r$ pacman -S git mingw-w64-x86_64-toolchain\r   You will need to add /c/Program\\ Files/Go/bin and ~/Go/bin to your PATH, for MSYS2 you can paste the following command into your terminal:\n $ echo \u0026quot;export PATH=$PATH:/c/Program\\ Files/Go/bin:~/Go/bin\u0026quot; \u0026gt;\u0026gt; ~/.bashrc\r   macos\r#\r\r Download Go from the download page and follow instructions Install Xcode from the Mac App Store Set up the Xcode command line tools by opening a Terminal window and typing the following: xcode-select --install In macOS the graphics drivers will already be installed.  linux\r#\r\r You will need to install Go, gcc and the graphics library header files using your package manager, one of the following commands will probably work. Debian / Ubuntu: sudo apt-get install golang gcc libgl1-mesa-dev xorg-dev Fedora: sudo dnf install golang gcc libXcursor-devel libXrandr-devel mesa-libGL-devel libXi-devel libXinerama-devel libXxf86vm-devel Arch Linux: sudo pacman -S go xorg-server-devel libxcursor libxrandr libxinerama libxi Solus: sudo eopkg it -c system.devel golang mesalib-devel libxrandr-devel libxcursor-devel libxi-devel libxinerama-devel openSUSE: sudo zypper install go gcc libXcursor-devel libXrandr-devel Mesa-libGL-devel libXi-devel libXinerama-devel libXxf86vm-devel Void Linux: sudo xbps-install -S go base-devel xorg-server-devel libXrandr-devel libXcursor-devel libXinerama-devel  rpi\r#\r\r You will need to install Go, gcc and the graphics library header files using the package manager. sudo apt-get install golang gcc libegl1-mesa-dev xorg-dev  bsd\r#\r\r You will need to install Go, gcc and the graphics library header files using the package manager. FreeBSD: sudo pkg install go gcc xorg pkgconf  android\r#\r\r To develop apps for Android you will first need to install the tools for your current computer (Windows, macOS or Linux) Once complete you will need to install the Android SDK and Android NDK - the recommended approach is to install Android Studio and then go to Tools \u0026gt; SDK Manager and from SDK Tools install the NDK (Side by side) package.  ios\r#\r\r To develop apps for iOS you will need access to an Apple Mac computer, configured according to the macOS tab above. You will also need to create an Apple Developer account and sign up to the developer program (costs apply) to obtain the necessary certificate to run your app on any devices.  function clickTab(tab) {\rdocument.querySelector('li.tabcontrol[data-name=\"'+tab+'\"]').click();\r}\r$(document).ready(function(){\rvar ua = navigator.userAgent || navigator.vendor || window.opera;\rif (/android/i.test(ua)) {\rclickTab(\"android\");\rreturn;\r} else if (/iPad|iPhone|iPod/.test(ua) \u0026\u0026 !window.MSStream) {\rclickTab(\"ios\");\rreturn;\r}\rvar os = window.navigator.platform;\rif (os == \"win32\") {\rclickTab(\"windows\");\r} else if (os == \"MacIntel\") {\rclickTab(\"macos\");\r} else if (os == \"Linux i686\" || os == \"Linux x86_64\") {\rclickTab(\"linux\");\r} else if (os == \"Linux armv7l\") {\rclickTab(\"rpi\");\r} else if (os == \"FreeBSD i386\" || os == \"FreeBSD amd64\" || os == \"OpenBSD i386\" || os == \"OpenBSD amd64\" || os == \"NetBSD i386\" || os == \"NetBSD amd64\") {\rclickTab(\"bsd\");\r}\r});\r Downloading\r#\r\rWhen using Go modules (required with Go 1.16 and later), you will need to set up the module before you can use the package. If you are not using modules or you already have your module initialized, you can skip this to the next step. Run the following command and replace MODULE_NAME with your preferred module name (this should be called in a new folder specific for your application).\n$ cd myapp\r$ go mod init MODULE_NAME\r You now need to download the Fyne module. This will be done using the following command:\n$ go get fyne.io/fyne/v2\r To finish your module\u0026rsquo;s set up, you now need to tidy the module file to correctly reference Fyne as a dependency. You do this by using the following command (can be skipped if you are not using modules):\n$ go mod tidy\r If you are unsure of how Go modules work, consider reading Tutorial: Create a Go module.\nRun the demo\r#\r\rIf you want to see the Fyne toolkit in action before you start to code your own application, you can see our demo app running on your computer by executing:\n$ go run fyne.io/fyne/v2/cmd/fyne_demo\r Please note that the first run has to compile some C-code and can thus take longer than usual. Subsequent builds reuse the cache and will be much faster.\nInstalling\r#\r\rIf you want to, you can also install the demo using the following command (requires Go 1.16 or later):\n$ go install fyne.io/fyne/v2/cmd/fyne_demo@latest\r For earlier versions of Go, you need to use the following command instead:\n$ go get fyne.io/fyne/v2/cmd/fyne_demo\r If your GOBIN environment has been added to path (should be by default on macOS and Windows), you can then run the demo:\n$ fyne_demo\r And that\u0026rsquo;s all there is to it! Now you can write your own Fyne application in your IDE of choice. If you want to see some Fyne code in action then you can read your first application.\n"},{"id":2,"href":"/fyne/docs/container/box/","title":"Box","section":"Containers and Layout","content":"As discussed in Container and Layouts elements within a container can be arranged using a layout. This section explores the builtin layouts and how to use them.\nThe most commonly used layout is layout.BoxLayout and it has two variants, horizontal and vertical. A box layout arranges all elements in a single row or column with optional spaces to assist alignment.\nA horizontal box layout, created with layout.NewHBoxLayout() creates an arrangement of items in a single row. Every item in the box will have its width set to its MinSize().Width and the height will be equal for all items, the largest of all the MinSize().Height values. The layout can be used in a container or you can use the box widget widget.NewHBox().\nA vertical box layout is similar but it arranges items in a column. Each item will have its height set to minimum and all the widths will be equal, set to the largest of the minimum widths.\nTo create an expanding space between elements (so that some are left aligned and the others right aligned, for example) add a layout.NewSpacer() as one of the items. A spacer will expand to fill all available space. Adding a spacer at the beginning of a vertical box layout will cause all items to be bottom aligned. You can add one to the beginning and end of a horizontal arrangement to create a center alignment.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/layout\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Box Layout\u0026#34;)  \ttext1 := canvas.NewText(\u0026#34;Hello\u0026#34;, color.White) \ttext2 := canvas.NewText(\u0026#34;There\u0026#34;, color.White) \ttext3 := canvas.NewText(\u0026#34;(right)\u0026#34;, color.White) \tcontent := container.New(layout.NewHBoxLayout(), text1, text2, layout.NewSpacer(), text3)  \ttext4 := canvas.NewText(\u0026#34;centered\u0026#34;, color.White) \tcentered := container.New(layout.NewHBoxLayout(), layout.NewSpacer(), text4, layout.NewSpacer()) \tmyWindow.SetContent(container.New(layout.NewVBoxLayout(), content, centered)) \tmyWindow.ShowAndRun() } "},{"id":3,"href":"/fyne/docs/extend/custom-layout/","title":"Building a Custom Layout","section":"Extending Fyne","content":"In a Fyne application each Container arranges it\u0026rsquo;s child elements using a simple layout algorithm. Fyne defines many layouts available in the fyne.io/fyne/v2/layout package. If you look at the code you will see that they all implement the Layout interface.\ntype Layout interface { \tLayout([]CanvasObject, Size) \tMinSize(objects []CanvasObject) Size } Any application can provide a custom layout to arrange widgets in a non-standard manner. To do this you need to implement the interface above in your own code. To illustrate this we will create a new layout that arranges elements in a diagonal line and is arranged to the bottom left of it\u0026rsquo;s container\nFirst we will define a new type, diagonal, and define what it\u0026rsquo;s minimum size will be. To calculate this we just add the width and height of all child elements (specified as the []fyne.CanvasObject parameter to MinSize.\nimport \u0026#34;fyne.io/fyne/v2\u0026#34;  type diagonal struct { }  func (d *diagonal) MinSize(objects []fyne.CanvasObject) fyne.Size { \tw, h := float32(0), float32(0) \tfor _, o := range objects { \tchildSize := o.MinSize()  \tw += childSize.Width \th += childSize.Height \t} \treturn fyne.NewSize(w, h) } To this type we add a Layout() function that should move all of the specified objects into the fyne.Size specified in the second parameter.\nIn our implementation we calculate the top-left of the widgets (this is 0 x parameter and has a y position that is the height of the container less the total of all child item heights). From the top position we simply advance each item position by the size of the previous child.\nfunc (d *diagonal) Layout(objects []fyne.CanvasObject, containerSize fyne.Size) { \tpos := fyne.NewPos(0, containerSize.Height - d.MinSize(objects).Height) \tfor _, o := range objects { \tsize := o.MinSize() \to.Resize(size) \to.Move(pos)  \tpos = pos.Add(fyne.NewPos(size.Width, size.Height)) \t} } That\u0026rsquo;s all there is to creating a custom layout. Now that the code is all written we can use it as the layout parameter to container.New. The code below sets up 3 Label widgets and place them in a container with our new layout. If you run this application you will see the diagonal widget arrangement and, upon resizing the window, they will align to the bottom left of the available space.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Diagonal\u0026#34;)  \ttext1 := widget.NewLabel(\u0026#34;topleft\u0026#34;) \ttext2 := widget.NewLabel(\u0026#34;Middle Label\u0026#34;) \ttext3 := widget.NewLabel(\u0026#34;bottomright\u0026#34;)  \tw.SetContent(container.New(\u0026amp;diagonal{}, text1, text2, text3)) \tw.ShowAndRun() } "},{"id":4,"href":"/fyne/docs/binding/","title":"Data Binding","section":"Data Binding","content":"Data binding is a powerful new addition to the Fyne toolkit that was introduced in version v2.0.0. By using data binding we can avoid manually managing many standard objects like Labels, Buttons and Lists.\nThe builtin bindings support many primitive types (like Int, String, Float etc), lists (such as StringList, BoolList) as well as Map and Struct bindings. Each of these types can be created using a simple constructor function. For example to create a new string binding with a zero value you can use binding.NewString(). You can get or set the value of most data bindings using Get and Set methods.\nIt is also possible to bind to an existing value using similar functions who\u0026rsquo;s names start Bind and they all accept a pointer to the type bound. To bind to an existing int we could use binding.BindInt(\u0026amp;myInt). By keeping a reference to a bound value instead of the original variable we can configure widgets and functions to respond to any changes automatically. If you change the external data directly, be sure to call Reload() to ensure that the binding system reads the new value.\npackage main  import ( \t\u0026#34;log\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; )  func main() { \tboundString := binding.NewString() \ts, _ := boundString.Get() \tlog.Printf(\u0026#34;Bound = \u0026#39;%s\u0026#39;\u0026#34;, s)  \tmyInt := 5 \tboundInt := binding.BindInt(\u0026amp;myInt) \ti, _ := boundInt.Get() \tlog.Printf(\u0026#34;Source = %d, bound = %d\u0026#34;, myInt, i) } We start learning about simple values widget binding next.\n"},{"id":5,"href":"/fyne/docs/architecture/geometry/","title":"Geometry","section":"Architecture","content":"Fyne apps are based on 1 canvas per window. Each canvas has a root CanvasObject which can be a single widget or a Container for many sub-objects whose size and position are controlled by a Layout.\nPosition\r#\r\r Each canvas has its origin at the top left (0, 0) every element of the UI may be scaled depending on the output device and so the API does not describe pixels or exact measurements. The position (10, 10) may be 10 pixels right and down from the origin on, for example, a 120DPI monitor but on a HiDPI (or \u0026ldquo;Retina\u0026rdquo;) display this will probably be closer to 20 pixels.\nEvery position referenced by a CanvasObject is relative to it\u0026rsquo;s parent. This is important for layout algorithms but also for developers in situations such as the Tappable.Tapped(PointEvent) handlers. Here the the X/Y coordinates will be calculated from the top left of the button not the overall canvas. This is designed to allow code to be as self-contained as possible.\nPixel size\r#\r\r Like other vector based GUI libraries the Fyne coordinates need to be based on some baseline monitor resolution. All scaling is relative to this value. For fyne that resolution is 120DPI. This means that the sizes referred to in fyne.Size will be 1=1px when your monitor is 120DPI and scale values are all set to 1. For a HiDPI screen, as mentioned above, the actual DPI may be closer to 240 and on mobile devices it could even be 360 or higher. To manage handle this complexity the toolkit manages scaling internally so your apps will always look the right size. If a user sets the scale to be smaller then their apps will always have smaller than normal fonts, buttons etc, and when they specify larger then your app will scale up to suit.\nWhen compared to Material Design we can see that their baseline DPI is 160, although the maths is similar the actual numbers will be different. This means that device-independent sizes in Fyne use a smaller number to represent the same physical size. For example an icon that is 18 tall in Fyne would be sized at 24 in a standard material design (for example Android) app. This does not matter when building your application, but may be important when working with designers or experts with Material Design.\nOne time that pixel sizes will matter is if you start loading bitmaps images. Normally these scale appropriately, but if you specify FillMode=fyne.FillOriginal then the actual image size will be different on different devices, due to the pixel density. Normally this feature would be used inside a Scroll container. Fyne also defines a canvas.Raster primitive which will draw pixels exactly at the pixel density of the output device. This enables your code to draw at the highest possible output resolution without knowing details of the device you are running on. If for some reason you need \u0026ldquo;pixel perfect\u0026rdquo; positioning you need to multiply CanvasObject.Size() by Canvas.Scale().\n"},{"id":6,"href":"/fyne/docs/started/","title":"Getting Started","section":"Docs","content":"\r\rIntroduction\r\rintroduction\r\r\rHello World\r\rHello World\r\r\rApplication and RunLoop\r\rApplication and RunLoop\r\r\rUpdating Content\r\rUpdating Content\r\r\rWindow Handling\r\rWindow Handling\r\r\rTesting Graphical Apps\r\rTesting Graphical Apps\r\r\rPackaging for Desktop\r\rPackaging for Desktop\r\r\rPackaging Mobile Apps\r\rPackaging Mobile Apps\r\r\rDistributing to App Stores\r\rDistributing to App Stores\r\r\rApp Metadata\r\rApp Metadata\r\r\rCross Compiling\r\rCross Compiling\r\r\r"},{"id":7,"href":"/fyne/docs/widget/label/","title":"Label","section":"Widgets","content":"Widgets are the main components of a Fyne application GUI, they can be used in any place that a basic fyne.CanvasObject can. They manage user interactions and will always match the current theme.\nThe Label widget is the simplest of them - it presents text to the user. Unlike canvas.Text it can handle some simple formatting (such as \\n) and wrapping (by setting the Wrapping field). You can create a label by calling widget.NewLabel(\u0026quot;some text\u0026quot;), the result can be assigned to a variable or passed directly into a container.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Label Widget\u0026#34;)  \tcontent := widget.NewLabel(\u0026#34;text\u0026#34;)  \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } "},{"id":8,"href":"/fyne/docs/faq/layout/","title":"Layout and Widget Size","section":"Frequently Asked Questions","content":"Intro\nMove and Resize\r#\r\rQ: How can I move my widget to a different position or resize it?\nA: The position and size of elements in a Fyne app are controlled by the layout of the container that they are within. If the elements of your UI are too small consider using a different layout or container.\nA new Window will expand whatever element is passed to SetContent() to fill it\u0026rsquo;s size. Each time you add a container to this it will divide up the available space according to the layout. Layouts like HBox and VBox will shrink content to it\u0026rsquo;s MinSize() in one dimension or another to pack contents in. Layouts like Max or Border will expand content to fill the space. By writing a custom layout you could fully controll the items within a container.\nQ: Why is my image so small?\nA: One of the difficulties in using a fully scalable user interface toolkit such as Fyne is that the coordinate system is device independent. This allows apps to draw at the right resolution or pixel density to get the best results based on the hardware connected. What this means for pixel based images is that their size could vary based on details not known at compile time.\nDue to this complication an image loaded using canvas.NewImageFromFile() or similar calls will not have a size set, leading to it being very small or appearing to be hidden by default. When placed in an appropriate layout the image will stretch according to it\u0026rsquo;s FillMode property. If you desire the image to always be set to a certain size (or larger) you can call Image.SetMinSize() and specify a device independent size for the image.\nContainers and Layout\r#\r\rQ: How can I manually control the position of elements\nA: In some situations you may want to have complete control over the position and size of elements in a container. To do this you create a container without a layout. The container.NewWithoutLayout() function will create a container for manual positioning - you should pass to that constructor a list of the graphical elements that you want to manage in this container.\nOnce set up then you can use Move() and Resize() on each element to position it as desired. When doing this be careful to note that it will not adjust as the available space changes - and it does not have an explicit minimum size either. To add either of those features you should replace your manual positioning with a custom layout.\n"},{"id":9,"href":"/fyne/docs/canvas/rectangle/","title":"Rectangle","section":"Drawing and Animation","content":"canvas.Rectangle is the simplest canvas object in Fyne. It displays a block of the specified colour. You can also set the colour using the FillColor field.\nIn this example the rectangle fills the window as it is the only content element.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Rectangle\u0026#34;)  \trect := canvas.NewRectangle(color.White) \tw.SetContent(rect)  \tw.Resize(fyne.NewSize(150, 100)) \tw.ShowAndRun() } Other fyne.CanvaObject types have more configuration, let us look next at canvas.Text.\n"},{"id":10,"href":"/fyne/docs/explore/container/","title":"Container and Layouts","section":"Exploring Fyne","content":"In the previous example we saw how to set a CanvasObject to the content of a Canvas, but it is not very useful to only show one visual element. To show more than one item we use the Container type.\nAs the fyne.Container also is a fyne.CanvasObject, we can set it to be the content of a fyne.Canvas. In this example we create 3 text objects and then place them in a container using the container.NewWithoutLayout() function. As there is no layout set we can move the elements around like you see with text2.Move().\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t//\u0026#34;fyne.io/fyne/v2/layout\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Container\u0026#34;) \tgreen := color.NRGBA{R: 0, G: 180, B: 0, A: 255}  \ttext1 := canvas.NewText(\u0026#34;Hello\u0026#34;, green) \ttext2 := canvas.NewText(\u0026#34;There\u0026#34;, green) \ttext2.Move(fyne.NewPos(20, 20)) \tcontent := container.NewWithoutLayout(text1, text2) \t// content := container.New(layout.NewGridLayout(2), text1, text2)  \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } A fyne.Layout implements a method for organising items within a container. By uncommenting the container.New() line in this example you alter the container to use a grid layout with 2 columns. Run this code and try resizing the window to see how the layout automatically configures the contents of the window. Notice also that the manual position of text2 is ignored by the layout code.\nTo see more you can check out the Layout list.\n"},{"id":11,"href":"/fyne/docs/started/helloword/","title":"Hello World","section":"Getting Started","content":"Create your first Fyne app\r#\r\r Having completed the steps in the getting started document you\u0026rsquo;re ready to build your first app. To illustrate the process we will build a simple hello world application.\nA simple app starts by creating an app instance with app.New() and then opening a window with app.NewWindow(). Then a widget tree is defined that is set as the main content with SetContent() on a window. The app UI is then shown by calling ShowAndRun() on the window.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello World\u0026#34;)  \tw.SetContent(widget.NewLabel(\u0026#34;Hello World!\u0026#34;)) \tw.ShowAndRun() } The code above can be built using the command go build . and then executed either by running the hello command or by double clicking the icon. You could also bypass the compiling step and just run the code directly using go run ..\nEither approach will show a window that looks just like this:\n\rIf you prefer a light theme then just set the environment variable FYNE_THEME=light and you\u0026rsquo;ll get:\n\rThat\u0026rsquo;s all there is to getting started. To learn more you can read the full API documentation.\n"},{"id":12,"href":"/fyne/docs/binding/simple/","title":"Binding Simple Widgets","section":"Data Binding","content":"The simplest form of binding a widget is to pass it a bound item as a value instead of a static value. Many widgets provide a WithData constructor that will accept a typed data binding item. To set up the binding all you need to do is pass the right type in.\nAlthough this may not look like much of a benefit in the initial code you can then see how it ensures that the displayed content is always up to date with the source of the data. You will notice how we did not need to call Refresh() on the Label widget or even keep a reference to it and yet it updates appropriately.\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Simple\u0026#34;)  \tstr := binding.NewString() \tstr.Set(\u0026#34;Initial value\u0026#34;)  \ttext := widget.NewLabelWithData(str) \tw.SetContent(text)  \tgo func() { \ttime.Sleep(time.Second * 2) \tstr.Set(\u0026#34;A new string\u0026#34;) \t}()  \tw.ShowAndRun() } In the next step we look at how to set up widgets that edit values through two way binding.\n"},{"id":13,"href":"/fyne/docs/widget/button/","title":"Button","section":"Widgets","content":"The button widget can contain text, an icon or both, the constructor functions are widget.NewButton() and widget.NewButtonWithIcon(). To create a text button there are just 2 parameters, the string content and a 0 parameter func() that will be called when the button is tapped. See the example for how that can be created.\nThe button constructor with an icon includes an additional parameter which is the fyne.Resource which contains the icon data. The builtin icons within the theme package all adapt appropriately to a change in theme. You can pass in your own image if it is loaded as a resource - helpers such as fyne.LoadResourceFromPath() may assist, though bundling resources is recommended where possible.\nTo create a button with only an icon you should pass \u0026quot;\u0026quot; as the label parameter to widget.NewButtonWithIcon().\npackage main  import ( \t\u0026#34;log\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; \t//\u0026#34;fyne.io/fyne/v2/theme\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Button Widget\u0026#34;)  \tcontent := widget.NewButton(\u0026#34;click me\u0026#34;, func() { \tlog.Println(\u0026#34;tapped\u0026#34;) \t})  \t//content := widget.NewButtonWithIcon(\u0026#34;Home\u0026#34;, theme.HomeIcon(), func() { \t//\tlog.Println(\u0026#34;tapped home\u0026#34;) \t//})  \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } "},{"id":14,"href":"/fyne/docs/explore/","title":"Exploring Fyne","section":"Docs","content":"\r\rCanvas and CanvasObject\r\rCanvas and CanvasObject\r\r\rContainer and Layouts\r\rContainer and Layouts\r\r\rWidget List\r\rWidget List\r\r\rLayout List\r\rLayout List\r\r\rDialog List\r\rDialog List\r\r\rAdding Shortcuts to an App\r\rAdding Shortcuts to an App\r\r\rUsing the Preferences API\r\rUsing the Preferences API\r\r\rCompile Options\r\rCompile Options\r\r\rData Binding\r\rData Binding\r\r\r"},{"id":15,"href":"/fyne/docs/container/grid/","title":"Grid","section":"Containers and Layout","content":"The grid layout lays out the elements of a container in a grid pattern with a fixed number of columns. Items will fill a single row until the number of columns is met, after this a new row will be created. Vertical space will be split equally between each of the rows of objects.\nYou create a grid layout using layout.NewGridLayout(cols) where cols is the number of items (columns) you wish to have in each row. This layout is then passed as the first parameter to container.New(...).\nIf you resize the container then each of the cells will resize equally to share the available space.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/layout\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Grid Layout\u0026#34;)  \ttext1 := canvas.NewText(\u0026#34;1\u0026#34;, color.White) \ttext2 := canvas.NewText(\u0026#34;2\u0026#34;, color.White) \ttext3 := canvas.NewText(\u0026#34;3\u0026#34;, color.White) \tgrid := container.New(layout.NewGridLayout(2), text1, text2, text3) \tmyWindow.SetContent(grid) \tmyWindow.ShowAndRun() } "},{"id":16,"href":"/fyne/docs/architecture/scaling/","title":"Scaling","section":"Architecture","content":"Fyne is built entirely using vector graphics, which means applications written with Fyne will scale to any size beautifully (not just whole number increments). This is a great benefit to the rising popularity of high density displays on mobile devices and high-end computers. The default scale value is calculated to match your operating system - on some systems this is user configuration and on others from your screen\u0026rsquo;s pixel density (DPI - dots per inch). If a Fyne window is moved to another screen it will re-scale and adjust the window size accordingly! We call this \u0026ldquo;auto scaling\u0026rdquo;, and it is designed to keep an app user interface the same size as you change monitor.\nYou can adjust the size of applications using the fyne_settings app or by setting a specific scale using the FYNE_SCALE environment variable. These values can make content larger or smaller than the system settings, using \u0026ldquo;1.5\u0026rdquo; will make things 50% larger or setting 0.8 will make it 20% smaller.\n\rStandard size\rFYNE_SCALE=0.5\rFYNE_SCALE=2.5\r\r"},{"id":17,"href":"/fyne/docs/canvas/text/","title":"Text","section":"Drawing and Animation","content":"canvas.Text is used for all text rendering within Fyne. It is created by specifying the text and colour for the text. Text is rendered using the default font, specified by the current theme.\nThe text object allows certain configuration like the Alignment and TextStyle field. as illustrated in the example here. To use a monospaced font instead you can specify fyne.TextStyle{Monospace: true}.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Text\u0026#34;)  \ttext := canvas.NewText(\u0026#34;Text Object\u0026#34;, color.White) \ttext.Alignment = fyne.TextAlignTrailing \ttext.TextStyle = fyne.TextStyle{Italic: true} \tw.SetContent(text)  \tw.ShowAndRun() } It is possible to use an alternative font by specifying a FYNE_FONT environment variable. Use this to set a .ttf file to use instead of the one provided in the Fyne toolkit or the current theme.\n"},{"id":18,"href":"/fyne/docs/faq/theme/","title":"Theme and Customisation","section":"Frequently Asked Questions","content":"In this page we answer some common questions about the design of Fyne themes and widgets.\nCustomisation\r#\r\rQ: How can I change the colour of text for a Label widget?\nA: All of the standard widgets use the current Theme definition to set the colour, font and sizes. To make changes to your application consider using a custom theme.\nIf your application requires text that is a different colour you can use the canvas.Text type instead. That allows directly setting the colour and size of the text. Be careful when doing this because a user can choose between light or dark theme variations, so you should test with both.\nQ: How can I remove the background colour from my Entry widget?\nA: The input background is set by the theme InputBackground color. You can change that to color.Transparent to remove all input background boxes. It is not possible to edit the style of a single input element - the theme API is designed to give a customisable, but consistent, design.\nTheme API\r#\r\rQ: How can I use my custom theme written before v2.0.0?\nA: Over time you should consider updating to use the new theme API. However it is possible to use a simple adapter that was included to allow the usage of old themes during the transition time. You will find theme.FromLegacy function that can adapt an old theme instance to the new API.\nmyTheme := \u0026amp;myOldThemeType{} updated := theme.FromLegacy(myTheme) app.Settings().SetTheme(updated) There are no performance penalties when using a theme in this mode, but in a future release this API will be removed.\n"},{"id":19,"href":"/fyne/docs/started/apprun/","title":"Application and RunLoop","section":"Getting Started","content":"For a GUI application to work it needs to run an event loop (sometimes called a runloop) that processes user interactions and drawing events. In Fyne this is started using the App.Run() or Window.ShowAndRun() functions. One of these must be called from the end of your setup code in the main() function.\nAn application should only have one runloop and so you should only call Run() once in your code. Calling it a second time will cause errors.\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Hello\u0026#34;) \tmyWindow.SetContent(widget.NewLabel(\u0026#34;Hello\u0026#34;))  \tmyWindow.Show() \tmyApp.Run() \ttidyUp() }  func tidyUp() { \tfmt.Println(\u0026#34;Exited\u0026#34;) } For desktop runtimes an app can be quit directly by calling App.Quit() (mobile apps do not support this) - normally not needed in developer code. An application will also quit once all the windows are closed. See also that functions executed after Run() will not be called until the application exits.\n"},{"id":20,"href":"/fyne/docs/explore/widgets/","title":"Widget List","section":"Exploring Fyne","content":"Standard Widgets (in widget package)\r#\r\r Accordion\r#\r\rAccordion displays a list of AccordionItems. Each item is represented by a button that reveals a detailed view when tapped.\n\rButton\r#\r\rButton widget has a text label and icon, both are optional.\n\rCard\r#\r\rCard widget groups elements with a header and subheader, all are optional.\n\rCheck\r#\r\rCheck widget has a text label and a checked (or unchecked) icon.\n\rEntry\r#\r\rEntry widget allows simple text to be input when focused.\n\rPasswordEntry widget hides text input and adds a button to display the text.\n\rFileIcon\r#\r\rFileIcon provides helpful standard icons for various types of file. It displays the type of file as an indicator icon and shows the extension of the file type.\n\rForm\r#\r\rForm widget is two column grid where each row has a label and a widget (usually an input). The last row of the grid will contain the appropriate form control buttons if any should be shown.\n\rHyperlink\r#\r\rHyperlink widget is a text component with appropriate padding and layout. When clicked, the URL opens in your default web browser.\n\rIcon\r#\r\rIcon widget is a basic image component that load\u0026rsquo;s its resource to match the theme.\n\rLabel\r#\r\rLabel widget is a label component with appropriate padding and layout.\n\rProgress bar\r#\r\rProgressBar widget creates a horizontal panel that indicates progress.\n\rProgressBarInfinite widget creates a horizontal panel that indicates waiting indefinitely An infinite progress bar loops 0% -\u0026gt; 100% repeatedly until Stop() is called.\n\rRadioGroup\r#\r\rRadioGroup widget has a list of text labels and radio check icons next to each.\n\rSelect\r#\r\rSelect widget has a list of options, with the current one shown, and triggers an event function when clicked.\n\rSelectEntry\r#\r\rSelect entry widget adds an editable component to the select widget. Users can select an option or enter their own value.\n\rSeparator\r#\r\rSeparator widget shows a dividing line between other elements.\n\rSlider\r#\r\rSlider if a widget that can slide between two fixed values.\n\rTextGrid\r#\r\rTextGrid is a monospaced grid of characters. This is designed to be used by a text editor, code preview or terminal emulator.\n\rToolbar\r#\r\rToolbar widget creates a horizontal list of tool buttons.\n\rCollection Widgets (in widget package)\r#\r\rCollection widgets provide advanced caching functionality to provide high performance rendering of massive data. This does lead to a more complex constructor, but is a good balance for the outcome it enables. Each of these widgets uses a series of callbacks, the minimum set is defined by their constructor function, which includes the data size, the creation of template items that can be re-used and finally the function that applies data to a widget as it is about to be added to the display.\nList\r#\r\rList provides a high performance vertical scroll of many sub-items.\n\rTable\r#\r\rTable provides a high performance scrolled two dimensional display of many sub-items. Tree\r#\r\rTree provides a high performance vertical scroll of items that can be expanded to reveal child elements..\n\rContainer Widgets (in container package)\r#\r\rContainer widgets are like regular containers but they provide some additional functionality.\nAppTabs\r#\r\rAppTabs widget allows switching visible content from a list of TabItems. Each item is represented by a button at the top of the widget.\n\rScroll\r#\r\rScrollContainer defines a container that is smaller than the Content.\n\rSplit\r#\r\rSplitContainer defines a container whose size is split between two children.\n\r"},{"id":21,"href":"/fyne/docs/extend/bundle/","title":"Bundling resources","section":"Extending Fyne","content":"Go based applications are usually built as a single binary executable, and this is the same for Fyne applications. A single file makes it easier to distribute install our software. Unfortunately GUI applications typically require additional resources to render the user interface. To manage this challenge a Go application can bundle assets into the binary itself. The Fyne toolkit prefers the use of \u0026ldquo;fyne bundle\u0026rdquo; as it has various benefits that we will explore below.\nThe basic approach to bundle an asset is to execute the \u0026ldquo;fyne bundle\u0026rdquo; command. This tool has various parameters to customise the output, but in it\u0026rsquo;s basic form the file to bundle will be converted into Go source code that can be built into your application.\n$ ls image.png\tmain.go $ fyne bundle image.png \u0026gt;\u0026gt; bundled.go $ ls bundled.go\timage.png\tmain.go $ The contents of bundled.go will be a list of resource variables that we can then access in our code. For example the code above will result in a file that includes the following:\nvar resourceImagePng = \u0026amp;fyne.StaticResource{ \tStaticName: \u0026#34;image.png\u0026#34;, \tStaticContent: []byte{ ... \t}} As you see the default naming is \u0026ldquo;resource\u0026lt;Name\u0026gt;.\u0026lt;Ext\u0026gt;\u0026rdquo;. The name and package used in this file can be customised in command parameters. We can then use this name to, for example, load an image on our canvas:\nimg := canvas.NewImageFromResource(resourceImagePng) A fyne resource is just a collection of bytes with a unique name, so this could be a font, a sound file or any other data you wish to load. Also you can bundle many resources into a single file using the -append parameter. If you will be bundling many files it is recommended to save the commands in a shell script, for example this file gen.sh:\n#!/bin/bash fyne bundle image1.png \u0026gt; bundled.go fyne bundle -append image2.png \u0026gt;\u0026gt; bundled.go If you then change any assets or add new ones then you can update this file and run it once to update your bundled.go file. You should then add bundled.go to version control so others can build your app without needing to run \u0026ldquo;fyne bundle\u0026rdquo;. It is also a good idea to add gen.sh as well so that others can re-generate the bundled resources if required.\n"},{"id":22,"href":"/fyne/docs/canvas/","title":"Drawing and Animation","section":"Docs","content":"\r\rRectangle\r\rcanvas.Rectangle is the simplest canvas object in Fyne. It displays a block of the specified colour. You can also set the colour using the FillColor field. In this example the rectangle fills the window as it is the only content element. package main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;Rectangle\u0026#34;) rect := canvas.\r\r\rText\r\rcanvas.Text is used for all text rendering within Fyne. It is created by specifying the text and colour for the text. Text is rendered using the default font, specified by the current theme. The text object allows certain configuration like the Alignment and TextStyle field. as illustrated in the example here. To use a monospaced font instead you can specify fyne.TextStyle{Monospace: true}. package main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.\r\r\rLine\r\rThe canvas.Line object draws a line from the Position1 (default is top, left) to Position2 (default is bottom, right). You specify its colour and can vary the stroke width which otherwise defaults to 1. A line position can be manipulated using the Position1 or Position2 fields or by using the Move() and Resize() functions. For example a 0 width area will show a vertical line whereas 0 height would be horizontal.\r\r\rCircle\r\rcanvas.Circle defines a circle shape filled by the specified colour. You may also set a StrokeWidth and therefore a different StrokeColor as shown in this example. The circle will fill the space specified by calling Resize() or by the layout it is controlled by. As the example sets the circle as the window content it will resize to fill the window, within a basic padding (controlled by the theme). package main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.\r\r\rImage\r\rA canvas.Image represents a scalable image resource in Fyne. It can be loaded from a resource (as shown in the example), from an image file, from a URI location containing an image, from an io.Reader, or from a Go image.Image in memory. The default image fill mode is canvas.ImageFillStretch which will cause it to fill the space specified (through Resize() or layout). Alternatively you could use canvas.ImageFillContain to ensure that the aspect ratio is maintained and the image is within the bounds.\r\r\rRaster\r\rThe canvas.Raster is like an image but draws exactly one spot for each pixel on the screen. This means that as a user interface scales or the image resizes more pixels will be requested to fill the space. To do this we use a Generator function as illustrated in this example - it will be used to return the colour of each pixel. The generator functions can be pixel based (as in this example where we generate a new random colour for each pixel) or based on full images.\r\r\rAnimation\r\rFyne includes an animation framework that allows you to smoothly transition canvas properties from one value to another over time. An animation can contain any code which means that any types of object attributes can be managed, however there are builtin animations for size, position and color. Animations are normally created using the builtin helpers of the canvas package, such as NewSizeAnimation, and calling Start() on the created animation. You can set animations to repeat or auto reverse, as we will see below.\r\r\rGradient\r\rThe last canvas primitive type is Gradient, available as canvas.LinearGradient and canvas.RadialGradient which is used to draw a gradient from one colour to another in various patterns. You can create gradients using NewHorizontalGradient(), NewVerticalGradient() or NewRadialGradient(). To create a gradient you need a start and end colour - every colour in between is calculated by the canvas. In this example we use color.Transparent to show how a gradient (or any other type) could use an alpha value to be semi-transparent over the content behind.\r\r\r"},{"id":23,"href":"/fyne/docs/widget/entry/","title":"Entry","section":"Widgets","content":"The entry widget is used for user input of simple text content. An entry can be created with a simple widget.NewEntry() constructing function. When you create the widget keep a reference so that you can access its Text field later. It is also possible to use the OnChanged callback function to be notified every time the content changes.\nEntry widgets can also have validation for verifying the text input typed into it. This can be done by setting the Validator field to a fyne.StringValidator. You can also set a PlaceHolder text and also set the entry to MultiLine to accept more than one line of text.\npackage main  import ( \t\u0026#34;log\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Entry Widget\u0026#34;)  \tinput := widget.NewEntry() \tinput.SetPlaceHolder(\u0026#34;Enter text...\u0026#34;)  \tcontent := container.NewVBox(input, widget.NewButton(\u0026#34;Save\u0026#34;, func() { \tlog.Println(\u0026#34;Content was:\u0026#34;, input.Text) \t}))  \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } You can also create a password entry (where the content is obscured) using the NewPasswordEntry() function.\n"},{"id":24,"href":"/fyne/docs/container/gridwrap/","title":"Grid Wrap","section":"Containers and Layout","content":"Like the previous grid layout, the grid wrap layout creates an arrangement of elements in a grid pattern. However this grid does not have a set number of columns, instead it uses a fixed size for each cell and then flows the content to as many rows as is needed to display the items.\nYou create a grid wrap layout using layout.NewGridWrapLayout(size) where size specifies the size to apply to all child elements. This layout is then passed as the first parameter to container.New(...). The number of columns and rows will be calculated based on the current size of the container.\nInitially a grid wrap layout will have a single column, if you resize it (as illustrated in the code comment to the right) it will rearrange the child elements to fill the space.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/layout\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Grid Wrap Layout\u0026#34;)  \ttext1 := canvas.NewText(\u0026#34;1\u0026#34;, color.White) \ttext2 := canvas.NewText(\u0026#34;2\u0026#34;, color.White) \ttext3 := canvas.NewText(\u0026#34;3\u0026#34;, color.White) \tgrid := container.New(layout.NewGridWrapLayout(fyne.NewSize(50, 50)), \ttext1, text2, text3) \tmyWindow.SetContent(grid)  \t// myWindow.Resize(fyne.NewSize(180, 75)) \tmyWindow.ShowAndRun() } "},{"id":25,"href":"/fyne/docs/canvas/line/","title":"Line","section":"Drawing and Animation","content":"The canvas.Line object draws a line from the Position1 (default is top, left) to Position2 (default is bottom, right). You specify its colour and can vary the stroke width which otherwise defaults to 1.\nA line position can be manipulated using the Position1 or Position2 fields or by using the Move() and Resize() functions. For example a 0 width area will show a vertical line whereas 0 height would be horizontal.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Line\u0026#34;)  \tline := canvas.NewLine(color.White) \tline.StrokeWidth = 5 \tw.SetContent(line)  \tw.Resize(fyne.NewSize(100, 100)) \tw.ShowAndRun() } Lines are typically used in a custom layout or controlled manually. Unlike text they have no natural (minimum) size but can be used to great effect in complex layouts.\n"},{"id":26,"href":"/fyne/docs/binding/twoway/","title":"Two-Way Binding","section":"Data Binding","content":"So far we have looked at data binding as a way of keeping our user interface elements up to date. Far more common, however, is the need to update values from the UI widgets and keep the data up to date everywhere. Thankfully the bindings provided in Fyne are \u0026ldquo;two-way\u0026rdquo; which means that values can be pushed into them as well as read out. The change in data will be communicated to all connected code without any additional code.\nTo see this in action we can update the last test app to display a Label and an Entry that are bound to the same value. By setting this up you can see that editing the value through the entry will update the text in the label as well. This is all possible without calling refresh or referencing the widgets in our code.\nBy moving your app to use data binding you can stop saving pointers to all your widgets. By instead capturing your data as a set of bound values your user interface can be completely separate code. Cleaner to read and easier to manage.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Two Way\u0026#34;)  \tstr := binding.NewString() \tstr.Set(\u0026#34;Hi!\u0026#34;)  \tw.SetContent(container.NewVBox( \twidget.NewLabelWithData(str), \twidget.NewEntryWithData(str), \t))  \tw.ShowAndRun() } Next we will look at how to add conversions in our data.\n"},{"id":27,"href":"/fyne/docs/architecture/widgets/","title":"Widgets","section":"Architecture","content":"Widgets in the Fyne toolkit are designed for a clean and pleasant user interaction, following a standard theme and supporting rapid app development, solid testing and easy maintenance. There are various design considerations that promote that ambition, we explore them in this page.\nBehaviour API\r#\r\r One thing that you will notice about the standard widgets is that the API is all about behaviour and state - but very little that controls the actual look of an element. This is by design. It enables our code, and that of app developers, to focus on the behaviour of a widget so that it\u0026rsquo;s rendering process can be left to other code. This makes it much easier to test, in fact full applications can be run through unit tests in memory without ever having to render the app.\nYou can extend an existing widget to add new behaviours without needing to worry about how it is rendered. It is also possible to write your own components, an application is not limited to using the provided widget set. When building your own widget you will notice that the rendering details are completely separate from the state - this is part of the design mentioned above. A WidgetRenderer (the code that renders a Widget) typically holds a reference to the widget that it will be rendering to access state or other information. When a widget state changes then Refresh() is called - the renderer will then be asked to refresh and it should update the display to reflect the new state. Custom widgets are recommended to use the current Theme but can choose to specify thier own sizes, colours and icons where that seems desirable.\nContent Padding\r#\r\r The standard widgets use the theme specified padding to make appropriate space around their graphical components. In the v2.0.0 release the height and baseline of most widgets was standardised to ensure that standard layouts will align well by default. If you are building a custom widget it is recommended to follow these guidelines.\nThe value of theme.Padding() is used in layouts to space elements of a container, it creates a standardised space around the various parts of an application. Some widgets, however, have content that should be inset from the edges of the extents. Consider Entry, It has a background and an underline that go out to the edges, but it\u0026rsquo;s content should be inset. And so we have standardised the amount of spacing used to inset so that alignment matches.\nThe standard inset, or content padding, of a widget is currently defined as 2*theme.Padding(). The standard value of padding is 4 which means the standard inset is 8. You can see in Label and Entry how the (text) content is inset by this much so that their content will align horizontally and vertically when placed next to each other.\n![](/images/architecture/widget-inset.png)\rIt is recommended that custom widgets include similar dimensions so that they fit well alongside the standard widgets.\n"},{"id":28,"href":"/fyne/docs/explore/layouts/","title":"Layout List","section":"Exploring Fyne","content":"Standard Layouts\r#\r\r Horizontal Box (HBox)\r#\r\rHorizontal Box arranges items in a horizontal row. Every element will have the same height (the height of the tallest item in the container) and objects will be left-aligned at their minimum width.\n\rVertical Box (VBox)\r#\r\rVertical Box arranges items in a vertical column. Every element will have the same width (the width of the widest item in the container) and objects will be top-aligned at their minimum height.\n\rCenter\r#\r\rCenter layout positions all container elements in the center of the container. Every object will be set to it\u0026rsquo;s minimum size.\n\rForm\r#\r\rForm layout arranges items in pairs where the first column is at minimum width. This is normally useful for labelling elements in a form, where the label is in the first column and the item it describes is in the second. You should always add an even number of elements to a form layout.\n\rGrid\r#\r\rGrid layout arranges items equally in the available space. A number of columns is specified, with objects being positioned horizontally until the number of columns is reached at which point a new row is started. All objects have the same size, that is width divided by column total and the height will be total height divided by the number of rows required. Minus padding.\n\rGridWrap\r#\r\rGridWrap layout arranges all items to flow along a row, wrapping to a new row if there is insufficient space. All objects will be set to the same size, which is the size passed to the layout. This layout may not respect item MinSize to manage this uniform layout. Often used in file managers or image thumbnail lists.\n\rBorder\r#\r\rBorder layout supports positioning of items at the outside of available space. The border is passed pointers to the objects for (top, left, bottom, right). All items in the container that are not positioned on a border will fill the remaining space.\n\rMax\r#\r\rMax layout positions all container elements to fill the available space. The objects will all be full-sized and drawn in the order they were added to the container (last-most is on top).\n\rPadded\r#\r\rPadded layout positions all container elements to fill the available space but with a small padding around the outside. The size of the padding is theme specific. The objects will all be drawn in the order they were added to the container (last-most is on top).\n\rCombining Layouts\r#\r\rIt is possible to build up more complex application structures by using multiple layouts. Multiple containers that each have their own layout can be nested to create complete user interface arrangements using only the standard layouts listed above. For example a horizontal box for a header, a vertical box for a left side file panel and a grid wrap layout in the content area - all inside a container using a border layout can build the result illustrated below.\n\r"},{"id":29,"href":"/fyne/docs/started/updating/","title":"Updating Content","section":"Getting Started","content":"Having completed the hello world tutorial or other examples you will have created a basic user interface. In this page we see how the content of a GUI can be updated from your code.\nThe first step is to assign the widget you want to update to a variable. In the hello world tutorial we passed widget.NewLabel directly into SetContent(), to update it we change that to two different lines, such as:\n\tclock := widget.NewLabel(\u0026#34;\u0026#34;) \tw.SetContent(clock) Once the content has been assigned to a variable we can call functions like SetText(\u0026quot;new text\u0026quot;). For our example we will set the content of our label to the current time, with the help of Time.Format.\n\tformatted := time.Now().Format(\u0026#34;Time: 03:04:05\u0026#34;) \tclock.SetText(formatted) That is all we need to do to change content of a visible item (see below for the full code). However, we can go further and update content on a regular basis.\nRunning in the background\r#\r\rMost applications will need to have processes that run in the background, for example downloading data or responding to events. To simulate this we will extend the code above to run every second.\nLike with most go code we can create a goroutine (using the go keyword) and run our code there. If we move the text update code to a new function it can be called on initial display as well as on a timer for regular updating. By combining a goroutine and the time.Tick inside a for loop we can update the label every second.\n\tgo func() { \tfor range time.Tick(time.Second) { \tupdateTime(clock) \t} \t}() It is important to place this code before ShowAndRun or Run calls because they will not return until the application closes. With all of this together the code will run and update the user interface each second, creating a basic clock widget. The full code is as follows:\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func updateTime(clock *widget.Label) { \tformatted := time.Now().Format(\u0026#34;Time: 03:04:05\u0026#34;) \tclock.SetText(formatted) }  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Clock\u0026#34;)  \tclock := widget.NewLabel(\u0026#34;\u0026#34;) \tupdateTime(clock)  \tw.SetContent(clock) \tgo func() { \tfor range time.Tick(time.Second) { \tupdateTime(clock) \t} \t}() \tw.ShowAndRun() } "},{"id":30,"href":"/fyne/docs/container/border/","title":"Border","section":"Containers and Layout","content":"The border layout is possibly the most widely used to construct user interfaces as it allows the positioning of items around a central element which will expand to fill the space. To create a border layout you need to pass the fyne.CanvasObjects that should be positioned in a border position to the layout (as well as the container as usual). This syntax is a little different to the other layouts but is basically just layout.NewBorderLayout(top, bottom, left, right) as illustrated in the example to the right.\nAny items passed to the container that do not appear in specific border locations will be positioned to the central area and will expand to fill the space available. You can also pass nil to border parameters that you wish to leave empty.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/layout\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Border Layout\u0026#34;)  \ttop := canvas.NewText(\u0026#34;top bar\u0026#34;, color.White) \tleft := canvas.NewText(\u0026#34;left\u0026#34;, color.White) \tmiddle := canvas.NewText(\u0026#34;content\u0026#34;, color.White) \tcontent := container.New(layout.NewBorderLayout(top, nil, left, nil), \ttop, left, middle) \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } Note that all items in the center will expand to fill the space (as if they were in a layout.MaxLayout container). To manage the area yourself you can create a new fyne.Container (using container.New()) and use any layout you wish.\n"},{"id":31,"href":"/fyne/docs/widget/choices/","title":"Choices","section":"Widgets","content":"There are various widgets available to present the user with a choice, these include a checkbox, radio group and select popup.\nThe widget.Check provides a simple yes/no choice and is created using a string label. Each of these widgets also takes a \u0026ldquo;changed\u0026rdquo; func(...) where the parameter is of the appropriate type. widget.NewCheck(..) therefore takes a string parameter for the label and a func(bool) param for the change handler. You can also use the Checked field to get the boolean value.\nThe radio widget is similar, but the first parameter is a slice of strings that represents each of the options. The change function expects a string parameter this time to return the currently selected value. Call widget.NewRadioGroup(...) to construct the radio group widget, you can use this reference later to read the Selected field instead of using the change callback.\nThe select widget is identical in the constructor signature as the radio widget. Calling widget.NewSelect(...) will instead show a button that displays a popup when tapped from which the user can make a selection. This is better for long lists of options.\npackage main  import ( \t\u0026#34;log\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Choice Widgets\u0026#34;)  \tcheck := widget.NewCheck(\u0026#34;Optional\u0026#34;, func(value bool) { \tlog.Println(\u0026#34;Check set to\u0026#34;, value) \t}) \tradio := widget.NewRadioGroup([]string{\u0026#34;Option 1\u0026#34;, \u0026#34;Option 2\u0026#34;}, func(value string) { \tlog.Println(\u0026#34;Radio set to\u0026#34;, value) \t}) \tcombo := widget.NewSelect([]string{\u0026#34;Option 1\u0026#34;, \u0026#34;Option 2\u0026#34;}, func(value string) { \tlog.Println(\u0026#34;Select set to\u0026#34;, value) \t})  \tmyWindow.SetContent(container.NewVBox(check, radio, combo)) \tmyWindow.ShowAndRun() } "},{"id":32,"href":"/fyne/docs/canvas/circle/","title":"Circle","section":"Drawing and Animation","content":"canvas.Circle defines a circle shape filled by the specified colour. You may also set a StrokeWidth and therefore a different StrokeColor as shown in this example.\nThe circle will fill the space specified by calling Resize() or by the layout it is controlled by. As the example sets the circle as the window content it will resize to fill the window, within a basic padding (controlled by the theme).\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Circle\u0026#34;)  \tcircle := canvas.NewCircle(color.White) \tcircle.StrokeColor = color.Gray{0x99} \tcircle.StrokeWidth = 5 \tw.SetContent(circle)  \tw.Resize(fyne.NewSize(100, 100)) \tw.ShowAndRun() } All these have been basic types that can be rendered by our driver with no additional information. Next we will look at more complex types starting with Image.\n"},{"id":33,"href":"/fyne/docs/container/","title":"Containers and Layout","section":"Docs","content":"\r\rBox\r\rAs discussed in Container and Layouts elements within a container can be arranged using a layout. This section explores the builtin layouts and how to use them. The most commonly used layout is layout.BoxLayout and it has two variants, horizontal and vertical. A box layout arranges all elements in a single row or column with optional spaces to assist alignment. A horizontal box layout, created with layout.NewHBoxLayout() creates an arrangement of items in a single row.\r\r\rGrid\r\rThe grid layout lays out the elements of a container in a grid pattern with a fixed number of columns. Items will fill a single row until the number of columns is met, after this a new row will be created. Vertical space will be split equally between each of the rows of objects. You create a grid layout using layout.NewGridLayout(cols) where cols is the number of items (columns) you wish to have in each row.\r\r\rGrid Wrap\r\rLike the previous grid layout, the grid wrap layout creates an arrangement of elements in a grid pattern. However this grid does not have a set number of columns, instead it uses a fixed size for each cell and then flows the content to as many rows as is needed to display the items. You create a grid wrap layout using layout.NewGridWrapLayout(size) where size specifies the size to apply to all child elements.\r\r\rBorder\r\rThe border layout is possibly the most widely used to construct user interfaces as it allows the positioning of items around a central element which will expand to fill the space. To create a border layout you need to pass the fyne.CanvasObjects that should be positioned in a border position to the layout (as well as the container as usual). This syntax is a little different to the other layouts but is basically just layout.\r\r\rForm\r\rThe layout.FormLayout is like a 2 column grid layout but tweaked to lay out forms in an application. The height of each item will be the larger of the two minimum heights in each row. The width of the left item will be the largest minimum width of all items in the first column whilst the second item in each row will expand to fill the space. This layout is more typically used within the widget.\r\r\rCenter\r\rlayout.CenterLayout organises all items in its container to be centered in the available space. The objects will be drawn in the order they are passed to the container, with the last being drawn top-most. package main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/layout\u0026#34; \u0026#34;fyne.io/fyne/v2/theme\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Center Layout\u0026#34;) img := canvas.\r\r\rMax\r\rThe layout.MaxLayout is the simplest layout, it sets all items in the container to be the same size as the container. This is not often useful in general containers but can be suitable when composing widgets. The max layout will expand the container to be at least the size of the largest item\u0026rsquo;s minimum size. The objects will be drawn in the order the are passed to the container, with the last being drawn top-most.\r\r\rAppTabs\r\rThe AppTabs container is used to allow the user to switch between different content panels. Tabs are either just text or text and an icon. It is recommended not to mix some tabs having icons and some without. A tab container is created using container.NewAppTabs(...) and passing container.TabItem items (that can be created using container.NewTabItem(...)). The tab container can be configured by setting the location of tabs, one of container.TabLocationTop, container.\r\r\r"},{"id":34,"href":"/fyne/docs/extend/custom-theme/","title":"Creating a Custom Theme","section":"Extending Fyne","content":"Applications are able to load custom themes that can apply small changes to the standard theme or provide a completely unique look. A theme will need to implement the functions of fyne.Theme interface, which is defined as follows:\ntype Theme interface { \tColor(ThemeColorName, ThemeVariant) color.Color \tFont(TextStyle) Resource \tIcon(ThemeIconName) Resource \tSize(ThemeSizeName) float32 } To apply our theme changes we will first define a new type that that implements this interface.\nDefine your theme\r#\r\rWe start by defining a new type that will be our theme, a simple empty struct will do:\ntype myTheme struct {} It is a good idea to assert that we implement an interface so that compile errors are closer to the defining type.\nvar _ fyne.Theme = (*myTheme)(nil) At this point you could see compile errors because we still need to implement the methods, we start with color.\nCustomising colors\r#\r\rThe Color function defined in the Theme interface asks us to define a named color and also provides a hint for the variant that the user desires (for example theme.VariantLight or theme.VariantDark). In our theme we will return a custom background color - using a different value for light and dark.\nfunc (m myTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color { \tif name == theme.ColorNameBackground { \tif variant == theme.VariantLight { \treturn color.White \t} \treturn color.Black \t}  \treturn theme.DefaultTheme().Color(name, variant) } You will see the last line here references the theme.DefaultTheme() to look up standard values. This allows us to provide custom values and yet fall back to the standard theme when we don\u0026rsquo;t want to provide our own values.\nOf course colors are simpler than resources, we look at that for custom icons.\nOverriding default icons\r#\r\rIcons (and Fonts) use fyne.Resource as values instead of simple types like int (for size) or color.Color for colors. We can build our own resource using fyne.NewStaticResource, or you could pass in a value that was created using resource embedding.\nfunc (m myTheme) Icon(name fyne.ThemeIconName) fyne.Resource { \tif name == theme.IconNameHome { \tfyne.NewStaticResource(\u0026#34;myHome\u0026#34;, homeBytes) \t} \t\treturn theme.DefaultTheme().Icon(name) } As above we return the default theme icon if we don\u0026rsquo;t want to provide a specific override.\nLoad the theme\r#\r\rBefore we can load the theme you will need to implement the Size and Font methods as well. You can just use these empty implementations if you are happy to use the defaults.\nfunc (m myTheme) Font(style fyne.TextStyle) fyne.Resource { \treturn theme.DefaultTheme().Font(style) }  func (m myTheme) Size(name fyne.ThemeSizeName) float32 { \treturn theme.DefaultTheme().Size(name) } To set the theme for your app you will need to add the following line of code:\napp.Settings().SetTheme(\u0026amp;myTheme{}) With these changes you can apply your own style, to make small tweaks or provide a completely custom looking application!\n"},{"id":35,"href":"/fyne/docs/binding/conversion/","title":"Data Conversion","section":"Data Binding","content":"So far we have used data binding where the type of data matches the output type (for example String and Label or Entry). Often it will be desirable to present data that is not already in the correct format. To do this the binding package provides a number of helpful conversion functions.\nMost commonly this will be used to convert different types of data into strings for displaying in Label or Entry widgets. See in the code how we can convert a Float to String using binding.FloatToString. The original value can be edited by moving the slider. Each time the data changes it will run the conversion code and update any connected widgets.\nIt is also possible to use format strings to add more natural output for the user interface. You can see that our short binding is also converting a Float to String but by using a WithFormat helper we can pass a format string (similar to the fmt package) to provide a custom output.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Conversion\u0026#34;)  \tf := binding.NewFloat() \tstr := binding.FloatToString(f) \tshort := binding.FloatToStringWithFormat(f, \u0026#34;%0.0f%%\u0026#34;) \tf.Set(25.0)  \tw.SetContent(container.NewVBox( \twidget.NewSliderWithData(0, 100.0, f), \twidget.NewLabelWithData(str), \twidget.NewLabelWithData(short), \t))  \tw.ShowAndRun() } Lastly in this section we will look at list data.\n"},{"id":36,"href":"/fyne/docs/architecture/organisation/","title":"Organisation and Packages","section":"Architecture","content":"The Fyne project is split into many packages, each providing different types of functionality. They are as follows:\n fyne.io/fyne/v2 This import provides the basic definitions common to all Fyne code including data types and interfaces. fyne.io/fyne/v2/app The app package provides the APIs that start a new application. Normally you only require app.New() or app.NewWithID(). fyne.io/fyne/v2/canvas The canvas package provides all of the drawing APIs within Fyne. The complete Fyne toolkit is made up of these primitive graphical types. fyne.io/fyne/v2/container The container package provides containers that are used to lay out and organise applications. fyne.io/fyne/v2/data/binding The binding package contains ways of binding data sources to widgets. fyne.io/fyne/v2/data/validation The validation package provides tolling for validating data inside widgets. fyne.io/fyne/v2/dialog The dialog package contains dialogs such as confirm, error and file save/open. fyne.io/fyne/v2/layout The layout package provides various layout implementations for use with containers (discussed in a later tutorial). fyne.io/fyne/v2/storage The storage package provides storage access and management functionality. fyne.io/fyne/v2/test Applications can be tested more easily using the tools within the test package. fyne.io/fyne/v2/widget Most graphical applications are created using a collection of widgets. All the widgets and interactive elements within Fyne are in this package.  "},{"id":37,"href":"/fyne/docs/explore/dialogs/","title":"Dialog List","section":"Exploring Fyne","content":"Standard Dialogs\r#\r\r Color\r#\r\rAllow users to pick a colour from a standard set (or any color in advanced mode).\n\rConfirm\r#\r\rAsk for conformation of an action.\n\rFileOpen\r#\r\rPresent this to ask user to choose a file to use inside the app. The actual dialog displayed will depend on the current operating system.\n\rForm\r#\r\rGet various input elements in a dialog, with validation.\n\rInformation\r#\r\rA simple way to present some information to the app user.\n\rCustom\r#\r\rPresent any content inside a dialog container.\n\r"},{"id":38,"href":"/fyne/docs/started/windows/","title":"Window Handling","section":"Getting Started","content":"Windows are created using App.NewWindow() and need to be shown using the Show() function. The helper method ShowAndRun() on fyne.Window allows you to show your window and run the application at the same time.\nBy default a window will be the right size to show its content by checking the MinSize() function (more on that in later examples). You can set a larger size by calling the Window.Resize() method. Into this is passed a fyne.Size which contains a width and height using device independent pixels (meaning that it will be the same across different devices), for example to make a window square by default we could:\n\tw.Resize(fyne.NewSize(100, 100)) Be aware that the desktop environment may have constraints that cause windows to be smaller than requested. Mobile devices will typically ignore this as they are only displayed at full-screen.\nIf you wish to show a second window you must only call the Show() function. It can also be helpful to split Window.Show() from App.Run() if you want to open multiple windows when your application starts. The example below shows how to load two windows when starting.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello World\u0026#34;)  \tw.SetContent(widget.NewLabel(\u0026#34;Hello World!\u0026#34;)) \tw.Show()  \tw2 := a.NewWindow(\u0026#34;Larger\u0026#34;) \tw2.SetContent(widget.NewLabel(\u0026#34;More content\u0026#34;)) \tw2.Resize(fyne.NewSize(100, 100)) \tw2.Show()  \ta.Run() } The above application will exit when both windows are closed. If your app is arranged so one window is main and the others are accessory views you can set one window to be \u0026ldquo;master\u0026rdquo; so that the app exits if that window is closed. To do this use the SetMaster() function on Window.\nWindows can be created at any time, we could change the code above so that the content of the second window (w2) is a button that opens a new window. You could also load windows from more complex workflows, but be careful because new windows will normally appear above the current active content.\n\tw2.SetContent(widget.NewButton(\u0026#34;Open new\u0026#34;, func() { \tw3 := a.NewWindow(\u0026#34;Third\u0026#34;) \tw3.SetContent(widget.NewLabel(\u0026#34;Third\u0026#34;)) \tw3.Show() \t})) "},{"id":39,"href":"/fyne/docs/container/form/","title":"Form","section":"Containers and Layout","content":"The layout.FormLayout is like a 2 column grid layout but tweaked to lay out forms in an application. The height of each item will be the larger of the two minimum heights in each row. The width of the left item will be the largest minimum width of all items in the first column whilst the second item in each row will expand to fill the space.\nThis layout is more typically used within the widget.Form (for validation, submit and cancel buttons, etc) but it can also be used directly with layout.NewFormLayout() passed to the first parameter of container.New(...).\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/layout\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Form Layout\u0026#34;)  \tlabel1 := canvas.NewText(\u0026#34;Label 1\u0026#34;, color.Black) \tvalue1 := canvas.NewText(\u0026#34;Value\u0026#34;, color.White) \tlabel2 := canvas.NewText(\u0026#34;Label 2\u0026#34;, color.Black) \tvalue2 := canvas.NewText(\u0026#34;Something\u0026#34;, color.White) \tgrid := container.New(layout.NewFormLayout(), label1, value1, label2, value2) \tmyWindow.SetContent(grid) \tmyWindow.ShowAndRun() } "},{"id":40,"href":"/fyne/docs/widget/form/","title":"Form","section":"Widgets","content":"The form widget is used to lay out many input fields with labels and optional cancel and submit buttons. In its most bare form it aligns labels to the left of each input widget. By setting OnCancel or OnSubmit the form will add a button bar with the specified handlers called when appropriate.\nThe widget can be created with widget.NewForm(...) passing a list of widget.FormItems, or by using the \u0026amp;widget.Form{} syntax illustrated in the example. There is also a helpful Form.Append(label, widget) that can be used for an alternative syntax.\nIn this example we create two entries, one of which is a \u0026ldquo;multiline\u0026rdquo; (like HTML TextArea) to hold values. There is an OnSubmit handler which prints the information before closing the window (and therefore the application).\npackage main  import ( \t\u0026#34;log\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Form Widget\u0026#34;)  \tentry := widget.NewEntry() \ttextArea := widget.NewMultiLineEntry()  \tform := \u0026amp;widget.Form{ \tItems: []*widget.FormItem{ // we can specify items in the constructor \t{Text: \u0026#34;Entry\u0026#34;, Widget: entry}}, \tOnSubmit: func() { // optional, handle form submission \tlog.Println(\u0026#34;Form submitted:\u0026#34;, entry.Text) \tlog.Println(\u0026#34;multiline:\u0026#34;, textArea.Text) \tmyWindow.Close() \t}, \t}  \t// we can also append items \tform.Append(\u0026#34;Text\u0026#34;, textArea)  \tmyWindow.SetContent(form) \tmyWindow.ShowAndRun() } "},{"id":41,"href":"/fyne/docs/canvas/image/","title":"Image","section":"Drawing and Animation","content":"A canvas.Image represents a scalable image resource in Fyne. It can be loaded from a resource (as shown in the example), from an image file, from a URI location containing an image, from an io.Reader, or from a Go image.Image in memory.\nThe default image fill mode is canvas.ImageFillStretch which will cause it to fill the space specified (through Resize() or layout). Alternatively you could use canvas.ImageFillContain to ensure that the aspect ratio is maintained and the image is within the bounds. Further to this you can use canvas.ImageFillOriginal (as used in the example here) which ensures that it will also have a minimum size equal to that of the original image size.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/theme\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Image\u0026#34;)  \timage := canvas.NewImageFromResource(theme.FyneLogo()) \t// image := canvas.NewImageFromURI(uri) \t// image := canvas.NewImageFromImage(src) \t// image := canvas.NewImageFromReader(reader, name) \t// image := canvas.NewImageFromFile(fileName) \timage.FillMode = canvas.ImageFillOriginal \tw.SetContent(image)  \tw.ShowAndRun() } Images can be bitmap based (like PNG and JPEG) or vector based (such as SVG). Where possible we recommend scalable images as they will continue to render well as sizes change. Be careful when using original image sizes as they may not behave exactly as expected with different user interface scales. As Fyne allows the entire user interface to scale a 25px image file may not be the same height as a 25 height fyne object.\n"},{"id":42,"href":"/fyne/docs/binding/list/","title":"List Data","section":"Data Binding","content":"To demonstrate how more complex types can be connected we will look at the List widget and how data binding can make it easier to use. Firstly we create a StringList data binding, which is a list of String data type. Once we have a data of list type we can connect this to the standard List widget. To do so we use the widget.NewListWithData constructor, much like other widgets.\nComparing this code to the list tour You will see 2 main changes, the first is that we pass the data type as the first parameter instead of a length callback function. The second change is the last parameter, our UpdateItem callback. The revised version takes a binding.DataItem value instead of widget.ListIndexID. When using this callback structure we should Bind to the template label widget instead of calling SetText. This means that if any of the strings change in the data source each affected row of the table will refresh.\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;List Data\u0026#34;)  \tdata := binding.BindStringList( \t\u0026amp;[]string{\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;}, \t)  \tlist := widget.NewListWithData(data, \tfunc() fyne.CanvasObject { \treturn widget.NewLabel(\u0026#34;template\u0026#34;) \t}, \tfunc(i binding.DataItem, o fyne.CanvasObject) { \to.(*widget.Label).Bind(i.(binding.String)) \t})  \tadd := widget.NewButton(\u0026#34;Append\u0026#34;, func() { \tval := fmt.Sprintf(\u0026#34;Item %d\u0026#34;, data.Length()+1) \tdata.Append(val) \t}) \tmyWindow.SetContent(container.NewBorder(nil, add, nil, nil, list)) \tmyWindow.ShowAndRun() } In our demo code there is an \u0026ldquo;Append\u0026rdquo; Button, when tapped it will append a new value to the data source. Doing so will automatically trigger the data change handlers and expand the List widget to display the new data.\n"},{"id":43,"href":"/fyne/docs/widget/","title":"Widgets","section":"Docs","content":"\r\rLabel\r\rWidgets are the main components of a Fyne application GUI, they can be used in any place that a basic fyne.CanvasObject can. They manage user interactions and will always match the current theme. The Label widget is the simplest of them - it presents text to the user. Unlike canvas.Text it can handle some simple formatting (such as \\n) and wrapping (by setting the Wrapping field). You can create a label by calling widget.\r\r\rButton\r\rThe button widget can contain text, an icon or both, the constructor functions are widget.NewButton() and widget.NewButtonWithIcon(). To create a text button there are just 2 parameters, the string content and a 0 parameter func() that will be called when the button is tapped. See the example for how that can be created. The button constructor with an icon includes an additional parameter which is the fyne.Resource which contains the icon data.\r\r\rEntry\r\rThe entry widget is used for user input of simple text content. An entry can be created with a simple widget.NewEntry() constructing function. When you create the widget keep a reference so that you can access its Text field later. It is also possible to use the OnChanged callback function to be notified every time the content changes. Entry widgets can also have validation for verifying the text input typed into it.\r\r\rChoices\r\rThere are various widgets available to present the user with a choice, these include a checkbox, radio group and select popup. The widget.Check provides a simple yes/no choice and is created using a string label. Each of these widgets also takes a \u0026ldquo;changed\u0026rdquo; func(...) where the parameter is of the appropriate type. widget.NewCheck(..) therefore takes a string parameter for the label and a func(bool) param for the change handler. You can also use the Checked field to get the boolean value.\r\r\rForm\r\rThe form widget is used to lay out many input fields with labels and optional cancel and submit buttons. In its most bare form it aligns labels to the left of each input widget. By setting OnCancel or OnSubmit the form will add a button bar with the specified handlers called when appropriate. The widget can be created with widget.NewForm(...) passing a list of widget.FormItems, or by using the \u0026amp;widget.Form{} syntax illustrated in the example.\r\r\rProgressBar\r\rThe progress bar widget has two forms, the standard progress bar shows the user which Value has been reached, from Min to Max. The default min is 0.0 and the max defaults to 1.0. To use the default values just call widget.NewProgressBar(). After creating you can set the Value field. To set up a custom range you can set Min and Max fields manually. The label will always show the percentage completion.\r\r\rToolbar\r\rThe toolbar widget creates a row of action buttons using icons to represent each. The widget.NewToolbar(...) constructor function takes a list of widget.ToolbarItem parameters. The builtin types of toolbar items are action, separator and spacer. The most used item is an action that is created using the widget.NewToolbarItemAction(..) function. An action takes two parameters, first being the icon resource to draw and the latter is the func() to call when tapped.\r\r\rList\r\rThe List widget is one of the toolkit\u0026rsquo;s collection widgets. These widgets are designed to help build really performant interfaces when lots of data is being presented. You can also see the Table and Tree widgets which have a similar API. Because of this design they are a little more complicated to use. The List uses callback functions to ask for data when it is required. There are 3 main callbacks, Length, CreateItem and UpdateItem.\r\r\rTable\r\rThe Table widget is like the List widget (another of the toolkit\u0026rsquo;s collection widgets) with a two-dimensional index. Like List this is designed to help build really performant interfaces when lots of data is being presented. Because of this the widget is not created with all the data embedded, but instead calls out to the data source when needed. The Table uses callback functions to ask for data when it is required.\r\r\r"},{"id":44,"href":"/fyne/docs/extend/custom-widget/","title":"Writing a Custom Widget","section":"Extending Fyne","content":"The standard widgets included with Fyne are designed to support standard user interactions and requirements. As a GUI often has to provide custom functionality it may be necessary to write a custom widget. This article outlines how.\nA widget is split into two areas - each implementing a standard interface - the fyne.Widget and the fyne.WidgetRenderer. The widget defines behaviour and state, with the renderer being used to define how it should be drawn to screen.\nfyne.Widget\r#\r\rA widget in Fyne is simply a stateful canvas object that has its rendering definition separated from the main logic. As you can see from the fyne.Widget interface there is not much that must be implemented.\ntype Widget interface { \tCanvasObject  \tCreateRenderer() WidgetRenderer } As a widget needs to be used like any other canvas item we inherit from the same interface. To save writing all the functions required we can make use of the widget.BaseWidget type which handles the basics.\nEach widget definition will contain much more than the interface requires. It is standard in a Fyne widget to export the fields which define behaviour (just like the primitives defined in the canvas package).\nFor example, look at the widget.Button type:\ntype Button struct { \tBaseWidget \tText string \tStyle ButtonStyle \tIcon fyne.Resource  \tOnTapped func() } You can see how each of these items store state about the widget behaviour but nothing about how it is rendered.\nfyne.WidgetRenderer\r#\r\rThe widget renderer is responsible for managing a list of fyne.CanvasObject primitives that come together to create the design of our widget. It is much like a fyne.Container with a custom layout and some additional theme handling.\nEvery widget must provide a renderer, but it is entirely possible to re-use a renderer from another widget - especially if your widget is a lightweight wrapper around another standard control.\ntype WidgetRenderer interface { \tLayout(Size) \tMinSize() Size  \tRefresh() \tObjects() []CanvasObject \tDestroy() } As you can see the Layout(Size) and MinSize() functions are similar to the fyne.Layout interface, without the []fyne.CanvasObject parameter - this is because a widget does need to be laid out but it controls which objects will be included.\nThe Refresh() method is triggered when the widget this renderer draws has changed or if the theme is altered. In either situation we may need to make adjustments to how it looks. Lastly the Destroy() method is called when this renderer is no longer needed so it should clear any resources that would otherwise leak.\nCompare again with the button widget - it\u0026rsquo;s fyne.WidgetRenderer implementation is based on the following type:\ntype buttonRenderer struct { \ticon *canvas.Image \tlabel *canvas.Text \tshadow *fyne.CanvasObject  \tobjects []fyne.CanvasObject \tbutton *Button } As you can see it has fields to cache the actual image, text and shadow canvas objects for drawing. It keeps track of the slice of objects required by fyne.WidgetRenderer as a convenience.\nLastly it keeps a reference to the widget.Button for all state information. In the Refresh() method it will update the graphical state based on any changes in the underlying widget.Button type.\nBring it together\r#\r\rA basic widget will extend the widget.BaseWidget type and declare any state that the widget holds. The CreateRenderer() function must exist and return a new fyne.WidgetRenderer instance. The widget and driver code in Fyne will ensure that this is cached accordingly - this method may be called many times (for example if a widget is hidden and then shown). If CreateRenderer() is called again you should return a new renderer instance as the old one may have been destroyed.\nTake care not to keep any important state in your renderer - animation tickers are well suited to that location but user state would not be. A widget that is hidden may have it\u0026rsquo;s renderer destroyed and if it is shown again the new renderer must be able to reflect the same widget state.\n"},{"id":45,"href":"/fyne/docs/explore/shortcuts/","title":"Adding Shortcuts to an App","section":"Exploring Fyne","content":"Shortcuts are common tasks that can be triggered by keyboard combinations or context menus. Shortcuts, much like keyboard events, can be attached to a focused element or registered on the Canvas to always be available in a Window.\nRegistering with a Canvas\r#\r\rThere are many standard shortcuts defined (such as fyne.ShortcutCopy) which are connected to standard keyboard shortcuts and right-click menus. The first step to adding a new Shortcut is to define the shortcut. For most uses this will be a keyboard triggered shortcut, which is a desktop extension. To do this we use desktop.CustomShortcut, for example to use the Tab key and Control modifier you might do the following:\n\tctrlTab := desktop.CustomShortcut{KeyName: fyne.KeyTab, Modifier: desktop.ControlModifier} Notice that this shortcut can be re-used so you could attach it to menus or other items as well. For this example we want it to be always available, so we register it with our window\u0026rsquo;s Canvas as follows:\n\tctrlTab := desktop.CustomShortcut{KeyName: fyne.KeyTab, Modifier: desktop.ControlModifier} \tw.Canvas().AddShortcut(\u0026amp;ctrlTab, func(shortcut fyne.Shortcut) { \tlog.Println(\u0026#34;We tapped Ctrl+Tab\u0026#34;) \t}) As you can see there are two parts to registering a shortcut in this way - passing the shortcut definition and also a callback function. If the user types the keyboard shortcut then the function will be called and the output printed.\nAdding shortcuts to an Entry\r#\r\rIt can also be helpful to have a shortcut apply only when the current item is focused. This approach can be used for any focusable widget, and is managed by extending that widget and adding a TypedShortcut handler. This is much like adding key handlers, except the value passed in will be a fyne.Shortcut.\ntype myEntry struct { \twidget.Entry }  func (m *myEntry) TypedShortcut(s fyne.Shortcut) { \tif _, ok := s.(*desktop.CustomShortcut); !ok { \tm.Entry.TypedShortcut(s) \treturn \t}  \tlog.Println(\u0026#34;Shortcut typed:\u0026#34;, s) } From the excerpt above you can see how a TypedShortcut handler might be implemented. Inside this function you should check whether the shortcut is of the custom type used earlier. If the shortcut is a standard one it\u0026rsquo;s a good idea to call the original shortcut handler (if the widget had one). With those checks done you can compare the shortcut with the various types you are handling (if there are multiple).\n"},{"id":46,"href":"/fyne/docs/started/testing/","title":"Testing Graphical Apps","section":"Getting Started","content":"Part of a good test suite is being able to quickly write tests and run them on a regular basis. Fyne\u0026rsquo;s API is designed to make testing applications easy. By separating component logic from it\u0026rsquo;s rendering definition we can load applications without actually displaying them and test the functionality completely.\nExample\r#\r\rWe can demonstrate unit testing by extending our Hello World app to include space for users to input their name to be greeted. We start by updating the user interface to have two elements, a Label for the greeting and an Entry for the name input. We display them, one above another, using container.NewVBox (a vertical box container). The updated user interface code will look as follows:\nfunc makeUI() (*widget.Label, *widget.Entry) { \treturn widget.NewLabel(\u0026#34;Hello world!\u0026#34;), \twidget.NewEntry() }  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello Person\u0026#34;)  \tw.SetContent(container.NewVBox(makeUI())) \tw.ShowAndRun() } To test this input behaviour we create a new file (with a name ending _test.go to mark it as tests) that defines a TestGreeter function.\npackage main  import (  \u0026#34;testing\u0026#34; )  func TestGreeting(t *testing.T) { } We can add an intial test that verifies the initial state, to do this we test the Text field of the Label that is returned from makeUI and error the test if it is not correct. Add the following code to your test method:\n\tout, in := makeUI()  \tif out.Text != \u0026#34;Hello world!\u0026#34; { \tt.Error(\u0026#34;Incorrect initial greeting\u0026#34;) \t} This test will pass - next we add to the test to validate the greeter. We use the Fyne fyne.io/fyne/v2/test package which assists in test scenarios, calling test.Type to simulate user input. The following test code will check that the output updates when the user\u0026rsquo;s name is input (be sure to add the import as well):\n\ttest.Type(in, \u0026#34;Andy\u0026#34;) \tif out.Text != \u0026#34;Hello Andy!\u0026#34; { \tt.Error(\u0026#34;Incorrect user greeting\u0026#34;) \t} You can run all of these tests using go test . - just like any other tests. Doing so you will now see a failure - because we did not add the greeter logic. Update the makeUI function to the following code:\nfunc makeUI() (*widget.Label, *widget.Entry) { \tout := widget.NewLabel(\u0026#34;Hello world!\u0026#34;) \tin := widget.NewEntry()  \tin.OnChanged = func(content string) { \tout.SetText(\u0026#34;Hello \u0026#34; + content + \u0026#34;!\u0026#34;) \t} \treturn out, in } Doing so you will see that the tests now pass. You can also run the full application (using go run .) and see the greeting update as you enter a name in the Entry field. Notice also that these tests all run without displaying a window or stealing your mouse - this is another benefit of the Fyne unit testing setup.\n"},{"id":47,"href":"/fyne/docs/container/center/","title":"Center","section":"Containers and Layout","content":"layout.CenterLayout organises all items in its container to be centered in the available space. The objects will be drawn in the order they are passed to the container, with the last being drawn top-most.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/layout\u0026#34; \t\u0026#34;fyne.io/fyne/v2/theme\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Center Layout\u0026#34;)  \timg := canvas.NewImageFromResource(theme.FyneLogo()) \timg.FillMode = canvas.ImageFillOriginal \ttext := canvas.NewText(\u0026#34;Overlay\u0026#34;, color.Black) \tcontent := container.New(layout.NewCenterLayout(), img, text)  \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } The center layout causes all items to stay at their minimum size, if you wish to expand items to fill the space then see layout.MaxLayout.\n"},{"id":48,"href":"/fyne/docs/binding/","title":"Data Binding","section":"Docs","content":"\r\rData Binding\r\rData binding is a powerful new addition to the Fyne toolkit that was introduced in version v2.0.0. By using data binding we can avoid manually managing many standard objects like Labels, Buttons and Lists. The builtin bindings support many primitive types (like Int, String, Float etc), lists (such as StringList, BoolList) as well as Map and Struct bindings. Each of these types can be created using a simple constructor function. For example to create a new string binding with a zero value you can use binding.\r\r\rBinding Simple Widgets\r\rThe simplest form of binding a widget is to pass it a bound item as a value instead of a static value. Many widgets provide a WithData constructor that will accept a typed data binding item. To set up the binding all you need to do is pass the right type in. Although this may not look like much of a benefit in the initial code you can then see how it ensures that the displayed content is always up to date with the source of the data.\r\r\rTwo-Way Binding\r\rSo far we have looked at data binding as a way of keeping our user interface elements up to date. Far more common, however, is the need to update values from the UI widgets and keep the data up to date everywhere. Thankfully the bindings provided in Fyne are \u0026ldquo;two-way\u0026rdquo; which means that values can be pushed into them as well as read out. The change in data will be communicated to all connected code without any additional code.\r\r\rData Conversion\r\rSo far we have used data binding where the type of data matches the output type (for example String and Label or Entry). Often it will be desirable to present data that is not already in the correct format. To do this the binding package provides a number of helpful conversion functions. Most commonly this will be used to convert different types of data into strings for displaying in Label or Entry widgets.\r\r\rList Data\r\rTo demonstrate how more complex types can be connected we will look at the List widget and how data binding can make it easier to use. Firstly we create a StringList data binding, which is a list of String data type. Once we have a data of list type we can connect this to the standard List widget. To do so we use the widget.NewListWithData constructor, much like other widgets.\r\r\r"},{"id":49,"href":"/fyne/docs/extend/numerical-entry/","title":"Numerical Entry","section":"Extending Fyne","content":"In the traditional sense, GUI programs have used callbacks to customize actions for widgets. Fyne does not expose inserting custom callbacks to capture events on widgets, but it does not need to. The Go language is plenty extensible to make this work.\nInstead we can simply use Type Embedding and extend the widget to only make it possible to enter numerical values.\nFirst create a new type struct, we will call it numericalEntry.\ntype numericalEntry struct {  widget.Entry } As mentioned in Extending existing widgets, we follow good practice and create a constructor function that extends the BaseWidget.\nfunc newNumericalEntry() *numericalEntry {  entry := \u0026amp;numericalEntry{}  entry.ExtendBaseWidget(entry)  return entry } Now we need to make the entry accept only numbers. This can be done by overriding the TypedRune(rune) method that\u0026rsquo;s part of the fyne.Focusable interface. This will allow us to intercept the standard handling of runes received from key presses and only pass through those that we want. Inside this method, we will use a conditional to check if the rune matches any of the numbers between zero and nine. If they do, we delegate it to the standard TypedRune(rune) method of the embeded entry. If they do not, we just ignore the inputs. This implementation will only allow integers to be entered, but can easily be extended to check for other keys in the future if necessary.\nfunc (e *numericalEntry) TypedRune(r rune) { \tswitch r { \tcase \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;: \te.Entry.TypedRune(r) \t} } If we want to update the implementation to allow for decimal numers as well, we can simply add . and , to the list of allowed runes (some languages use commas over dots for decimal notations).\nfunc (e *numericalEntry) TypedRune(r rune) { \tswitch r { \tcase \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;,\u0026#39;: \te.Entry.TypedRune(r) \t} } With this, the entry now only allows the user to enter numerical values when keys are pressed. However, the paste shortcut will still allow text to be entered. To fix this, we can overwrite the TypedShortcut(fyne.Shortcut) method that is part of the fyne.Shortcutable interface. First we need to do a type assertion to check if the given shortcut is of the type *fyne.ShortcutPaste. If it is not, we can just delegate the shortcut back to the embeded entry. If it is, we check if the clipboard content is numerical, by using strconv.ParseFloat() (if you want to only allow integers, strconv.Atoi() will be just fine), and then delegating the shortcut back to the embeded entry if the clipboard content could be parsed without errors.\nfunc (e *numericalEntry) TypedShortcut(shortcut fyne.Shortcut) { \tpaste, ok := shortcut.(*fyne.ShortcutPaste) \tif !ok { \te.Entry.TypedShortcut(shortcut) \treturn \t}  \tcontent := paste.Clipboard.Content() \tif _, err := strconv.ParseFloat(content, 64); err == nil { \te.Entry.TypedShortcut(shortcut) \t} } As a bonus, we can also make sure that mobile operating systems open the numerical keyboard instead of the default keyboard. This can be done by by first importng the fyne.io/fyne/v2/driver/mobile package and overwriting the Keyboard() mobile.KeyboardType method that is part of the mobile.Keyboardable interface. Inside the function, we then simply return the mobile.NumberKeyboard type.\nfunc (e *numericalEntry) Keyboard() mobile.KeyboardType { \treturn mobile.NumberKeyboard } In the end, the resulting code could look something like this:\npackage main  import ( \t\u0026#34;strconv\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  type numericalEntry struct { \twidget.Entry }  func newNumericalEntry() *numericalEntry { \tentry := \u0026amp;numericalEntry{} \tentry.ExtendBaseWidget(entry) \treturn entry }  func (e *numericalEntry) TypedRune(r rune) { \tswitch r { \tcase \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;,\u0026#39;: \te.Entry.TypedRune(r) \t} }  func (e *numericalEntry) TypedShortcut(shortcut fyne.Shortcut) { \tpaste, ok := shortcut.(*fyne.ShortcutPaste) \tif !ok { \te.Entry.TypedShortcut(shortcut) \treturn \t}  \tcontent := paste.Clipboard.Content() \tif _, err := strconv.ParseFloat(content, 64); err == nil { \te.Entry.TypedShortcut(shortcut) \t} }  func (e *numericalEntry) Keyboard() mobile.KeyboardType { \treturn mobile.NumberKeyboard }  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Numerical\u0026#34;)  \tentry := newNumericalEntry()  \tw.SetContent(entry) \tw.ShowAndRun() } "},{"id":50,"href":"/fyne/docs/widget/progressbar/","title":"ProgressBar","section":"Widgets","content":"The progress bar widget has two forms, the standard progress bar shows the user which Value has been reached, from Min to Max. The default min is 0.0 and the max defaults to 1.0. To use the default values just call widget.NewProgressBar(). After creating you can set the Value field.\nTo set up a custom range you can set Min and Max fields manually. The label will always show the percentage completion.\nThe other form of progress widget is the infinite progress bar. This version simply shows that some activity is ongoing by moving a segment of the bar from left to right and back again. You create this using widget.NewProgressBarInfinite() and it will start animating as soon as it is shown.\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;ProgressBar Widget\u0026#34;)  \tprogress := widget.NewProgressBar() \tinfinite := widget.NewProgressBarInfinite()  \tgo func() { \tfor i := 0.0; i \u0026lt;= 1.0; i += 0.1 { \ttime.Sleep(time.Millisecond * 250) \tprogress.SetValue(i) \t} \t}()  \tmyWindow.SetContent(container.NewVBox(progress, infinite)) \tmyWindow.ShowAndRun() } "},{"id":51,"href":"/fyne/docs/canvas/raster/","title":"Raster","section":"Drawing and Animation","content":"The canvas.Raster is like an image but draws exactly one spot for each pixel on the screen. This means that as a user interface scales or the image resizes more pixels will be requested to fill the space. To do this we use a Generator function as illustrated in this example - it will be used to return the colour of each pixel.\nThe generator functions can be pixel based (as in this example where we generate a new random colour for each pixel) or based on full images. Generating complete images (with canvas.NewRaster()) is more efficient but sometimes controlling pixels directly is more convenient.\npackage main  import ( \t\u0026#34;image/color\u0026#34; \t\u0026#34;math/rand\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Raster\u0026#34;)  \traster := canvas.NewRasterWithPixels( \tfunc(_, _, w, h int) color.Color { \treturn color.RGBA{uint8(rand.Intn(255)), \tuint8(rand.Intn(255)), \tuint8(rand.Intn(255)), 0xff} \t}) \t// raster := canvas.NewRasterFromImage() \tw.SetContent(raster) \tw.Resize(fyne.NewSize(120, 100)) \tw.ShowAndRun() } If your pixel data is stored in an image you can load it through the NewRasterFromImage() function which will load the image to display pixel perfect on screen.\n"},{"id":52,"href":"/fyne/docs/started/packaging/","title":"Packaging for Desktop","section":"Getting Started","content":"Packaging a graphical app for distribution can be complex. Graphical applications typically have icons and metadata associated with them as well as specific formats required to integrate with each environment. Windows executables need embedded icons, macOS apps are bundles and with Linux there are various metadata files that should get installed. What a hassle!\nThankfully the \u0026ldquo;fyne\u0026rdquo; app has a \u0026ldquo;package\u0026rdquo; command that can handle this automatically. Just specifying the target OS and any required metadata (such as icon) will generate the appropriate package. The icon conversion will be done automatically for .icns or .ico so just provide a .png file :). All you need is to have the application already built for the target platform\u0026hellip;\ngo install fyne.io/fyne/v2/cmd/fyne@latest\rfyne package -os darwin -icon myapp.png If you\u0026rsquo;re using an older version of Go (\u0026lt;1.16), you should install fyne using go get\ngo get fyne.io/fyne/v2/cmd/fyne\rfyne package -os darwin -icon myapp.png Will create myapp.app, a complete bundle structure for distribution to macOS users. You could then build the linux and Windows versions too\u0026hellip;\nfyne package -os linux -icon myapp.png\rfyne package -os windows -icon myapp.png These commands will create:\n myapp.tar.gz that contains a folder structure starting at usr/local/ that a Linux user could expand to the root of their system. myapp.exe (after the second build, which is required for a windows package) will have the icon and app metadata embedded.  If you just want to install the desktop app on your computer then you can make use of the helpful install subcommand. For example to install your current application system wide you could simply execute the following:\nfyne install -icon myapp.png All of these commands also support a default icon file of Icon.png so that you can avoid typing the parameter for each execution. Since Fyne 2.1 there is also a metadata file where you can set default options for your project.\nOf course you can still run your applications using the standard Go tools if you prefer.\n"},{"id":53,"href":"/fyne/docs/explore/preferences/","title":"Using the Preferences API","section":"Exploring Fyne","content":"Storing user configurations and values is a common task for application developers, but implementing it across multiple platforms can be tedious and time-consuming. To make it easier, Fyne has an API for storing values on the filesystem in a clean and understandable way while the complex parts are handled for you.\nLets start with the setup of the API. It is part of the Preferences interface where storage and loading functions exist for values of Bool, Float, Int and String. They each consist of three different functions, one for loading, one loading with a fallback value and lastly, one for storing values. An example of the three functions and their behaviour can be seen below for the String type:\n// String looks up a string value for the key String(key string) string // StringWithFallback looks up a string value and returns the given fallback if not found StringWithFallback(key, fallback string) string // SetString saves a string value for the given key SetString(key string, value string) These functions can be accessed through the created application variable and calling the Preferences() method on. Please note that it is necessary to create the apps with a unique ID (usually like a reversed url). This means that the application will need to be created using app.NewWithID() to have its own place to store values. It can roughly be used like the example below:\na := app.NewWithID(\u0026#34;com.example.tutorial.preferences\u0026#34;) [...] a.Preferences().SetBool(\u0026#34;Boolean\u0026#34;, true) number := a.Preferences().IntWithFallback(\u0026#34;ApplicationLuckyNumber\u0026#34;, 21) expression := a.Preferences().String(\u0026#34;RegularExpression\u0026#34;) [...] To show this, we are going to build a simple little app that always closes after a set amount of time. This timeout should be user changeable and applied on the next start of the application.\nLet us start by creating a variable called timeout that will be used to store time in the form of time.Duration.\nvar timeout time.Duration Then we could create a select widget to let the user select the timeout from a couple pre-defined strings and then multiplying the timeout by the number of seconds that the string relates to. Lastly, the \u0026quot;AppTimeout\u0026quot; key is used to set the string value to the selected one.\ntimeoutSelector := widget.NewSelect([]string{\u0026#34;10 seconds\u0026#34;, \u0026#34;30 seconds\u0026#34;, \u0026#34;1 minute\u0026#34;}, func(selected string) {  switch selected {  case \u0026#34;10 seconds\u0026#34;:  timeout = 10 * time.Second  case \u0026#34;30 seconds\u0026#34;:  timeout = 30 * time.Second  case \u0026#34;1 minute\u0026#34;:  timeout = time.Minute  }   a.Preferences().SetString(\u0026#34;AppTimeout\u0026#34;, selected) }) Now we want to grab the set value and if none exists, we want to have a fallback that sets the timeout to the shortest one possible to save the user time when waiting. This can be done by setting the selected value of timeoutSelector to the loaded value or the fallback if that happens to be the case. By doing it this way, the code inside the select widget will run for that specific value.\ntimeoutSelector.SetSelected(a.Preferences().StringWithFallback(\u0026#34;AppTimeout\u0026#34;, \u0026#34;10 seconds\u0026#34;)) The last part will just be to have a function that starts in a separate goroutine and tells the application to quit after the selected timeout.\ngo func() {  time.Sleep(timeout)  a.Quit() }() In the end, the resulting code should look something like this:\npackage main  import (  \u0026#34;time\u0026#34;   \u0026#34;fyne.io/fyne/v2/app\u0026#34;  \u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() {  a := app.NewWithID(\u0026#34;com.example.tutorial.preferences\u0026#34;)  w := a.NewWindow(\u0026#34;Timeout\u0026#34;)   var timeout time.Duration   timeoutSelector := widget.NewSelect([]string{\u0026#34;10 seconds\u0026#34;, \u0026#34;30 seconds\u0026#34;, \u0026#34;1 minute\u0026#34;}, func(selected string) {  switch selected {  case \u0026#34;10 seconds\u0026#34;:  timeout = 10 * time.Second  case \u0026#34;30 seconds\u0026#34;:  timeout = 30 * time.Second  case \u0026#34;1 minute\u0026#34;:  timeout = time.Minute  }   a.Preferences().SetString(\u0026#34;AppTimeout\u0026#34;, selected)  })   timeoutSelector.SetSelected(a.Preferences().StringWithFallback(\u0026#34;AppTimeout\u0026#34;, \u0026#34;10 seconds\u0026#34;))   go func() {  time.Sleep(timeout)  a.Quit()  }()   w.SetContent(timeoutSelector)  w.ShowAndRun() } "},{"id":54,"href":"/fyne/docs/canvas/animation/","title":"Animation","section":"Drawing and Animation","content":"Fyne includes an animation framework that allows you to smoothly transition canvas properties from one value to another over time. An animation can contain any code which means that any types of object attributes can be managed, however there are builtin animations for size, position and color.\nAnimations are normally created using the builtin helpers of the canvas package, such as NewSizeAnimation, and calling Start() on the created animation. You can set animations to repeat or auto reverse, as we will see below.\nLet us look first at a colour animation which gradually changes the fill colour of a Rectangle. In the following code sample we set an rectangle to be set as the content of a window, as we have done in earlier code samples. The big difference is the animation that we start just before showing the window. The animation is created using NewColorRGBAAnimation which will transition the colour channels from the defined red state through to blue and it will take 2 seconds (the specified duration) to do so.\npackage main  import ( \t\u0026#34;image/color\u0026#34; \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello\u0026#34;)  \tobj := canvas.NewRectangle(color.Black) \tobj.Resize(fyne.NewSize(50, 50)) \tw.SetContent(container.NewWithoutLayout(obj))  \tred := color.NRGBA{R:0xff, A:0xff} \tblue := color.NRGBA{B:0xff, A:0xff} \tcanvas.NewColorRGBAAnimation(red, blue, time.Second*2, func(c color.Color) { \tobj.FillColor = c \tcanvas.Refresh(obj) \t}).Start()  \tw.Resize(fyne.NewSize(250, 50)) \tw.SetPadded(false) \tw.ShowAndRun() } It is also possible to animate multiple properties at the same time. If you look carefully you will see that we added the rectangle into a container without layout - this means that we can manually move or resize the object. Let\u0026rsquo;s add a new position animation that will move the Rectangle across the window, and automatically reverse as well.\nmove := canvas.NewPositionAnimation(fyne.NewPos(0, 0), fyne.NewPos(200, 0), time.Second, obj.Move) move.AutoReverse = true move.Start() Because the Move() function of CanvasObject expects a fyne.Position argument, and so does the position animation callback, we can simply pass the method name instead of creating a new function If you add the code above just under the first animation you will see that the object moves across the window at the same time as it changes colour!\n"},{"id":55,"href":"/fyne/docs/extend/","title":"Extending Fyne","section":"Docs","content":"\r\rBuilding a Custom Layout\r\rIn a Fyne application each Container arranges it\u0026rsquo;s child elements using a simple layout algorithm. Fyne defines many layouts available in the fyne.io/fyne/v2/layout package. If you look at the code you will see that they all implement the Layout interface. type Layout interface { Layout([]CanvasObject, Size) MinSize(objects []CanvasObject) Size } Any application can provide a custom layout to arrange widgets in a non-standard manner. To do this you need to implement the interface above in your own code.\r\r\rBundling resources\r\rGo based applications are usually built as a single binary executable, and this is the same for Fyne applications. A single file makes it easier to distribute install our software. Unfortunately GUI applications typically require additional resources to render the user interface. To manage this challenge a Go application can bundle assets into the binary itself. The Fyne toolkit prefers the use of \u0026ldquo;fyne bundle\u0026rdquo; as it has various benefits that we will explore below.\r\r\rCreating a Custom Theme\r\rApplications are able to load custom themes that can apply small changes to the standard theme or provide a completely unique look. A theme will need to implement the functions of fyne.Theme interface, which is defined as follows: type Theme interface { Color(ThemeColorName, ThemeVariant) color.Color Font(TextStyle) Resource Icon(ThemeIconName) Resource Size(ThemeSizeName) float32 } To apply our theme changes we will first define a new type that that implements this interface.\r\r\rWriting a Custom Widget\r\rThe standard widgets included with Fyne are designed to support standard user interactions and requirements. As a GUI often has to provide custom functionality it may be necessary to write a custom widget. This article outlines how. A widget is split into two areas - each implementing a standard interface - the fyne.Widget and the fyne.WidgetRenderer. The widget defines behaviour and state, with the renderer being used to define how it should be drawn to screen.\r\r\rNumerical Entry\r\rIn the traditional sense, GUI programs have used callbacks to customize actions for widgets. Fyne does not expose inserting custom callbacks to capture events on widgets, but it does not need to. The Go language is plenty extensible to make this work. Instead we can simply use Type Embedding and extend the widget to only make it possible to enter numerical values. First create a new type struct, we will call it numericalEntry.\r\r\rExtending Widgets\r\rThe standard Fyne widgets provide the minimum functionality and customisation to support most use-cases. It may be required at certain times to have more advanced functionality. Rather than have developers build their own widgets it is possible to extend the existing ones. For example we will extend the icon widget to support being tapped. To do this we declare a new struct that embeds the widget.Icon type. We create a constructor function that calls the important ExtendBaseWidget function.\r\r\r"},{"id":56,"href":"/fyne/docs/canvas/gradient/","title":"Gradient","section":"Drawing and Animation","content":"The last canvas primitive type is Gradient, available as canvas.LinearGradient and canvas.RadialGradient which is used to draw a gradient from one colour to another in various patterns. You can create gradients using NewHorizontalGradient(), NewVerticalGradient() or NewRadialGradient().\nTo create a gradient you need a start and end colour - every colour in between is calculated by the canvas. In this example we use color.Transparent to show how a gradient (or any other type) could use an alpha value to be semi-transparent over the content behind.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; )  func main() { \tmyApp := app.New() \tw := myApp.NewWindow(\u0026#34;Gradient\u0026#34;)  \tgradient := canvas.NewHorizontalGradient(color.White, color.Transparent) \t//gradient := canvas.NewRadialGradient(color.White, color.Transparent) \tw.SetContent(gradient)  \tw.Resize(fyne.NewSize(100, 100)) \tw.ShowAndRun() } "},{"id":57,"href":"/fyne/docs/container/max/","title":"Max","section":"Containers and Layout","content":"The layout.MaxLayout is the simplest layout, it sets all items in the container to be the same size as the container. This is not often useful in general containers but can be suitable when composing widgets.\nThe max layout will expand the container to be at least the size of the largest item\u0026rsquo;s minimum size. The objects will be drawn in the order the are passed to the container, with the last being drawn top-most.\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/layout\u0026#34; \t\u0026#34;fyne.io/fyne/v2/theme\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Max Layout\u0026#34;)  \timg := canvas.NewImageFromResource(theme.FyneLogo()) \ttext := canvas.NewText(\u0026#34;Overlay\u0026#34;, color.Black) \tcontent := container.New(layout.NewMaxLayout(), img, text)  \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } "},{"id":58,"href":"/fyne/docs/widget/toolbar/","title":"Toolbar","section":"Widgets","content":"The toolbar widget creates a row of action buttons using icons to represent each. The widget.NewToolbar(...) constructor function takes a list of widget.ToolbarItem parameters. The builtin types of toolbar items are action, separator and spacer.\nThe most used item is an action that is created using the widget.NewToolbarItemAction(..) function. An action takes two parameters, first being the icon resource to draw and the latter is the func() to call when tapped. This creates a standard toolbar button.\nYou can use widget.NewToolbarSeparator() to create a small divider between items in a toolbar (usually a thin vertical line). Lastly you can use widget.NewToolbarSpacer() to create a flexible space between elements. This is most useful to right align the toolbar items that are listed after the spacer.\nA toolbar should always be at the top of the content area so it\u0026rsquo;s normal to add it to a fyne.Container using the layout.BorderLayout to align it above other content.\npackage main  import ( \t\u0026#34;log\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t\u0026#34;fyne.io/fyne/v2/theme\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Toolbar Widget\u0026#34;)  \ttoolbar := widget.NewToolbar( \twidget.NewToolbarAction(theme.DocumentCreateIcon(), func() { \tlog.Println(\u0026#34;New document\u0026#34;) \t}), \twidget.NewToolbarSeparator(), \twidget.NewToolbarAction(theme.ContentCutIcon(), func() {}), \twidget.NewToolbarAction(theme.ContentCopyIcon(), func() {}), \twidget.NewToolbarAction(theme.ContentPasteIcon(), func() {}), \twidget.NewToolbarSpacer(), \twidget.NewToolbarAction(theme.HelpIcon(), func() { \tlog.Println(\u0026#34;Display help\u0026#34;) \t}), \t)  \tcontent := container.NewBorder(toolbar, nil, nil, nil, widget.NewLabel(\u0026#34;Content\u0026#34;)) \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } "},{"id":59,"href":"/fyne/docs/explore/compiling/","title":"Compile Options","section":"Exploring Fyne","content":"Build tags\r#\r\rFyne will typically configure your application appropriately for the target platform by selecting the driver and configuration. The following build tags are supported and can help in your development. For example if you wish to simulate a mobile application whilst running on a desktop computer you could use the following command:\ngo run -tags mobile main.go\r    Tag Description     gles Force use of embedded OpenGL (GLES) instead of full OpenGL. This is normally controlled by the target device and not normally needed.   hints Display developer hints for improvements or optimisations. Running with hints will log when your application does not follow material design or other recommendations.   mobile This tag runs an application in a simulated mobile window. Useful when you want to preview your app on a mobile platform without compiling and installing to the device.   no_native_menus This flag is specifically for macOS and indicates that the application should not use the macOS native menus. Instead menus will be displayed inside the application window. Most useful for testing an application on macOS to simulate the behavior on Windows or Linux.    "},{"id":60,"href":"/fyne/docs/explore/binding/","title":"Data Binding","section":"Exploring Fyne","content":"Data binding was introduced in Fyne v2.0.0 and makes it easier to connect many widgets to a data source that will update over time. the data/binding package has many helpful bindings that can manage most standard types that will be used in an application. A data binding can be managed using the binding API (for example NewString) or it can be connected to an external item of data like (`BindInt(*int)).\nWidgets that support binding typically have a ...WithData constructor to set up the binding when creating the widget. You can also call Bind() and Unbind() to manage the data of an existing widget. The following example shows how you can manage a String data item that is bound to a simple Label widget.\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello\u0026#34;)  \tstr := binding.NewString() \tgo func() { \tdots := \u0026#34;.....\u0026#34; \tfor i := 5; i \u0026gt;= 0; i-- { \tstr.Set(\u0026#34;Count down\u0026#34; + dots[:i]) \ttime.Sleep(time.Second) \t} \tstr.Set(\u0026#34;Blast off!\u0026#34;) \t}()  \tw.SetContent(widget.NewLabelWithData(str)) \tw.ShowAndRun() } You can find out more in the data binding section of this site.\n"},{"id":61,"href":"/fyne/docs/started/mobile/","title":"Packaging Mobile Apps","section":"Getting Started","content":"Your Fyne app code will work out of the box as mobile apps, just as it did for desktop. However it is a little more complex to package the code for distribution. This page will explore the process to do just that to get your app on iOS and Android.\nFirstly you will need some more development tools installed for mobile packaging to complete. For Android builds you must have the Android SDK and NDK installed with appropriate environment set up so that the tools (such as adb) can be found on the command line. To build iOS apps you will need Xcode installed on your macOS computer as well as the command line tools optional package.\nOnce you have a working development environment the packaging is simple. To build an application for Android and iOS the following commands will do everything for you. Be sure to have a unique application identifier as it is unwise to change these after your first release.\nfyne package -os android -appID com.example.myapp -icon mobileIcon.png\rfyne package -os ios -appID com.example.myapp -icon mobileIcon.png After these commands have completed (which may take some time on first compilation) you will see two new files in your directory, myapp.apk and myapp.app. You will see that the latter has the same name as a darwin application bundle - don\u0026rsquo;t get them confused as they will not work on the other platform.\nTo install the android app on your phone or a simulator simply call:\nadb install myapp.apk For iOS to install on device open Xcode and choose the \u0026ldquo;Devices and Simulators\u0026rdquo; menu item within the \u0026ldquo;Window\u0026rdquo; menu. Then find your phone and drag the myapp.app icon onto your app list. To install on a simulator you can use the command line tools as follows:\nxcrun simctl install booted myapp.app "},{"id":62,"href":"/fyne/docs/container/apptabs/","title":"AppTabs","section":"Containers and Layout","content":"The AppTabs container is used to allow the user to switch between different content panels. Tabs are either just text or text and an icon. It is recommended not to mix some tabs having icons and some without. A tab container is created using container.NewAppTabs(...) and passing container.TabItem items (that can be created using container.NewTabItem(...)).\nThe tab container can be configured by setting the location of tabs, one of container.TabLocationTop, container.TabLocationBottom, container.TabLocationLeading and container.TabLocationTrailing. The default location is top.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t//\u0026#34;fyne.io/fyne/v2/theme\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;TabContainer Widget\u0026#34;)  \ttabs := container.NewAppTabs( \tcontainer.NewTabItem(\u0026#34;Tab 1\u0026#34;, widget.NewLabel(\u0026#34;Hello\u0026#34;)), \tcontainer.NewTabItem(\u0026#34;Tab 2\u0026#34;, widget.NewLabel(\u0026#34;World!\u0026#34;)), \t)  \t//tabs.Append(container.NewTabItemWithIcon(\u0026#34;Home\u0026#34;, theme.HomeIcon(), widget.NewLabel(\u0026#34;Home tab\u0026#34;)))  \ttabs.SetTabLocation(container.TabLocationLeading)  \tmyWindow.SetContent(tabs) \tmyWindow.ShowAndRun() } When loaded on a mobile device the tab location may be ignored. In a portrait orientation a leading or trailing position will be changed to bottom. When in landscape orientation, the top or bottom positions will be moved to leading.\n"},{"id":63,"href":"/fyne/docs/architecture/","title":"Architecture","section":"Docs","content":"\r\rGeometry\r\rFyne apps are based on 1 canvas per window. Each canvas has a root CanvasObject which can be a single widget or a Container for many sub-objects whose size and position are controlled by a Layout. Position\r#\rEach canvas has its origin at the top left (0, 0) every element of the UI may be scaled depending on the output device and so the API does not describe pixels or exact measurements.\r\r\rScaling\r\rFyne is built entirely using vector graphics, which means applications written with Fyne will scale to any size beautifully (not just whole number increments). This is a great benefit to the rising popularity of high density displays on mobile devices and high-end computers. The default scale value is calculated to match your operating system - on some systems this is user configuration and on others from your screen\u0026rsquo;s pixel density (DPI - dots per inch).\r\r\rWidgets\r\rWidgets in the Fyne toolkit are designed for a clean and pleasant user interaction, following a standard theme and supporting rapid app development, solid testing and easy maintenance. There are various design considerations that promote that ambition, we explore them in this page. Behaviour API\r#\rOne thing that you will notice about the standard widgets is that the API is all about behaviour and state - but very little that controls the actual look of an element.\r\r\rOrganisation and Packages\r\rThe Fyne project is split into many packages, each providing different types of functionality. They are as follows: fyne.io/fyne/v2 This import provides the basic definitions common to all Fyne code including data types and interfaces. fyne.io/fyne/v2/app The app package provides the APIs that start a new application. Normally you only require app.New() or app.NewWithID(). fyne.io/fyne/v2/canvas The canvas package provides all of the drawing APIs within Fyne. The complete Fyne toolkit is made up of these primitive graphical types.\r\r\r"},{"id":64,"href":"/fyne/docs/widget/list/","title":"List","section":"Widgets","content":"The List widget is one of the toolkit\u0026rsquo;s collection widgets. These widgets are designed to help build really performant interfaces when lots of data is being presented. You can also see the Table and Tree widgets which have a similar API. Because of this design they are a little more complicated to use.\nThe List uses callback functions to ask for data when it is required. There are 3 main callbacks, Length, CreateItem and UpdateItem. The Length callback (passed first) is the simplest, it returns how many items are in the data to be presented. The others relate to templates - how graphical elements are created, cached and re-used.\nThe CreateItem callback returns a new template object. This will be re-used with real data when the widget is presented. The MinSize of this object will influence the List minimum size. Lastly UpdateItem is called to apply an item of data to a cached template. Use this to set the content ready for display.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  var data = []string{\u0026#34;a\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;list\u0026#34;}  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;List Widget\u0026#34;)  \tlist := widget.NewList( \tfunc() int { \treturn len(data) \t}, \tfunc() fyne.CanvasObject { \treturn widget.NewLabel(\u0026#34;template\u0026#34;) \t}, \tfunc(i widget.ListItemID, o fyne.CanvasObject) { \to.(*widget.Label).SetText(data[i]) \t})  \tmyWindow.SetContent(list) \tmyWindow.ShowAndRun() } "},{"id":65,"href":"/fyne/docs/started/distribution/","title":"Distributing to App Stores","section":"Getting Started","content":"Packaging a graphical app as described in the Packaging page provides a file or bundle that could be directly shared or distributed. However signing and uploading to app stores and market places is an additional step that requires platform-specific configuration, which we will cover in this page.\nIn each of these steps we will use a new tool that is part of the fyne command line utilities. The fyne release step handles the signing and preparation for each store, but the parameters vary per-platform, which we see below.\nmacOS App Store (since fyne 1.4.2)\r#\r\rPrerequisites:\n Apple mac running macOS and Xcode Apple Developer account Mac App Store application certificate Mac App Store installer certificate Apple Transporter app from App Store     2. Bundle the completed app for release:\n$ fyne release -appID com.example.myapp -appVersion 1.0 -appBuild 1 -category games 3. Drag the .pkg onto Transporter and tap \u0026ldquo;Deliver\u0026rdquo;.\n4. Go to back to the AppStore Connect website, choose your build for the release and submit for review.\nGoogle Play Store (Android)\r#\r\rPrerequisites:\n Google Play Console account distribution keystore (creation instructions in android docs)  1. Set up your app / version ready for build to be uploaded at Google Play Console. Turn off \u0026ldquo;Play app signing\u0026rdquo; option as we manage it ourselves.\n2. Bundle the completed app for release:\n$ fyne release -os android -appID com.example.myapp -appVersion 1.0 -appBuild 1 3. Drag the .apk file into the build drop zone on the app version page in Play Console\n4. Start rollout of new version.\niOS App Store (since fyne 1.4.1)\r#\r\rPrerequisites:\n Apple mac running macOS and Xcode Apple Developer account iOS App Store distribution certificate Apple Transporter app from App Store  1. Set up your app / version ready for a build to be uploaded at AppStore Connect.\n2. Bundle the completed app for release:\n$ fyne release -os ios -appID com.example.myapp -appVersion 1.0 -appBuild 1 3. Drag the .ipa onto Transporter and tap \u0026ldquo;Deliver\u0026rdquo;.\n4. Go to back to the AppStore Connect website, choose your build for the release and submit for review.\n"},{"id":66,"href":"/fyne/docs/faq/","title":"Frequently Asked Questions","section":"Docs","content":"\r\rLayout and Widget Size\r\rIntro Move and Resize\r#\rQ: How can I move my widget to a different position or resize it? A: The position and size of elements in a Fyne app are controlled by the layout of the container that they are within. If the elements of your UI are too small consider using a different layout or container. A new Window will expand whatever element is passed to SetContent() to fill it\u0026rsquo;s size.\r\r\rTheme and Customisation\r\rIn this page we answer some common questions about the design of Fyne themes and widgets. Customisation\r#\rQ: How can I change the colour of text for a Label widget? A: All of the standard widgets use the current Theme definition to set the colour, font and sizes. To make changes to your application consider using a custom theme. If your application requires text that is a different colour you can use the canvas.\r\r\rFrequently Asked Questions\r\rAs the Fyne toolkit presents a different approach to the traditional design of GUI tookits in some ways we have compiled this selection of answers to frequently asked questions. The content is grouped into the following areas. Layout and widget size Theme and customisation If you have more questions please get in touch.\r\r\r"},{"id":67,"href":"/fyne/docs/widget/table/","title":"Table","section":"Widgets","content":"The Table widget is like the List widget (another of the toolkit\u0026rsquo;s collection widgets) with a two-dimensional index. Like List this is designed to help build really performant interfaces when lots of data is being presented. Because of this the widget is not created with all the data embedded, but instead calls out to the data source when needed.\nThe Table uses callback functions to ask for data when it is required. There are 3 main callbacks, Length, CreateCell and UpdateCell. The Length callback (passed first) is the simplest, it returns how many items are in the data to be presented, the two ints it returns represent the row and colum count. The other two relate to the content templates.\nThe CreateCell callback returns a new template object, just like list. The difference being that MinSize will define the standard size of each cell, and the minimum size of the table (it shows at least one cell). As previously the UpdateCell is called to apply data to a cell template. The index passed in is the same (row, col) int pair.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  var data = [][]string{[]string{\u0026#34;top left\u0026#34;, \u0026#34;top right\u0026#34;}, \t[]string{\u0026#34;bottom left\u0026#34;, \u0026#34;bottom right\u0026#34;}}  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Table Widget\u0026#34;)  \tlist := widget.NewTable( \tfunc() (int, int) { \treturn len(data), len(data[0]) \t}, \tfunc() fyne.CanvasObject { \treturn widget.NewLabel(\u0026#34;wide content\u0026#34;) \t}, \tfunc(i widget.TableCellID, o fyne.CanvasObject) { \to.(*widget.Label).SetText(data[i.Row][i.Col]) \t})  \tmyWindow.SetContent(list) \tmyWindow.ShowAndRun() } "},{"id":68,"href":"/fyne/docs/started/metadata/","title":"App Metadata","section":"Getting Started","content":"App Metadata\r#\r\rSince release v2.1.0 of the fyne command we support a metadata file that allows you to store information about your application in the repository. This file is optional, but can help to avoid having to remember specific build parameters for each package and release command.\nThe file should be named FyneApp.toml in the directory where you run the fyne command (this is normally the main package). The contents of the file are as follows:\nWebsite = \u0026#34;https://darcybook.github.io\u0026#34;  [Details] Icon = \u0026#34;Icon.png\u0026#34; Name = \u0026#34;My App\u0026#34; ID = \u0026#34;com.example.app\u0026#34; Version = \u0026#34;1.0.0\u0026#34; Build = 1 The top portion of the file is metadata that will be used if you upload your app to the https://apps.fyne.io listing page, so it is optional. The [Details] section contains data about your application that are used in the release process by other app stores and operating systems. The fyne tool will use this file if it is found, many mandatory command parameters are not required if the metadata is present. You can still override these values by using command line parameters.\n"},{"id":69,"href":"/fyne/docs/api/","title":"API Documentation","section":"Docs","content":"\r\rapp\r\rapp\rapp\r#\rimport \u0026#34;fyne.io/fyne/v2/app\u0026#34; Package app provides app implementations for working with Fyne graphical interfaces. The fastest way to get started is to call app.New() which will normally load a new desktop application. If the \u0026ldquo;ci\u0026rdquo; tag is passed to go (go run -tags ci myapp.go) it will run an in-memory application. Usage\r#\rfunc New\r#\rfunc New() fyne.App New returns a new application instance with the default driver and no unique ID\rapp.\r\r\rcanvas\r\rcanvas\rcanvas\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Package canvas contains all of the primitive CanvasObjects that make up a Fyne GUI The types implemented in this package are used as building blocks in order to build higher order functionality. These types are designed to be non-interactive, by design. If additional functonality is required, it\u0026rsquo;s usually a sign that this type should be used as part of a custom Widget. Usage\r#\rconst ( // DurationStandard is the time a standard interface animation will run.\r\r\rcontainer\r\rcontainer\rcontainer\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Package container provides container widgets that are used to lay out and organise applications Usage\r#\rconst ( // ScrollBoth supports horizontal and vertical scrolling. ScrollBoth ScrollDirection = widget.ScrollBoth // ScrollHorizontalOnly specifies the scrolling should only happen left to right. ScrollHorizontalOnly = widget.ScrollHorizontalOnly // ScrollVerticalOnly specifies the scrolling should only happen top to bottom. ScrollVerticalOnly = widget.ScrollVerticalOnly // ScrollNone turns off scrolling for this container.\r\r\rdata\r\rbinding\rbinding\rbinding\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtypes\r#\rBool BoolList DataItem DataList DataListener DataMap ExternalBool ExternalBoolList ExternalFloat ExternalFloatList ExternalInt ExternalIntList ExternalRune ExternalRuneList ExternalString ExternalStringList ExternalURI ExternalURIList ExternalUntyped ExternalUntypedList ExternalUntypedMap Float FloatList Int IntList Rune RuneList String StringList Struct URI URIList Untyped UntypedList UntypedMap binding.Bool\rbinding.Bool\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype Bool\r#\rtype Bool interface { DataItem Get() (bool, error) Set(bool) error } Bool supports binding a bool value.\r\r\rdialog\r\rdialog\rdialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Package dialog defines standard dialog windows for application GUIs. Usage\r#\rfunc ShowColorPicker\r#\rfunc ShowColorPicker(title, message string, callback func(c color.Color), parent fyne.Window) ShowColorPicker creates and shows a color dialog. The callback is triggered when the user selects a color. Since: 1.4\rfunc ShowConfirm\r#\rfunc ShowConfirm(title, message string, callback func(bool), parent fyne.Window) ShowConfirm shows a dialog over the specified window for a user confirmation.\r\r\rdriver\r\rdesktop\rdesktop\rdesktop\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Package desktop provides desktop specific driver functionality. Usage\r#\rconst ( // KeyNone represents no key KeyNone fyne.KeyName = \u0026#34;\u0026#34; // KeyShiftLeft represents the left shift key KeyShiftLeft fyne.KeyName = \u0026#34;LeftShift\u0026#34; // KeyShiftRight represents the right shift key KeyShiftRight fyne.KeyName = \u0026#34;RightShift\u0026#34; // KeyControlLeft represents the left control key KeyControlLeft fyne.KeyName = \u0026#34;LeftControl\u0026#34; // KeyControlRight represents the right control key KeyControlRight fyne.\r\r\rfyne\r\rfyne\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Package fyne describes the objects and components available to any Fyne app. These can all be created, manipulated and tested without rendering (for speed). Your main package should use the app package to create an application with a default driver that will render your UI. A simple application may look like this: package main import \u0026#34;fyne.io/fyne/v2/app\u0026#34; import \u0026#34;fyne.io/fyne/v2/container\u0026#34; import \u0026#34;fyne.\r\r\rfyne.Animation\r\rfyne.Animation\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Animation\r#\rtype Animation struct { AutoReverse bool Curve AnimationCurve Duration time.Duration RepeatCount int Tick func(float32) } Animation represents an animated element within a Fyne canvas. These animations may control individual objects or entire scenes. Since: 2.0\rfunc NewAnimation\r#\rfunc NewAnimation(d time.Duration, fn func(float32)) *Animation NewAnimation creates a very basic animation where the callback function will be called for every rendered frame between time.\r\r\rfyne.AnimationCurve\r\rfyne.AnimationCurve\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype AnimationCurve\r#\rtype AnimationCurve func(float32) float32 AnimationCurve represents an animation algorithm for calculating the progress through a timeline. Custom animations can be provided by implementing the \u0026ldquo;func(float32) float32\u0026rdquo; definition. The input parameter will start at 0.0 when an animation starts and travel up to 1.0 at which point it will end. A linear animation would return the same output value as is passed in.\r\r\rfyne.App\r\rfyne.App\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype App\r#\rtype App interface { // Create a new window for the application. // The first window to open is considered the \u0026#34;master\u0026#34; and when closed // the application will exit. NewWindow(title string) Window // Open a URL in the default browser application. OpenURL(url *url.URL) error // Icon returns the application icon, this is used in various ways // depending on operating system.\r\r\rfyne.BuildType\r\rfyne.BuildType\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype BuildType\r#\rtype BuildType int BuildType defines different modes that an application can be built using. const ( // BuildStandard is the normal build mode - it is not debug, test or release mode. BuildStandard BuildType = iota // BuildDebug is used when a developer would like more information and visual output for app debugging. BuildDebug // BuildRelease is a final production build, it is like BuildStandard but will use distribution certificates.\r\r\rfyne.Canvas\r\rfyne.Canvas\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Canvas\r#\rtype Canvas interface { Content() CanvasObject SetContent(CanvasObject) Refresh(CanvasObject) // Focus makes the provided item focused. // The item has to be added to the contents of the canvas before calling this. Focus(Focusable) // FocusNext focuses the next focusable item. // If no item is currently focused, the first focusable item is focused.\r\r\rfyne.CanvasObject\r\rfyne.CanvasObject\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype CanvasObject\r#\rtype CanvasObject interface { // MinSize returns the minimum size this object needs to be drawn. MinSize() Size // Move moves this object to the given position relative to its parent. // This should only be called if your object is not in a container with a layout manager. Move(Position) // Position returns the current position of the object relative to its parent.\r\r\rfyne.Clipboard\r\rfyne.Clipboard\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Clipboard\r#\rtype Clipboard interface { // Content returns the clipboard content Content() string // SetContent sets the clipboard content SetContent(content string) } Clipboard represents the system clipboard interface\r\r\rfyne.Container\r\rfyne.Container\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Container\r#\rtype Container struct { Hidden bool // Is this Container hidden Layout Layout // The Layout algorithm for arranging child CanvasObjects Objects []CanvasObject // The set of CanvasObjects this container holds } Container is a CanvasObject that contains a collection of child objects. The layout of the children is set by the specified Layout.\r\r\rfyne.Delta\r\rfyne.Delta\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Delta\r#\rtype Delta struct { DX, DY float32 } Delta is a generic X, Y coordinate, size or movement representation. func NewDelta\r#\rfunc NewDelta(dx float32, dy float32) Delta NewDelta returns a newly allocated Delta representing a movement in the X and Y axis. func (Delta) Components\r#\rfunc (v Delta) Components() (float32, float32) Components returns the X and Y elements of this Delta.\r\r\rfyne.Device\r\rfyne.Device\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Device\r#\rtype Device interface { Orientation() DeviceOrientation IsMobile() bool HasKeyboard() bool SystemScaleForWindow(Window) float32 } Device provides information about the devices the code is running on func CurrentDevice\r#\rfunc CurrentDevice() Device CurrentDevice returns the device information for the current hardware (via the driver)\r\r\rfyne.DeviceOrientation\r\rfyne.DeviceOrientation\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype DeviceOrientation\r#\rtype DeviceOrientation int DeviceOrientation represents the different ways that a mobile device can be held const ( // OrientationVertical is the default vertical orientation OrientationVertical DeviceOrientation = iota // OrientationVerticalUpsideDown is the portrait orientation held upside down OrientationVerticalUpsideDown // OrientationHorizontalLeft is used to indicate a landscape orientation with the top to the left OrientationHorizontalLeft // OrientationHorizontalRight is used to indicate a landscape orientation with the top to the right OrientationHorizontalRight ) \r\rfyne.Disableable\r\rfyne.Disableable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Disableable\r#\rtype Disableable interface { Enable() Disable() Disabled() bool } Disableable describes any CanvasObject that can be disabled. This is primarily used with objects that also implement the Tappable interface.\r\r\rfyne.DoubleTappable\r\rfyne.DoubleTappable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype DoubleTappable\r#\rtype DoubleTappable interface { DoubleTapped(*PointEvent) } DoubleTappable describes any CanvasObject that can also be double tapped.\r\r\rfyne.DragEvent\r\rfyne.DragEvent\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype DragEvent\r#\rtype DragEvent struct { PointEvent Dragged Delta } DragEvent defines the parameters of a pointer or other drag event. The DraggedX and DraggedY fields show how far the item was dragged since the last event.\r\r\rfyne.Draggable\r\rfyne.Draggable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Draggable\r#\rtype Draggable interface { Dragged(*DragEvent) DragEnd() } Draggable indicates that a CanvasObject can be dragged. This is used for any item that the user has indicated should be moved across the screen.\r\r\rfyne.Driver\r\rfyne.Driver\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Driver\r#\rtype Driver interface { // CreateWindow creates a new UI Window. CreateWindow(string) Window // AllWindows returns a slice containing all app windows. AllWindows() []Window // RenderedTextSize returns the size required to render the given string of specified // font size and style. It also returns the height to text baseline, measured from the top.\r\r\rfyne.Focusable\u0026#34;\r\rfyne.Focusable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Focusable\r#\rtype Focusable interface { // FocusGained is a hook called by the focus handling logic after this object gained the focus. FocusGained() // FocusLost is a hook called by the focus handling logic after this object lost the focus. FocusLost() // TypedRune is a hook called by the input handling logic on text input events if this object is focused.\r\r\rfyne.HardwareKey\r\rfyne.HardwareKey\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype HardwareKey\r#\rtype HardwareKey struct { // ScanCode represents a hardware ID for (normally desktop) keyboard events. ScanCode int } HardwareKey contains information associated with physical key events Most applications should use KeyName for cross-platform compatibility.\r\r\rfyne.KeyEvent\r\rfyne.KeyEvent\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype KeyEvent\r#\rtype KeyEvent struct { // Name describes the keyboard event that is consistent across platforms. Name KeyName // Physical is a platform specific field that reports the hardware information of physical keyboard events. Physical HardwareKey } KeyEvent describes a keyboard input event.\r\r\rfyne.KeyName\r\rfyne.KeyName\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype KeyName\r#\rtype KeyName string KeyName represents the name of a key that has been pressed const ( // KeyEscape is the \u0026#34;esc\u0026#34; key KeyEscape KeyName = \u0026#34;Escape\u0026#34; // KeyReturn is the carriage return (main keyboard) KeyReturn KeyName = \u0026#34;Return\u0026#34; // KeyTab is the tab advance key KeyTab KeyName = \u0026#34;Tab\u0026#34; // KeyBackspace is the delete-before-cursor key KeyBackspace KeyName = \u0026#34;BackSpace\u0026#34; // KeyInsert is the insert mode key KeyInsert KeyName = \u0026#34;Insert\u0026#34; // KeyDelete is the delete-after-cursor key KeyDelete KeyName = \u0026#34;Delete\u0026#34; // KeyRight is the right arrow key KeyRight KeyName = \u0026#34;Right\u0026#34; // KeyLeft is the left arrow key KeyLeft KeyName = \u0026#34;Left\u0026#34; // KeyDown is the down arrow key KeyDown KeyName = \u0026#34;Down\u0026#34; // KeyUp is the up arrow key KeyUp KeyName = \u0026#34;Up\u0026#34; // KeyPageUp is the page up num-pad key KeyPageUp KeyName = \u0026#34;Prior\u0026#34; // KeyPageDown is the page down num-pad key KeyPageDown KeyName = \u0026#34;Next\u0026#34; // KeyHome is the line-home key KeyHome KeyName = \u0026#34;Home\u0026#34; // KeyEnd is the line-end key KeyEnd KeyName = \u0026#34;End\u0026#34; // KeyF1 is the first function key KeyF1 KeyName = \u0026#34;F1\u0026#34; // KeyF2 is the second function key KeyF2 KeyName = \u0026#34;F2\u0026#34; // KeyF3 is the third function key KeyF3 KeyName = \u0026#34;F3\u0026#34; // KeyF4 is the fourth function key KeyF4 KeyName = \u0026#34;F4\u0026#34; // KeyF5 is the fifth function key KeyF5 KeyName = \u0026#34;F5\u0026#34; // KeyF6 is the sixth function key KeyF6 KeyName = \u0026#34;F6\u0026#34; // KeyF7 is the seventh function key KeyF7 KeyName = \u0026#34;F7\u0026#34; // KeyF8 is the eighth function key KeyF8 KeyName = \u0026#34;F8\u0026#34; // KeyF9 is the ninth function key KeyF9 KeyName = \u0026#34;F9\u0026#34; // KeyF10 is the tenth function key KeyF10 KeyName = \u0026#34;F10\u0026#34; // KeyF11 is the eleventh function key KeyF11 KeyName = \u0026#34;F11\u0026#34; // KeyF12 is the twelfth function key KeyF12 KeyName = \u0026#34;F12\u0026#34; // KeyEnter is the enter/ return key (keypad) KeyEnter KeyName = \u0026#34;KP_Enter\u0026#34; // Key0 represents the key 0 Key0 KeyName = \u0026#34;0\u0026#34; // Key1 represents the key 1 Key1 KeyName = \u0026#34;1\u0026#34; // Key2 represents the key 2 Key2 KeyName = \u0026#34;2\u0026#34; // Key3 represents the key 3 Key3 KeyName = \u0026#34;3\u0026#34; // Key4 represents the key 4 Key4 KeyName = \u0026#34;4\u0026#34; // Key5 represents the key 5 Key5 KeyName = \u0026#34;5\u0026#34; // Key6 represents the key 6 Key6 KeyName = \u0026#34;6\u0026#34; // Key7 represents the key 7 Key7 KeyName = \u0026#34;7\u0026#34; // Key8 represents the key 8 Key8 KeyName = \u0026#34;8\u0026#34; // Key9 represents the key 9 Key9 KeyName = \u0026#34;9\u0026#34; // KeyA represents the key A KeyA KeyName = \u0026#34;A\u0026#34; // KeyB represents the key B KeyB KeyName = \u0026#34;B\u0026#34; // KeyC represents the key C KeyC KeyName = \u0026#34;C\u0026#34; // KeyD represents the key D KeyD KeyName = \u0026#34;D\u0026#34; // KeyE represents the key E KeyE KeyName = \u0026#34;E\u0026#34; // KeyF represents the key F KeyF KeyName = \u0026#34;F\u0026#34; // KeyG represents the key G KeyG KeyName = \u0026#34;G\u0026#34; // KeyH represents the key H KeyH KeyName = \u0026#34;H\u0026#34; // KeyI represents the key I KeyI KeyName = \u0026#34;I\u0026#34; // KeyJ represents the key J KeyJ KeyName = \u0026#34;J\u0026#34; // KeyK represents the key K KeyK KeyName = \u0026#34;K\u0026#34; // KeyL represents the key L KeyL KeyName = \u0026#34;L\u0026#34; // KeyM represents the key M KeyM KeyName = \u0026#34;M\u0026#34; // KeyN represents the key N KeyN KeyName = \u0026#34;N\u0026#34; // KeyO represents the key O KeyO KeyName = \u0026#34;O\u0026#34; // KeyP represents the key P KeyP KeyName = \u0026#34;P\u0026#34; // KeyQ represents the key Q KeyQ KeyName = \u0026#34;Q\u0026#34; // KeyR represents the key R KeyR KeyName = \u0026#34;R\u0026#34; // KeyS represents the key S KeyS KeyName = \u0026#34;S\u0026#34; // KeyT represents the key T KeyT KeyName = \u0026#34;T\u0026#34; // KeyU represents the key U KeyU KeyName = \u0026#34;U\u0026#34; // KeyV represents the key V KeyV KeyName = \u0026#34;V\u0026#34; // KeyW represents the key W KeyW KeyName = \u0026#34;W\u0026#34; // KeyX represents the key X KeyX KeyName = \u0026#34;X\u0026#34; // KeyY represents the key Y KeyY KeyName = \u0026#34;Y\u0026#34; // KeyZ represents the key Z KeyZ KeyName = \u0026#34;Z\u0026#34; // KeySpace is the space key KeySpace KeyName = \u0026#34;Space\u0026#34; // KeyApostrophe is the key \u0026#34;\u0026#39;\u0026#34; KeyApostrophe KeyName = \u0026#34;\u0026#39;\u0026#34; // KeyComma is the key \u0026#34;,\u0026#34; KeyComma KeyName = \u0026#34;,\u0026#34; // KeyMinus is the key \u0026#34;-\u0026#34; KeyMinus KeyName = \u0026#34;-\u0026#34; // KeyPeriod is the key \u0026#34;.\r\r\rfyne.Layout\r\rfyne.Layout\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Layout\r#\rtype Layout interface { // Layout will manipulate the listed CanvasObjects Size and Position // to fit within the specified size. Layout([]CanvasObject, Size) // MinSize calculates the smallest size that will fit the listed // CanvasObjects using this Layout algorithm. MinSize(objects []CanvasObject) Size } Layout defines how CanvasObjects may be laid out in a specified Size.\r\r\rfyne.LegacyTheme\r\rfyne.LegacyTheme\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype LegacyTheme\r#\rtype LegacyTheme interface { BackgroundColor() color.Color ButtonColor() color.Color DisabledButtonColor() color.Color TextColor() color.Color DisabledTextColor() color.Color PlaceHolderColor() color.Color PrimaryColor() color.Color HoverColor() color.Color FocusColor() color.Color ScrollBarColor() color.Color ShadowColor() color.Color TextSize() int TextFont() Resource TextBoldFont() Resource TextItalicFont() Resource TextBoldItalicFont() Resource TextMonospaceFont() Resource Padding() int IconInlineSize() int ScrollBarSize() int ScrollBarSmallSize() int } LegacyTheme defines the requirements of any Fyne theme.\r\r\rfyne.Lifecycle\r\rfyne.Lifecycle\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Lifecycle\r#\rtype Lifecycle interface { // SetOnEnteredForeground hooks into the app becoming foreground and gaining focus. SetOnEnteredForeground(func()) // SetOnExitedForeground hooks into the app losing input focus and going into the background. SetOnExitedForeground(func()) // SetOnStarted hooks into an event that says the app is now running. SetOnStarted(func()) // SetOnStopped hooks into an event that says the app is no longer running.\r\r\rfyne.ListableURI\r\rfyne.ListableURI\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ListableURI\r#\rtype ListableURI interface { URI // List returns a list of child URIs of this URI. List() ([]URI, error) } ListableURI represents a URI that can have child items, most commonly a directory on disk in the native filesystem. Since: 1.4\r\r\rfyne.MainMenu\r\rfyne.MainMenu\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype MainMenu\r#\rtype MainMenu struct { Items []*Menu } MainMenu defines the data required to show a menu bar (desktop) or other appropriate top level menu. func NewMainMenu\r#\rfunc NewMainMenu(items ...*Menu) *MainMenu NewMainMenu creates a top level menu structure used by fyne.Window for displaying a menubar (or appropriate equivalent).\r\r\rfyne.Menu\r\rfyne.Menu\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Menu\r#\rtype Menu struct { Label string Items []*MenuItem } Menu stores the information required for a standard menu. A menu can pop down from a MainMenu or could be a pop out menu. func NewMenu\r#\rfunc NewMenu(label string, items ...*MenuItem) *Menu NewMenu creates a new menu given the specified label (to show in a MainMenu) and list of items to display.\r\r\rfyne.MenuItem\r\rfyne.MenuItem\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype MenuItem\r#\rtype MenuItem struct { ChildMenu *Menu // Since: 2.1 IsQuit bool IsSeparator bool Label string Action func() // Since: 2.1 Disabled bool // Since: 2.1 Checked bool } MenuItem is a single item within any menu, it contains a display Label and Action function that is called when tapped.\r\r\rfyne.Notification\r\rfyne.Notification\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Notification\r#\rtype Notification struct { Title, Content string } Notification represents a user notification that can be sent to the operating system. func NewNotification\r#\rfunc NewNotification(title, content string) *Notification NewNotification creates a notification that can be passed to App.SendNotification.\r\r\rfyne.OverlayStack\r\rfyne.OverlayStack\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype OverlayStack\r#\rtype OverlayStack interface { // Add adds an overlay on the top of the overlay stack. Add(overlay CanvasObject) // List returns the overlays currently on the overlay stack. List() []CanvasObject // Remove removes the given object and all objects above it from the overlay stack. Remove(overlay CanvasObject) // Top returns the top-most object of the overlay stack.\r\r\rfyne.PointEvent\r\rfyne.PointEvent\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype PointEvent\r#\rtype PointEvent struct { AbsolutePosition Position // The absolute position of the event Position Position // The relative position of the event } PointEvent describes a pointer input event. The position is relative to the top-left of the CanvasObject this is triggered on.\r\r\rfyne.Position\r\rfyne.Position\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Position\r#\rtype Position struct { X float32 // The position from the parent\u0026#39;s left edge Y float32 // The position from the parent\u0026#39;s top edge } Position describes a generic X, Y coordinate relative to a parent Canvas or CanvasObject. func NewPos\r#\rfunc NewPos(x float32, y float32) Position NewPos returns a newly allocated Position representing the specified coordinates.\r\r\rfyne.Preferences\r\rfyne.Preferences\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Preferences\r#\rtype Preferences interface { // Bool looks up a boolean value for the key Bool(key string) bool // BoolWithFallback looks up a boolean value and returns the given fallback if not found BoolWithFallback(key string, fallback bool) bool // SetBool saves a boolean value for the given key SetBool(key string, value bool) // Float looks up a float64 value for the key Float(key string) float64 // FloatWithFallback looks up a float64 value and returns the given fallback if not found FloatWithFallback(key string, fallback float64) float64 // SetFloat saves a float64 value for the given key SetFloat(key string, value float64) // Int looks up an integer value for the key Int(key string) int // IntWithFallback looks up an integer value and returns the given fallback if not found IntWithFallback(key string, fallback int) int // SetInt saves an integer value for the given key SetInt(key string, value int) // String looks up a string value for the key String(key string) string // StringWithFallback looks up a string value and returns the given fallback if not found StringWithFallback(key, fallback string) string // SetString saves a string value for the given key SetString(key string, value string) // RemoveValue removes a value for the given key (not currently supported on iOS) RemoveValue(key string) // AddChangeListener allows code to be notified when some preferences change.\r\r\rfyne.Resource\r\rfyne.Resource\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Resource\r#\rtype Resource interface { Name() string Content() []byte } Resource represents a single binary resource, such as an image or font. A resource has an identifying name and byte array content. The serialised path of a resource can be obtained which may result in a blocking filesystem write operation. func LoadResourceFromPath\r#\rfunc LoadResourceFromPath(path string) (Resource, error) LoadResourceFromPath creates a new StaticResource in memory using the contents of the specified file.\r\r\rfyne.Scrollable\r\rfyne.Scrollable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Scrollable\r#\rtype Scrollable interface { Scrolled(*ScrollEvent) } Scrollable describes any CanvasObject that can also be scrolled. This is mostly used to implement the widget.ScrollContainer.\r\r\rfyne.ScrollEvent\r\rfyne.ScrollEvent\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ScrollEvent\r#\rtype ScrollEvent struct { PointEvent Scrolled Delta } ScrollEvent defines the parameters of a pointer or other scroll event. The DeltaX and DeltaY represent how large the scroll was in two dimensions.\r\r\rfyne.SecondaryTappable\r\rfyne.SecondaryTappable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype SecondaryTappable\r#\rtype SecondaryTappable interface { TappedSecondary(*PointEvent) } SecondaryTappable describes a CanvasObject that can be right-clicked or long-tapped.\r\r\rfyne.Settings\r\rfyne.Settings\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Settings\r#\rtype Settings interface { Theme() Theme SetTheme(Theme) // ThemeVariant defines which preferred version of a theme should be used (i.e. light or dark) // // Since: 2.0 ThemeVariant() ThemeVariant Scale() float32 // PrimaryColor indicates a user preference for a named primary color // // Since: 1.4 PrimaryColor() string AddChangeListener(chan Settings) BuildType() BuildType } Settings describes the application configuration available.\r\r\rfyne.Shortcut\r\rfyne.Shortcut\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Shortcut\r#\rtype Shortcut interface { ShortcutName() string } Shortcut is the interface used to describe a shortcut action\r\r\rfyne.Shortcutable\r\rfyne.Shortcutable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Shortcutable\r#\rtype Shortcutable interface { TypedShortcut(Shortcut) } Shortcutable describes any CanvasObject that can respond to shortcut commands (quit, cut, copy, and paste).\r\r\rfyne.ShortcutCopy\r\rfyne.ShortcutCopy\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ShortcutCopy\r#\rtype ShortcutCopy struct { Clipboard Clipboard } ShortcutCopy describes a shortcut copy action. func (*ShortcutCopy) ShortcutName\r#\rfunc (se *ShortcutCopy) ShortcutName() string ShortcutName returns the shortcut name\r\r\rfyne.ShortcutCut\r\rfyne.ShortcutCut\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ShortcutCut\r#\rtype ShortcutCut struct { Clipboard Clipboard } ShortcutCut describes a shortcut cut action. func (*ShortcutCut) ShortcutName\r#\rfunc (se *ShortcutCut) ShortcutName() string ShortcutName returns the shortcut name\r\r\rfyne.ShortcutHandler\r\rfyne.ShortcutHandler\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ShortcutHandler\r#\rtype ShortcutHandler struct { } ShortcutHandler is a default implementation of the shortcut handler for the canvasObject func (*ShortcutHandler) AddShortcut\r#\rfunc (sh *ShortcutHandler) AddShortcut(shortcut Shortcut, handler func(shortcut Shortcut)) AddShortcut register an handler to be executed when the shortcut action is triggered func (*ShortcutHandler) RemoveShortcut\r#\rfunc (sh *ShortcutHandler) RemoveShortcut(shortcut Shortcut) RemoveShortcut removes a registered shortcut\r\r\rfyne.ShortcutPaste\r\rfyne.ShortcutPaste\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ShortcutPaste\r#\rtype ShortcutPaste struct { Clipboard Clipboard } ShortcutPaste describes a shortcut paste action. func (*ShortcutPaste) ShortcutName\r#\rfunc (se *ShortcutPaste) ShortcutName() string ShortcutName returns the shortcut name\r\r\rfyne.ShortcutSelectAll\r\rfyne.ShortcutSelectAll\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ShortcutSelectAll\r#\rtype ShortcutSelectAll struct{} ShortcutSelectAll describes a shortcut selectAll action. func (*ShortcutSelectAll) ShortcutName\r#\rfunc (se *ShortcutSelectAll) ShortcutName() string ShortcutName returns the shortcut name\r\r\rfyne.Size\r\rfyne.Size\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Size\r#\rtype Size struct { Width float32 // The number of units along the X axis. Height float32 // The number of units along the Y axis. } Size describes something with width and height. func MeasureText\r#\rfunc MeasureText(text string, size float32, style TextStyle) Size MeasureText uses the current driver to calculate the size of text when rendered.\r\r\rfyne.StaticResource\r\rfyne.StaticResource\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype StaticResource\r#\rtype StaticResource struct { StaticName string StaticContent []byte } StaticResource is a bundled resource compiled into the application. These resources are normally generated by the fyne_bundle command included in the Fyne toolkit. func NewStaticResource\r#\rfunc NewStaticResource(name string, content []byte) *StaticResource NewStaticResource returns a new static resource object with the specified name and content. Creating a new static resource in memory results in sharable binary data that may be serialised to the location returned by CachePath().\r\r\rfyne.Storage\r\rfyne.Storage\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Storage\r#\rtype Storage interface { RootURI() URI Create(name string) (URIWriteCloser, error) Open(name string) (URIReadCloser, error) Save(name string) (URIWriteCloser, error) Remove(name string) error List() []string } Storage is used to manage file storage inside an application sandbox. The files managed by this interface are unique to the current application.\r\r\rfyne.StringValidator\r\rfyne.StringValidator\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype StringValidator\r#\rtype StringValidator func(string) error StringValidator is a function signature for validating string inputs. Since: 1.4\r\r\rfyne.Tabbable\r\rfyne.Tabbable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Tabbable\r#\rtype Tabbable interface { // AcceptsTab() is a hook called by the key press handling logic. // If it returns true then the Tab key events will be sent using TypedKey. AcceptsTab() bool } Tabbable describes any object that needs to accept the Tab key presses. Since: 2.1\r\r\rfyne.Tappable\r\rfyne.Tappable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Tappable\r#\rtype Tappable interface { Tapped(*PointEvent) } Tappable describes any CanvasObject that can also be tapped. This should be implemented by buttons etc that wish to handle pointer interactions.\r\r\rfyne.TextAlign\r\rfyne.TextAlign\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype TextAlign\r#\rtype TextAlign int TextAlign represents the horizontal alignment of text within a widget or canvas object. const ( // TextAlignLeading specifies a left alignment for left-to-right languages. TextAlignLeading TextAlign = iota // TextAlignCenter places the text centrally within the available space. TextAlignCenter // TextAlignTrailing will align the text right for a left-to-right language.\r\r\rfyne.TextStyle\r\rfyne.TextStyle\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype TextStyle\r#\rtype TextStyle struct { Bold bool // Should text be bold Italic bool // Should text be italic Monospace bool // Use the system monospace font instead of regular // Since: 2.1 TabWidth int // Width of tabs in spaces } TextStyle represents the styles that can be applied to a text canvas object or text based widget.\r\r\rfyne.TextWrap\r\rfyne.TextWrap\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype TextWrap\r#\rtype TextWrap int TextWrap represents how text longer than the widget\u0026rsquo;s width will be wrapped. const ( // TextWrapOff extends the widget\u0026#39;s width to fit the text, no wrapping is applied. TextWrapOff TextWrap = iota // TextTruncate trims the text to the widget\u0026#39;s width, no wrapping is applied. // If an entry is asked to truncate it will provide scrolling capabilities.\r\r\rfyne.Theme\r\rfyne.Theme\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Theme\r#\rtype Theme interface { Color(ThemeColorName, ThemeVariant) color.Color Font(TextStyle) Resource Icon(ThemeIconName) Resource Size(ThemeSizeName) float32 } Theme defines the method to look up colors, sizes and fonts that make up a Fyne theme. Since: 2.0\r\r\rfyne.ThemeColorName\r\rfyne.ThemeColorName\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ThemeColorName\r#\rtype ThemeColorName string ThemeColorName is used to look up a colour based on its name. Since: 2.0\r\r\rfyne.ThemeIconName\r\rfyne.ThemeIconName\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ThemeIconName\r#\rtype ThemeIconName string ThemeIconName is used to look up an icon based on its name. Since: 2.0\r\r\rfyne.ThemeSizeName\r\rfyne.ThemeSizeName\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ThemeSizeName\r#\rtype ThemeSizeName string ThemeSizeName is used to look up a size based on its name. Since: 2.0\r\r\rfyne.ThemeVariant\r\rfyne.ThemeVariant\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype ThemeVariant\r#\rtype ThemeVariant uint ThemeVariant indicates a variation of a theme, such as light or dark. Since: 2.0\r\r\rfyne.URI\r\rfyne.URI\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype URI\r#\rtype URI interface { fmt.Stringer // Extension should return the file extension of the resource // referenced by the URI. For example, the Extension() of // \u0026#39;file://foo/bar.baz\u0026#39; is \u0026#39;baz\u0026#39;. May return an empty string if the // referenced resource has none. Extension() string // Name should return the base name of the item referenced by the URI.\r\r\rfyne.URIReadCloser\r\rfyne.URIReadCloser\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype URIReadCloser\r#\rtype URIReadCloser interface { io.ReadCloser URI() URI } URIReadCloser represents a cross platform data stream from a file or provider of data. It may refer to an item on a filesystem or data in another application that we have access to.\r\r\rfyne.URIWriteCloser\r\rfyne.URIWriteCloser\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype URIWriteCloser\r#\rtype URIWriteCloser interface { io.WriteCloser URI() URI } URIWriteCloser represents a cross platform data writer for a file resource. This will normally refer to a local file resource.\r\r\rfyne.Validatable\r\rfyne.Validatable\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Validatable\r#\rtype Validatable interface { Validate() error // SetOnValidationChanged is used to set the callback that will be triggered when the validation state changes. // The function might be overwritten by a parent that cares about child validation (e.g. widget.Form). SetOnValidationChanged(func(error)) } Validatable is an interface for specifying if a widget is validatable.\r\r\rfyne.Vector2\r\rfyne.Vector2\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Vector2\r#\rtype Vector2 interface { Components() (float32, float32) IsZero() bool } Vector2 marks geometry types that can operate as a coordinate vector.\r\r\rfyne.Widget\r\rfyne.Widget\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Widget\r#\rtype Widget interface { CanvasObject // CreateRenderer returns a new WidgetRenderer for this widget. // This should not be called by regular code, it is used internally to render a widget. CreateRenderer() WidgetRenderer } Widget defines the standard behaviours of any widget. This extends the CanvasObject - a widget behaves in the same basic way but will encapsulate many child objects to create the rendered widget.\r\r\rfyne.WidgetRenderer\r\rfyne.WidgetRenderer\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype WidgetRenderer\r#\rtype WidgetRenderer interface { // Destroy is for internal use. Destroy() // Layout is a hook that is called if the widget needs to be laid out. // This should never call Refresh. Layout(Size) // MinSize returns the minimum size of the widget that is rendered by this renderer. MinSize() Size // Objects returns all objects that should be drawn.\r\r\rfyne.Window\r\rfyne.Window\r#\rimport \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\rtype Window\r#\rtype Window interface { // Title returns the current window title. // This is typically displayed in the window decorations. Title() string // SetTitle updates the current title of the window. SetTitle(string) // FullScreen returns whether or not this window is currently full screen. FullScreen() bool // SetFullScreen changes the requested fullScreen property // true for a fullScreen window and false to unset this.\r\r\rlayout\r\rlayout\rlayout\r#\rimport \u0026#34;fyne.io/fyne/v2/layout\u0026#34; Package layout defines the various layouts available to Fyne apps Usage\r#\rfunc NewAdaptiveGridLayout\r#\rfunc NewAdaptiveGridLayout(rowcols int) fyne.Layout NewAdaptiveGridLayout returns a new grid layout which uses columns when horizontal but rows when vertical. func NewBorderLayout\r#\rfunc NewBorderLayout(top, bottom, left, right fyne.CanvasObject) fyne.Layout NewBorderLayout creates a new BorderLayout instance with top, bottom, left and right objects set. All other items in the container will fill the centre space\rlayout.\r\r\rstorage\r\rrepository\rrepository.CopyableRepository\u0026#34;\rrepository.CopyableRepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype CopyableRepository\r#\rtype CopyableRepository interface { Repository // Copy will be used to implement calls to storage.Copy() for the // registered scheme of this repository. // // A generic implementation is provided by GenericCopy(). // // NOTE: the first parameter is the source, the second is the // destination. // // NOTE: if storage.\rrepository.CustomURIRepository\u0026#34;\rrepository.CustomURIRepository\r#\rimport \u0026#34;fyne.\r\r\rtest\r\rtest\rtest\r#\rimport \u0026#34;fyne.io/fyne/v2/test\u0026#34; Package test provides utility drivers for running UI tests without rendering Usage\r#\rfunc ApplyTheme\r#\rfunc ApplyTheme(t *testing.T, theme fyne.Theme) ApplyTheme sets the given theme and waits for it to be applied to the current app. func AssertCanvasTappableAt\r#\rfunc AssertCanvasTappableAt(t *testing.T, c fyne.Canvas, pos fyne.Position) bool AssertCanvasTappableAt asserts that the canvas is tappable at the given position. func AssertImageMatches\r#\rfunc AssertImageMatches(t *testing.\r\r\rtheme\r\rwidget\rwidget\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Package widget defines the UI widgets within the Fyne toolkit Usage\r#\rvar ( // RichTextStyleBlockquote represents a quote presented in an indented block. // // Since: 2.1 RichTextStyleBlockquote = RichTextStyle{ ColorName: theme.ColorNameForeground, Inline: false, SizeName: theme.SizeNameText, TextStyle: fyne.TextStyle{Italic: true}, } // RichTextStyleCodeBlock represents a code blog segment. // // Since: 2.\rwidget.Accordion\rwidget.Accordion\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Accordion\r#\rtype Accordion struct { BaseWidget Items []*AccordionItem MultiOpen bool } Accordion displays a list of AccordionItems.\r\r\rUpgrading to v2.1\r\rThe 2.1 release is fully backward compatible with 2.0.4 and earlier, so upgrading is as simple as updating the version of code you compile with. This is different depending on whether or not you use go modules. Modules\r#\rIf your project has a go.mod file then you can edit the require line to use version v2.1.0, or you can execute the following command inside the directory: go get fyne.\r\r\rwidget\r\rtheme\rtheme\r#\rimport \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Package theme defines how a Fyne app should look when rendered Usage\r#\rconst ( // IconNameCancel is the name of theme lookup for cancel icon. // // Since: 2.0 IconNameCancel fyne.ThemeIconName = \u0026#34;cancel\u0026#34; // IconNameConfirm is the name of theme lookup for confirm icon. // // Since: 2.0 IconNameConfirm fyne.ThemeIconName = \u0026#34;confirm\u0026#34; // IconNameDelete is the name of theme lookup for delete icon.\r\r\r"},{"id":70,"href":"/fyne/docs/started/cross-compiling/","title":"Cross Compiling","section":"Getting Started","content":"Compiling for different platforms\r#\r\r Cross compiling with Go is designed to be simple - we just set the environment variable GOOS for the target Operating System (and GOARCH if targeting a different architecture). Unfortunately when using native graphics calls the use of CGo in Fyne makes this a little harder.\nCompiling from a development computer\r#\r\rTo cross-compile a Fyne application you will also have to set CGO_ENABLED=1 which tells go to enable the C compiler (this is normally turned off when the target platform is different to the current system). Doing so unfortunately means that you must have a C compiler for the target platform that you are going to compile for. After installing the appropriate compilers you will also need to set the CC environment variable to tell Go which compiler to use.\nThere are many ways to install the required tools - and different tools that can be used. The configuration recommended by the Fyne developers is:\n   GOOS (target) CC provider download notes     darwin o32-clang osxcross \rfrom github.com You will also need to install the macOS SDK (instructions at the download link)   windows x86_64-w64-mingw64-gcc mingw64 package manager For macOS use homebrew   linux gcc or x86_64-linux-musl-gcc gcc or musl-cross \rcygwin or package manager musl-cross is available from homebrew to provide the linux gcc. You will also need to install X11 and mesa headers for compilation.    With the environment variables above set you should be able to compile in the usual manner. If further errors occur it is likely to be due to missing packages. Some target platforms require additional libraries or headers to be installed for the compilation to succeed.\nUsing a virtual environment\r#\r\rAs a Linux system is able to cross compile to macOS and Windows easily it can be simpler to use a virtualised environment when you are not developing from Linux. Docker images are a useful tool for a complex build configuration and this works for Fyne as well. There are different tools that can be used. The tool recommended by the Fyne developers is fyne-cross. It has been inspired by xgo and uses a docker image built on top of the golang-cross image, that includes the MinGW compiler for windows, and a macOS SDK, along with the Fyne requirements.\nfyne-cross allows to build binaries and create distribution packages for the following targets:\n   GOOS GOARCH     darwin amd64   darwin 386   linux amd64   linux 386   linux arm64   linux arm   windows amd64   windows 386   android amd64   android 386   android arm64   android arm   ios    freebsd amd64   freebsd arm64     Note: iOS compilation is supported only on darwin hosts.\n Requirements\r#\r\r go \u0026gt;= 1.13 docker  Installation\r#\r\rgo get github.com/fyne-io/fyne-cross Usage\r#\r\rfyne-cross \u0026lt;command\u0026gt; [options]\rThe commands are:\rdarwin Build and package a fyne application for the darwin OS\rlinux Build and package a fyne application for the linux OS\rwindows Build and package a fyne application for the windows OS\randroid Build and package a fyne application for the android OS\rios Build and package a fyne application for the iOS OS\rfreebsd Build and package a fyne application for the freebsd OS\rversion Print the fyne-cross version information\rUse \u0026#34;fyne-cross \u0026lt;command\u0026gt; -help\u0026#34; for more information about a command. Wildcards\r#\r\rThe arch flag support wildcards in case want to compile against all supported GOARCH for a specified GOOS\nExample:\nfyne-cross windows -arch=* is equivalent to\nfyne-cross windows -arch=amd64,386 Example\r#\r\rThe example below cross compile and package the fyne examples application\ngit clone https://github.com/fyne-io/examples.git\rcd examples Compile and package the main example app\r#\r\rfyne-cross linux  Note: by default fyne-cross will compile the package into the current dir.\nThe command above is equivalent to: fyne-cross linux .\n Compile and package a particular example app\r#\r\rfyne-cross linux -output bugs ./cmd/bugs "},{"id":71,"href":"/fyne/docs/api/app/","title":"app","section":"API Documentation","content":"\r\rapp\r\rapp\r#\rimport \u0026#34;fyne.io/fyne/v2/app\u0026#34; Package app provides app implementations for working with Fyne graphical interfaces. The fastest way to get started is to call app.New() which will normally load a new desktop application. If the \u0026ldquo;ci\u0026rdquo; tag is passed to go (go run -tags ci myapp.go) it will run an in-memory application. Usage\r#\rfunc New\r#\rfunc New() fyne.App New returns a new application instance with the default driver and no unique ID\r\r\rapp.SettingsSchema\r\rapp.SettingsSchema\r#\rimport \u0026#34;fyne.io/fyne/v2/app\u0026#34; Usage\r#\rtype SettingsSchema\r#\rtype SettingsSchema struct { // these items are used for global settings load ThemeName string `json:\u0026#34;theme\u0026#34;` Scale float32 `json:\u0026#34;scale\u0026#34;` PrimaryColor string `json:\u0026#34;primary_color\u0026#34;` } SettingsSchema is used for loading and storing global settings func (*SettingsSchema) StoragePath\r#\rfunc (sc *SettingsSchema) StoragePath() string StoragePath returns the location of the settings storage\r\r\r"},{"id":72,"href":"/fyne/docs/api/app/","title":"app","section":"app","content":"app\r#\r\r import \u0026#34;fyne.io/fyne/v2/app\u0026#34; Package app provides app implementations for working with Fyne graphical interfaces. The fastest way to get started is to call app.New() which will normally load a new desktop application. If the \u0026ldquo;ci\u0026rdquo; tag is passed to go (go run -tags ci myapp.go) it will run an in-memory application.\nUsage\r#\r\rfunc New\r#\r\rfunc New() fyne.App New returns a new application instance with the default driver and no unique ID\nfunc NewWithID\r#\r\rfunc NewWithID(id string) fyne.App NewWithID returns a new app instance using the appropriate runtime driver. The ID string should be globally unique to this app.\ntypes\r#\r\r \rSettingsSchema  "},{"id":73,"href":"/fyne/docs/api/app/settingsschema/","title":"app.SettingsSchema","section":"app","content":"app.SettingsSchema\r#\r\r import \u0026#34;fyne.io/fyne/v2/app\u0026#34; Usage\r#\r\rtype SettingsSchema\r#\r\rtype SettingsSchema struct { \t// these items are used for global settings load \tThemeName string `json:\u0026#34;theme\u0026#34;` \tScale float32 `json:\u0026#34;scale\u0026#34;` \tPrimaryColor string `json:\u0026#34;primary_color\u0026#34;` } SettingsSchema is used for loading and storing global settings\nfunc (*SettingsSchema) StoragePath\r#\r\rfunc (sc *SettingsSchema) StoragePath() string StoragePath returns the location of the settings storage\n"},{"id":74,"href":"/fyne/docs/api/data/binding/","title":"binding","section":"data","content":"\r\rbinding\r\rbinding\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtypes\r#\rBool BoolList DataItem DataList DataListener DataMap ExternalBool ExternalBoolList ExternalFloat ExternalFloatList ExternalInt ExternalIntList ExternalRune ExternalRuneList ExternalString ExternalStringList ExternalURI ExternalURIList ExternalUntyped ExternalUntypedList ExternalUntypedMap Float FloatList Int IntList Rune RuneList String StringList Struct URI URIList Untyped UntypedList UntypedMap \r\rbinding.Bool\r\rbinding.Bool\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype Bool\r#\rtype Bool interface { DataItem Get() (bool, error) Set(bool) error } Bool supports binding a bool value. Since: 2.0\rfunc BindPreferenceBool\r#\rfunc BindPreferenceBool(key string, p fyne.Preferences) Bool BindPreferenceBool returns a bindable bool value that is managed by the application preferences. Changes to this value will be saved to application storage and when the app starts the previous values will be read.\r\r\rbinding.BoolList\r\rbinding.BoolList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype BoolList\r#\rtype BoolList interface { DataList Append(value bool) error Get() ([]bool, error) GetValue(index int) (bool, error) Prepend(value bool) error Set(list []bool) error SetValue(index int, value bool) error } BoolList supports binding a list of bool values. Since: 2.0\rfunc NewBoolList\r#\rfunc NewBoolList() BoolList NewBoolList returns a bindable list of bool values.\r\r\rbinding.DataItem\r\rbinding.DataItem\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype DataItem\r#\rtype DataItem interface { // AddListener attaches a new change listener to this DataItem. // Listeners are called each time the data inside this DataItem changes. // Additionally the listener will be triggered upon successful connection to get the current value. AddListener(DataListener) // RemoveListener will detach the specified change listener from the DataItem.\r\r\rbinding.DataList\r\rbinding.DataList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype DataList\r#\rtype DataList interface { DataItem GetItem(index int) (DataItem, error) Length() int } DataList is the base interface for all bindable data lists. Since: 2.0\r\r\rbinding.DataListener\r\rbinding.DataListener\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype DataListener\r#\rtype DataListener interface { DataChanged() } DataListener is any object that can register for changes in a bindable DataItem. See NewDataListener to define a new listener using just an inline function. Since: 2.0\rfunc NewDataListener\r#\rfunc NewDataListener(fn func()) DataListener NewDataListener is a helper function that creates a new listener type from a simple callback function.\r\r\rbinding.DataMap\r\rbinding.DataMap\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype DataMap\r#\rtype DataMap interface { DataItem GetItem(string) (DataItem, error) Keys() []string } DataMap is the base interface for all bindable data maps. Since: 2.0\r\r\rbinding.ExternalBool\r\rbinding.ExternalBool\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalBool\r#\rtype ExternalBool interface { Bool Reload() error } ExternalBool supports binding a bool value to an external value. Since: 2.0\rfunc BindBool\r#\rfunc BindBool(v *bool) ExternalBool BindBool returns a new bindable value that controls the contents of the provided bool variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalBoolList\r\rbinding.ExternalBoolList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalBoolList\r#\rtype ExternalBoolList interface { BoolList Reload() error } ExternalBoolList supports binding a list of bool values from an external variable. Since: 2.0\rfunc BindBoolList\r#\rfunc BindBoolList(v *[]bool) ExternalBoolList BindBoolList returns a bound list of bool values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalFloat\r\rbinding.ExternalFloat\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalFloat\r#\rtype ExternalFloat interface { Float Reload() error } ExternalFloat supports binding a float64 value to an external value. Since: 2.0\rfunc BindFloat\r#\rfunc BindFloat(v *float64) ExternalFloat BindFloat returns a new bindable value that controls the contents of the provided float64 variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalFloatList\r\rbinding.ExternalFloatList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalFloatList\r#\rtype ExternalFloatList interface { FloatList Reload() error } ExternalFloatList supports binding a list of float64 values from an external variable. Since: 2.0\rfunc BindFloatList\r#\rfunc BindFloatList(v *[]float64) ExternalFloatList BindFloatList returns a bound list of float64 values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalInt\r\rbinding.ExternalInt\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalInt\r#\rtype ExternalInt interface { Int Reload() error } ExternalInt supports binding a int value to an external value. Since: 2.0\rfunc BindInt\r#\rfunc BindInt(v *int) ExternalInt BindInt returns a new bindable value that controls the contents of the provided int variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalIntList\r\rbinding.ExternalIntList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalIntList\r#\rtype ExternalIntList interface { IntList Reload() error } ExternalIntList supports binding a list of int values from an external variable. Since: 2.0\rfunc BindIntList\r#\rfunc BindIntList(v *[]int) ExternalIntList BindIntList returns a bound list of int values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalRune\r\rbinding.ExternalRune\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalRune\r#\rtype ExternalRune interface { Rune Reload() error } ExternalRune supports binding a rune value to an external value. Since: 2.0\rfunc BindRune\r#\rfunc BindRune(v *rune) ExternalRune BindRune returns a new bindable value that controls the contents of the provided rune variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalRuneList\r\rbinding.ExternalRuneList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalRuneList\r#\rtype ExternalRuneList interface { RuneList Reload() error } ExternalRuneList supports binding a list of rune values from an external variable. Since: 2.0\rfunc BindRuneList\r#\rfunc BindRuneList(v *[]rune) ExternalRuneList BindRuneList returns a bound list of rune values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalString\r\rbinding.ExternalString\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalString\r#\rtype ExternalString interface { String Reload() error } ExternalString supports binding a string value to an external value. Since: 2.0\rfunc BindString\r#\rfunc BindString(v *string) ExternalString BindString returns a new bindable value that controls the contents of the provided string variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalStringList\r\rbinding.ExternalStringList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalStringList\r#\rtype ExternalStringList interface { StringList Reload() error } ExternalStringList supports binding a list of string values from an external variable. Since: 2.0\rfunc BindStringList\r#\rfunc BindStringList(v *[]string) ExternalStringList BindStringList returns a bound list of string values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalUntyped\r\rbinding.ExternalUntyped\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalUntyped\r#\rtype ExternalUntyped interface { Untyped Reload() error } ExternalUntyped supports binding a interface{} value to an external value. Since: 2.1\rfunc BindUntyped\r#\rfunc BindUntyped(v interface{}) ExternalUntyped BindUntyped returns a bindable interface{} value that is bound to an external type. The parameter must be a pointer to the type you wish to bind.\r\r\rbinding.ExternalUntypedList\r\rbinding.ExternalUntypedList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalUntypedList\r#\rtype ExternalUntypedList interface { UntypedList Reload() error } ExternalUntypedList supports binding a list of interface{} values from an external variable. Since: 2.1\rfunc BindUntypedList\r#\rfunc BindUntypedList(v *[]interface{}) ExternalUntypedList BindUntypedList returns a bound list of interface{} values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalUntypedMap\r\rbinding.ExternalUntypedMap\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalUntypedMap\r#\rtype ExternalUntypedMap interface { UntypedMap Reload() error } ExternalUntypedMap is a map data binding with all values untyped (interface{}), connected to an external data source. Since: 2.0\rfunc BindUntypedMap\r#\rfunc BindUntypedMap(d *map[string]interface{}) ExternalUntypedMap BindUntypedMap creates a new map binding of string to interface{} based on the data passed. If your code changes the content of the map this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalURI\r\rbinding.ExternalURI\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalURI\r#\rtype ExternalURI interface { URI Reload() error } ExternalURI supports binding a fyne.URI value to an external value. Since: 2.1\rfunc BindURI\r#\rfunc BindURI(v *fyne.URI) ExternalURI BindURI returns a new bindable value that controls the contents of the provided fyne.URI variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\r\r\rbinding.ExternalURIList\r\rbinding.ExternalURIList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype ExternalURIList\r#\rtype ExternalURIList interface { URIList Reload() error } ExternalURIList supports binding a list of fyne.URI values from an external variable. Since: 2.1\rfunc BindURIList\r#\rfunc BindURIList(v *[]fyne.URI) ExternalURIList BindURIList returns a bound list of fyne.URI values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\r\r\rbinding.Float\r\rbinding.Float\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype Float\r#\rtype Float interface { DataItem Get() (float64, error) Set(float64) error } Float supports binding a float64 value. Since: 2.0\rfunc BindPreferenceFloat\r#\rfunc BindPreferenceFloat(key string, p fyne.Preferences) Float BindPreferenceFloat returns a bindable float64 value that is managed by the application preferences. Changes to this value will be saved to application storage and when the app starts the previous values will be read.\r\r\rbinding.FloatList\r\rbinding.FloatList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype FloatList\r#\rtype FloatList interface { DataList Append(value float64) error Get() ([]float64, error) GetValue(index int) (float64, error) Prepend(value float64) error Set(list []float64) error SetValue(index int, value float64) error } FloatList supports binding a list of float64 values. Since: 2.0\rfunc NewFloatList\r#\rfunc NewFloatList() FloatList NewFloatList returns a bindable list of float64 values.\r\r\rbinding.Int\r\rbinding.Int\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype Int\r#\rtype Int interface { DataItem Get() (int, error) Set(int) error } Int supports binding a int value. Since: 2.0\rfunc BindPreferenceInt\r#\rfunc BindPreferenceInt(key string, p fyne.Preferences) Int BindPreferenceInt returns a bindable int value that is managed by the application preferences. Changes to this value will be saved to application storage and when the app starts the previous values will be read.\r\r\rbinding.IntList\r\rbinding.IntList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype IntList\r#\rtype IntList interface { DataList Append(value int) error Get() ([]int, error) GetValue(index int) (int, error) Prepend(value int) error Set(list []int) error SetValue(index int, value int) error } IntList supports binding a list of int values. Since: 2.0\rfunc NewIntList\r#\rfunc NewIntList() IntList NewIntList returns a bindable list of int values.\r\r\rbinding.Rune\r\rbinding.Rune\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype Rune\r#\rtype Rune interface { DataItem Get() (rune, error) Set(rune) error } Rune supports binding a rune value. Since: 2.0\rfunc NewRune\r#\rfunc NewRune() Rune NewRune returns a bindable rune value that is managed internally. Since: 2.0\r\r\rbinding.RuneList\r\rbinding.RuneList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype RuneList\r#\rtype RuneList interface { DataList Append(value rune) error Get() ([]rune, error) GetValue(index int) (rune, error) Prepend(value rune) error Set(list []rune) error SetValue(index int, value rune) error } RuneList supports binding a list of rune values. Since: 2.0\rfunc NewRuneList\r#\rfunc NewRuneList() RuneList NewRuneList returns a bindable list of rune values.\r\r\rbinding.String\r\rbinding.String\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype String\r#\rtype String interface { DataItem Get() (string, error) Set(string) error } String supports binding a string value. Since: 2.0\rfunc BindPreferenceString\r#\rfunc BindPreferenceString(key string, p fyne.Preferences) String BindPreferenceString returns a bindable string value that is managed by the application preferences. Changes to this value will be saved to application storage and when the app starts the previous values will be read.\r\r\rbinding.StringList\r\rbinding.StringList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype StringList\r#\rtype StringList interface { DataList Append(value string) error Get() ([]string, error) GetValue(index int) (string, error) Prepend(value string) error Set(list []string) error SetValue(index int, value string) error } StringList supports binding a list of string values. Since: 2.0\rfunc NewStringList\r#\rfunc NewStringList() StringList NewStringList returns a bindable list of string values.\r\r\rbinding.Struct\r\rbinding.Struct\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype Struct\r#\rtype Struct interface { DataMap GetValue(string) (interface{}, error) SetValue(string, interface{}) error Reload() error } Struct is the base interface for a bound struct type. Since: 2.0\rfunc BindStruct\r#\rfunc BindStruct(i interface{}) Struct BindStruct creates a new map binding of string to interface{} using the struct passed as data. The key for each item is a string representation of each exported field with the value set as an interface{}.\r\r\rbinding.Untyped\r\rbinding.Untyped\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype Untyped\r#\rtype Untyped interface { DataItem Get() (interface{}, error) Set(interface{}) error } Untyped supports binding a interface{} value. Since: 2.1\rfunc NewUntyped\r#\rfunc NewUntyped() Untyped NewUntyped returns a bindable interface{} value that is managed internally. Since: 2.1\r\r\rbinding.UntypedList\r\rbinding.UntypedList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype UntypedList\r#\rtype UntypedList interface { DataList Append(value interface{}) error Get() ([]interface{}, error) GetValue(index int) (interface{}, error) Prepend(value interface{}) error Set(list []interface{}) error SetValue(index int, value interface{}) error } UntypedList supports binding a list of interface{} values. Since: 2.1\rfunc NewUntypedList\r#\rfunc NewUntypedList() UntypedList NewUntypedList returns a bindable list of interface{} values.\r\r\rbinding.UntypedMap\r\rbinding.UntypedMap\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype UntypedMap\r#\rtype UntypedMap interface { DataMap Delete(string) Get() (map[string]interface{}, error) GetValue(string) (interface{}, error) Set(map[string]interface{}) error SetValue(string, interface{}) error } UntypedMap is a map data binding with all values Untyped (interface{}). Since: 2.0\rfunc NewUntypedMap\r#\rfunc NewUntypedMap() UntypedMap NewUntypedMap creates a new, empty map binding of string to interface{}. Since: 2.\r\r\rbinding.URI\r\rbinding.URI\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype URI\r#\rtype URI interface { DataItem Get() (fyne.URI, error) Set(fyne.URI) error } URI supports binding a fyne.URI value. Since: 2.1\rfunc NewURI\r#\rfunc NewURI() URI NewURI returns a bindable fyne.URI value that is managed internally. Since: 2.1\rfunc StringToURI\r#\rfunc StringToURI(str String) URI StringToURI creates a binding that connects a String data item to a URI.\r\r\rbinding.URIList\r\rbinding.URIList\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype URIList\r#\rtype URIList interface { DataList Append(value fyne.URI) error Get() ([]fyne.URI, error) GetValue(index int) (fyne.URI, error) Prepend(value fyne.URI) error Set(list []fyne.URI) error SetValue(index int, value fyne.URI) error } URIList supports binding a list of fyne.URI values. Since: 2.1\rfunc NewURIList\r#\rfunc NewURIList() URIList NewURIList returns a bindable list of fyne.\r\r\r"},{"id":75,"href":"/fyne/docs/api/data/binding/","title":"binding","section":"binding","content":"binding\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtypes\r#\r\r \rBool \rBoolList \rDataItem \rDataList \rDataListener \rDataMap \rExternalBool \rExternalBoolList \rExternalFloat \rExternalFloatList \rExternalInt \rExternalIntList \rExternalRune \rExternalRuneList \rExternalString \rExternalStringList \rExternalURI \rExternalURIList \rExternalUntyped \rExternalUntypedList \rExternalUntypedMap \rFloat \rFloatList \rInt \rIntList \rRune \rRuneList \rString \rStringList \rStruct \rURI \rURIList \rUntyped \rUntypedList \rUntypedMap  "},{"id":76,"href":"/fyne/docs/api/data/binding/bool/","title":"binding.Bool","section":"binding","content":"binding.Bool\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype Bool\r#\r\rtype Bool interface { \tDataItem \tGet() (bool, error) \tSet(bool) error } Bool supports binding a bool value.\nSince: \r2.0\rfunc BindPreferenceBool\r#\r\rfunc BindPreferenceBool(key string, p fyne.Preferences) Bool BindPreferenceBool returns a bindable bool value that is managed by the application preferences. Changes to this value will be saved to application storage and when the app starts the previous values will be read.\nSince: \r2.0\rfunc NewBool\r#\r\rfunc NewBool() Bool NewBool returns a bindable bool value that is managed internally.\nSince: \r2.0\rfunc StringToBool\r#\r\rfunc StringToBool(str String) Bool StringToBool creates a binding that connects a String data item to a Bool. Changes to the String will be parsed and pushed to the Bool if the parse was successful, and setting the Bool update the String binding.\nSince: \r2.0\rfunc StringToBoolWithFormat\r#\r\rfunc StringToBoolWithFormat(str String, format string) Bool StringToBoolWithFormat creates a binding that connects a String data item to a Bool and is presented using the specified format. Changes to the Bool will be parsed and if the format matches and the parse is successful it will be pushed to the String. Setting the Bool will push a formatted value into the String.\nSince: \r2.0\r"},{"id":77,"href":"/fyne/docs/api/data/binding/boollist/","title":"binding.BoolList","section":"binding","content":"binding.BoolList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype BoolList\r#\r\rtype BoolList interface { \tDataList  \tAppend(value bool) error \tGet() ([]bool, error) \tGetValue(index int) (bool, error) \tPrepend(value bool) error \tSet(list []bool) error \tSetValue(index int, value bool) error } BoolList supports binding a list of bool values.\nSince: \r2.0\rfunc NewBoolList\r#\r\rfunc NewBoolList() BoolList NewBoolList returns a bindable list of bool values.\nSince: \r2.0\r"},{"id":78,"href":"/fyne/docs/api/data/binding/dataitem/","title":"binding.DataItem","section":"binding","content":"binding.DataItem\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype DataItem\r#\r\rtype DataItem interface { \t// AddListener attaches a new change listener to this DataItem. \t// Listeners are called each time the data inside this DataItem changes. \t// Additionally the listener will be triggered upon successful connection to get the current value. \tAddListener(DataListener) \t// RemoveListener will detach the specified change listener from the DataItem. \t// Disconnected listener will no longer be triggered when changes occur. \tRemoveListener(DataListener) } DataItem is the base interface for all bindable data items.\nSince: \r2.0\r"},{"id":79,"href":"/fyne/docs/api/data/binding/datalist/","title":"binding.DataList","section":"binding","content":"binding.DataList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype DataList\r#\r\rtype DataList interface { \tDataItem \tGetItem(index int) (DataItem, error) \tLength() int } DataList is the base interface for all bindable data lists.\nSince: \r2.0\r"},{"id":80,"href":"/fyne/docs/api/data/binding/datalistener/","title":"binding.DataListener","section":"binding","content":"binding.DataListener\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype DataListener\r#\r\rtype DataListener interface { \tDataChanged() } DataListener is any object that can register for changes in a bindable DataItem. See NewDataListener to define a new listener using just an inline function.\nSince: \r2.0\rfunc NewDataListener\r#\r\rfunc NewDataListener(fn func()) DataListener NewDataListener is a helper function that creates a new listener type from a simple callback function.\nSince: \r2.0\r"},{"id":81,"href":"/fyne/docs/api/data/binding/datamap/","title":"binding.DataMap","section":"binding","content":"binding.DataMap\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype DataMap\r#\r\rtype DataMap interface { \tDataItem \tGetItem(string) (DataItem, error) \tKeys() []string } DataMap is the base interface for all bindable data maps.\nSince: \r2.0\r"},{"id":82,"href":"/fyne/docs/api/data/binding/externalbool/","title":"binding.ExternalBool","section":"binding","content":"binding.ExternalBool\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalBool\r#\r\rtype ExternalBool interface { \tBool \tReload() error } ExternalBool supports binding a bool value to an external value.\nSince: \r2.0\rfunc BindBool\r#\r\rfunc BindBool(v *bool) ExternalBool BindBool returns a new bindable value that controls the contents of the provided bool variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":83,"href":"/fyne/docs/api/data/binding/externalboollist/","title":"binding.ExternalBoolList","section":"binding","content":"binding.ExternalBoolList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalBoolList\r#\r\rtype ExternalBoolList interface { \tBoolList  \tReload() error } ExternalBoolList supports binding a list of bool values from an external variable.\nSince: \r2.0\rfunc BindBoolList\r#\r\rfunc BindBoolList(v *[]bool) ExternalBoolList BindBoolList returns a bound list of bool values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":84,"href":"/fyne/docs/api/data/binding/externalfloat/","title":"binding.ExternalFloat","section":"binding","content":"binding.ExternalFloat\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalFloat\r#\r\rtype ExternalFloat interface { \tFloat \tReload() error } ExternalFloat supports binding a float64 value to an external value.\nSince: \r2.0\rfunc BindFloat\r#\r\rfunc BindFloat(v *float64) ExternalFloat BindFloat returns a new bindable value that controls the contents of the provided float64 variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":85,"href":"/fyne/docs/api/data/binding/externalfloatlist/","title":"binding.ExternalFloatList","section":"binding","content":"binding.ExternalFloatList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalFloatList\r#\r\rtype ExternalFloatList interface { \tFloatList  \tReload() error } ExternalFloatList supports binding a list of float64 values from an external variable.\nSince: \r2.0\rfunc BindFloatList\r#\r\rfunc BindFloatList(v *[]float64) ExternalFloatList BindFloatList returns a bound list of float64 values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":86,"href":"/fyne/docs/api/data/binding/externalint/","title":"binding.ExternalInt","section":"binding","content":"binding.ExternalInt\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalInt\r#\r\rtype ExternalInt interface { \tInt \tReload() error } ExternalInt supports binding a int value to an external value.\nSince: \r2.0\rfunc BindInt\r#\r\rfunc BindInt(v *int) ExternalInt BindInt returns a new bindable value that controls the contents of the provided int variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":87,"href":"/fyne/docs/api/data/binding/externalintlist/","title":"binding.ExternalIntList","section":"binding","content":"binding.ExternalIntList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalIntList\r#\r\rtype ExternalIntList interface { \tIntList  \tReload() error } ExternalIntList supports binding a list of int values from an external variable.\nSince: \r2.0\rfunc BindIntList\r#\r\rfunc BindIntList(v *[]int) ExternalIntList BindIntList returns a bound list of int values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":88,"href":"/fyne/docs/api/data/binding/externalrune/","title":"binding.ExternalRune","section":"binding","content":"binding.ExternalRune\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalRune\r#\r\rtype ExternalRune interface { \tRune \tReload() error } ExternalRune supports binding a rune value to an external value.\nSince: \r2.0\rfunc BindRune\r#\r\rfunc BindRune(v *rune) ExternalRune BindRune returns a new bindable value that controls the contents of the provided rune variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":89,"href":"/fyne/docs/api/data/binding/externalrunelist/","title":"binding.ExternalRuneList","section":"binding","content":"binding.ExternalRuneList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalRuneList\r#\r\rtype ExternalRuneList interface { \tRuneList  \tReload() error } ExternalRuneList supports binding a list of rune values from an external variable.\nSince: \r2.0\rfunc BindRuneList\r#\r\rfunc BindRuneList(v *[]rune) ExternalRuneList BindRuneList returns a bound list of rune values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":90,"href":"/fyne/docs/api/data/binding/externalstring/","title":"binding.ExternalString","section":"binding","content":"binding.ExternalString\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalString\r#\r\rtype ExternalString interface { \tString \tReload() error } ExternalString supports binding a string value to an external value.\nSince: \r2.0\rfunc BindString\r#\r\rfunc BindString(v *string) ExternalString BindString returns a new bindable value that controls the contents of the provided string variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":91,"href":"/fyne/docs/api/data/binding/externalstringlist/","title":"binding.ExternalStringList","section":"binding","content":"binding.ExternalStringList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalStringList\r#\r\rtype ExternalStringList interface { \tStringList  \tReload() error } ExternalStringList supports binding a list of string values from an external variable.\nSince: \r2.0\rfunc BindStringList\r#\r\rfunc BindStringList(v *[]string) ExternalStringList BindStringList returns a bound list of string values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":92,"href":"/fyne/docs/api/data/binding/externaluntyped/","title":"binding.ExternalUntyped","section":"binding","content":"binding.ExternalUntyped\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalUntyped\r#\r\rtype ExternalUntyped interface { \tUntyped \tReload() error } ExternalUntyped supports binding a interface{} value to an external value.\nSince: \r2.1\rfunc BindUntyped\r#\r\rfunc BindUntyped(v interface{}) ExternalUntyped BindUntyped returns a bindable interface{} value that is bound to an external type. The parameter must be a pointer to the type you wish to bind.\nSince: \r2.1\r"},{"id":93,"href":"/fyne/docs/api/data/binding/externaluntypedlist/","title":"binding.ExternalUntypedList","section":"binding","content":"binding.ExternalUntypedList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalUntypedList\r#\r\rtype ExternalUntypedList interface { \tUntypedList  \tReload() error } ExternalUntypedList supports binding a list of interface{} values from an external variable.\nSince: \r2.1\rfunc BindUntypedList\r#\r\rfunc BindUntypedList(v *[]interface{}) ExternalUntypedList BindUntypedList returns a bound list of interface{} values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\nSince: \r2.1\r"},{"id":94,"href":"/fyne/docs/api/data/binding/externaluntypedmap/","title":"binding.ExternalUntypedMap","section":"binding","content":"binding.ExternalUntypedMap\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalUntypedMap\r#\r\rtype ExternalUntypedMap interface { \tUntypedMap \tReload() error } ExternalUntypedMap is a map data binding with all values untyped (interface{}), connected to an external data source.\nSince: \r2.0\rfunc BindUntypedMap\r#\r\rfunc BindUntypedMap(d *map[string]interface{}) ExternalUntypedMap BindUntypedMap creates a new map binding of string to interface{} based on the data passed. If your code changes the content of the map this refers to you should call Reload() to inform the bindings.\nSince: \r2.0\r"},{"id":95,"href":"/fyne/docs/api/data/binding/externaluri/","title":"binding.ExternalURI","section":"binding","content":"binding.ExternalURI\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalURI\r#\r\rtype ExternalURI interface { \tURI \tReload() error } ExternalURI supports binding a fyne.URI value to an external value.\nSince: \r2.1\rfunc BindURI\r#\r\rfunc BindURI(v *fyne.URI) ExternalURI BindURI returns a new bindable value that controls the contents of the provided fyne.URI variable. If your code changes the content of the variable this refers to you should call Reload() to inform the bindings.\nSince: \r2.1\r"},{"id":96,"href":"/fyne/docs/api/data/binding/externalurilist/","title":"binding.ExternalURIList","section":"binding","content":"binding.ExternalURIList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype ExternalURIList\r#\r\rtype ExternalURIList interface { \tURIList  \tReload() error } ExternalURIList supports binding a list of fyne.URI values from an external variable.\nSince: \r2.1\rfunc BindURIList\r#\r\rfunc BindURIList(v *[]fyne.URI) ExternalURIList BindURIList returns a bound list of fyne.URI values, based on the contents of the passed slice. If your code changes the content of the slice this refers to you should call Reload() to inform the bindings.\nSince: \r2.1\r"},{"id":97,"href":"/fyne/docs/api/data/binding/float/","title":"binding.Float","section":"binding","content":"binding.Float\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype Float\r#\r\rtype Float interface { \tDataItem \tGet() (float64, error) \tSet(float64) error } Float supports binding a float64 value.\nSince: \r2.0\rfunc BindPreferenceFloat\r#\r\rfunc BindPreferenceFloat(key string, p fyne.Preferences) Float BindPreferenceFloat returns a bindable float64 value that is managed by the application preferences. Changes to this value will be saved to application storage and when the app starts the previous values will be read.\nSince: \r2.0\rfunc NewFloat\r#\r\rfunc NewFloat() Float NewFloat returns a bindable float64 value that is managed internally.\nSince: \r2.0\rfunc StringToFloat\r#\r\rfunc StringToFloat(str String) Float StringToFloat creates a binding that connects a String data item to a Float. Changes to the String will be parsed and pushed to the Float if the parse was successful, and setting the Float update the String binding.\nSince: \r2.0\rfunc StringToFloatWithFormat\r#\r\rfunc StringToFloatWithFormat(str String, format string) Float StringToFloatWithFormat creates a binding that connects a String data item to a Float and is presented using the specified format. Changes to the Float will be parsed and if the format matches and the parse is successful it will be pushed to the String. Setting the Float will push a formatted value into the String.\nSince: \r2.0\r"},{"id":98,"href":"/fyne/docs/api/data/binding/floatlist/","title":"binding.FloatList","section":"binding","content":"binding.FloatList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype FloatList\r#\r\rtype FloatList interface { \tDataList  \tAppend(value float64) error \tGet() ([]float64, error) \tGetValue(index int) (float64, error) \tPrepend(value float64) error \tSet(list []float64) error \tSetValue(index int, value float64) error } FloatList supports binding a list of float64 values.\nSince: \r2.0\rfunc NewFloatList\r#\r\rfunc NewFloatList() FloatList NewFloatList returns a bindable list of float64 values.\nSince: \r2.0\r"},{"id":99,"href":"/fyne/docs/api/data/binding/int/","title":"binding.Int","section":"binding","content":"binding.Int\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype Int\r#\r\rtype Int interface { \tDataItem \tGet() (int, error) \tSet(int) error } Int supports binding a int value.\nSince: \r2.0\rfunc BindPreferenceInt\r#\r\rfunc BindPreferenceInt(key string, p fyne.Preferences) Int BindPreferenceInt returns a bindable int value that is managed by the application preferences. Changes to this value will be saved to application storage and when the app starts the previous values will be read.\nSince: \r2.0\rfunc NewInt\r#\r\rfunc NewInt() Int NewInt returns a bindable int value that is managed internally.\nSince: \r2.0\rfunc StringToInt\r#\r\rfunc StringToInt(str String) Int StringToInt creates a binding that connects a String data item to a Int. Changes to the String will be parsed and pushed to the Int if the parse was successful, and setting the Int update the String binding.\nSince: \r2.0\rfunc StringToIntWithFormat\r#\r\rfunc StringToIntWithFormat(str String, format string) Int StringToIntWithFormat creates a binding that connects a String data item to a Int and is presented using the specified format. Changes to the Int will be parsed and if the format matches and the parse is successful it will be pushed to the String. Setting the Int will push a formatted value into the String.\nSince: \r2.0\r"},{"id":100,"href":"/fyne/docs/api/data/binding/intlist/","title":"binding.IntList","section":"binding","content":"binding.IntList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype IntList\r#\r\rtype IntList interface { \tDataList  \tAppend(value int) error \tGet() ([]int, error) \tGetValue(index int) (int, error) \tPrepend(value int) error \tSet(list []int) error \tSetValue(index int, value int) error } IntList supports binding a list of int values.\nSince: \r2.0\rfunc NewIntList\r#\r\rfunc NewIntList() IntList NewIntList returns a bindable list of int values.\nSince: \r2.0\r"},{"id":101,"href":"/fyne/docs/api/data/binding/rune/","title":"binding.Rune","section":"binding","content":"binding.Rune\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype Rune\r#\r\rtype Rune interface { \tDataItem \tGet() (rune, error) \tSet(rune) error } Rune supports binding a rune value.\nSince: \r2.0\rfunc NewRune\r#\r\rfunc NewRune() Rune NewRune returns a bindable rune value that is managed internally.\nSince: \r2.0\r"},{"id":102,"href":"/fyne/docs/api/data/binding/runelist/","title":"binding.RuneList","section":"binding","content":"binding.RuneList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype RuneList\r#\r\rtype RuneList interface { \tDataList  \tAppend(value rune) error \tGet() ([]rune, error) \tGetValue(index int) (rune, error) \tPrepend(value rune) error \tSet(list []rune) error \tSetValue(index int, value rune) error } RuneList supports binding a list of rune values.\nSince: \r2.0\rfunc NewRuneList\r#\r\rfunc NewRuneList() RuneList NewRuneList returns a bindable list of rune values.\nSince: \r2.0\r"},{"id":103,"href":"/fyne/docs/api/data/binding/string/","title":"binding.String","section":"binding","content":"binding.String\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype String\r#\r\rtype String interface { \tDataItem \tGet() (string, error) \tSet(string) error } String supports binding a string value.\nSince: \r2.0\rfunc BindPreferenceString\r#\r\rfunc BindPreferenceString(key string, p fyne.Preferences) String BindPreferenceString returns a bindable string value that is managed by the application preferences. Changes to this value will be saved to application storage and when the app starts the previous values will be read.\nSince: \r2.0\rfunc BoolToString\r#\r\rfunc BoolToString(v Bool) String BoolToString creates a binding that connects a Bool data item to a String. Changes to the Bool will be pushed to the String and setting the string will parse and set the Bool if the parse was successful.\nSince: \r2.0\rfunc BoolToStringWithFormat\r#\r\rfunc BoolToStringWithFormat(v Bool, format string) String BoolToStringWithFormat creates a binding that connects a Bool data item to a String and is presented using the specified format. Changes to the Bool will be pushed to the String and setting the string will parse and set the Bool if the string matches the format and its parse was successful.\nSince: \r2.0\rfunc FloatToString\r#\r\rfunc FloatToString(v Float) String FloatToString creates a binding that connects a Float data item to a String. Changes to the Float will be pushed to the String and setting the string will parse and set the Float if the parse was successful.\nSince: \r2.0\rfunc FloatToStringWithFormat\r#\r\rfunc FloatToStringWithFormat(v Float, format string) String FloatToStringWithFormat creates a binding that connects a Float data item to a String and is presented using the specified format. Changes to the Float will be pushed to the String and setting the string will parse and set the Float if the string matches the format and its parse was successful.\nSince: \r2.0\rfunc IntToString\r#\r\rfunc IntToString(v Int) String IntToString creates a binding that connects a Int data item to a String. Changes to the Int will be pushed to the String and setting the string will parse and set the Int if the parse was successful.\nSince: \r2.0\rfunc IntToStringWithFormat\r#\r\rfunc IntToStringWithFormat(v Int, format string) String IntToStringWithFormat creates a binding that connects a Int data item to a String and is presented using the specified format. Changes to the Int will be pushed to the String and setting the string will parse and set the Int if the string matches the format and its parse was successful.\nSince: \r2.0\rfunc NewString\r#\r\rfunc NewString() String NewString returns a bindable string value that is managed internally.\nSince: \r2.0\rfunc URIToString\r#\r\rfunc URIToString(v URI) String URIToString creates a binding that connects a URI data item to a String. Changes to the URI will be pushed to the String and setting the string will parse and set the URI if the parse was successful.\nSince: \r2.1\r"},{"id":104,"href":"/fyne/docs/api/data/binding/stringlist/","title":"binding.StringList","section":"binding","content":"binding.StringList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype StringList\r#\r\rtype StringList interface { \tDataList  \tAppend(value string) error \tGet() ([]string, error) \tGetValue(index int) (string, error) \tPrepend(value string) error \tSet(list []string) error \tSetValue(index int, value string) error } StringList supports binding a list of string values.\nSince: \r2.0\rfunc NewStringList\r#\r\rfunc NewStringList() StringList NewStringList returns a bindable list of string values.\nSince: \r2.0\r"},{"id":105,"href":"/fyne/docs/api/data/binding/struct/","title":"binding.Struct","section":"binding","content":"binding.Struct\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype Struct\r#\r\rtype Struct interface { \tDataMap \tGetValue(string) (interface{}, error) \tSetValue(string, interface{}) error \tReload() error } Struct is the base interface for a bound struct type.\nSince: \r2.0\rfunc BindStruct\r#\r\rfunc BindStruct(i interface{}) Struct BindStruct creates a new map binding of string to interface{} using the struct passed as data. The key for each item is a string representation of each exported field with the value set as an interface{}. Only exported fields are included.\nSince: \r2.0\r"},{"id":106,"href":"/fyne/docs/api/data/binding/untyped/","title":"binding.Untyped","section":"binding","content":"binding.Untyped\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype Untyped\r#\r\rtype Untyped interface { \tDataItem \tGet() (interface{}, error) \tSet(interface{}) error } Untyped supports binding a interface{} value.\nSince: \r2.1\rfunc NewUntyped\r#\r\rfunc NewUntyped() Untyped NewUntyped returns a bindable interface{} value that is managed internally.\nSince: \r2.1\r"},{"id":107,"href":"/fyne/docs/api/data/binding/untypedlist/","title":"binding.UntypedList","section":"binding","content":"binding.UntypedList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype UntypedList\r#\r\rtype UntypedList interface { \tDataList  \tAppend(value interface{}) error \tGet() ([]interface{}, error) \tGetValue(index int) (interface{}, error) \tPrepend(value interface{}) error \tSet(list []interface{}) error \tSetValue(index int, value interface{}) error } UntypedList supports binding a list of interface{} values.\nSince: \r2.1\rfunc NewUntypedList\r#\r\rfunc NewUntypedList() UntypedList NewUntypedList returns a bindable list of interface{} values.\nSince: \r2.1\r"},{"id":108,"href":"/fyne/docs/api/data/binding/untypedmap/","title":"binding.UntypedMap","section":"binding","content":"binding.UntypedMap\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype UntypedMap\r#\r\rtype UntypedMap interface { \tDataMap \tDelete(string) \tGet() (map[string]interface{}, error) \tGetValue(string) (interface{}, error) \tSet(map[string]interface{}) error \tSetValue(string, interface{}) error } UntypedMap is a map data binding with all values Untyped (interface{}).\nSince: \r2.0\rfunc NewUntypedMap\r#\r\rfunc NewUntypedMap() UntypedMap NewUntypedMap creates a new, empty map binding of string to interface{}.\nSince: \r2.0\r"},{"id":109,"href":"/fyne/docs/api/data/binding/uri/","title":"binding.URI","section":"binding","content":"binding.URI\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype URI\r#\r\rtype URI interface { \tDataItem \tGet() (fyne.URI, error) \tSet(fyne.URI) error } URI supports binding a fyne.URI value.\nSince: \r2.1\rfunc NewURI\r#\r\rfunc NewURI() URI NewURI returns a bindable fyne.URI value that is managed internally.\nSince: \r2.1\rfunc StringToURI\r#\r\rfunc StringToURI(str String) URI StringToURI creates a binding that connects a String data item to a URI. Changes to the String will be parsed and pushed to the URI if the parse was successful, and setting the URI update the String binding.\nSince: \r2.1\r"},{"id":110,"href":"/fyne/docs/api/data/binding/urilist/","title":"binding.URIList","section":"binding","content":"binding.URIList\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\r\rtype URIList\r#\r\rtype URIList interface { \tDataList  \tAppend(value fyne.URI) error \tGet() ([]fyne.URI, error) \tGetValue(index int) (fyne.URI, error) \tPrepend(value fyne.URI) error \tSet(list []fyne.URI) error \tSetValue(index int, value fyne.URI) error } URIList supports binding a list of fyne.URI values.\nSince: \r2.1\rfunc NewURIList\r#\r\rfunc NewURIList() URIList NewURIList returns a bindable list of fyne.URI values.\nSince: \r2.1\r"},{"id":111,"href":"/fyne/docs/api/canvas/","title":"canvas","section":"API Documentation","content":"\r\rcanvas\r\rcanvas\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Package canvas contains all of the primitive CanvasObjects that make up a Fyne GUI The types implemented in this package are used as building blocks in order to build higher order functionality. These types are designed to be non-interactive, by design. If additional functonality is required, it\u0026rsquo;s usually a sign that this type should be used as part of a custom Widget. Usage\r#\rconst ( // DurationStandard is the time a standard interface animation will run.\r\r\rcanvas.Circle\r\rcanvas.Circle\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype Circle\r#\rtype Circle struct { Position1 fyne.Position // The current top-left position of the Circle Position2 fyne.Position // The current bottomright position of the Circle Hidden bool // Is this circle currently hidden FillColor color.Color // The circle fill color StrokeColor color.Color // The circle stroke color StrokeWidth float32 // The stroke width of the circle } Circle describes a colored circle primitive in a Fyne canvas\r\r\rcanvas.Image\r\rcanvas.Image\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype Image\r#\rtype Image struct { // one of the following sources will provide our image data File string // Load the image from a file Resource fyne.Resource // Load the image from an in-memory resource Image image.Image // Specify a loaded image to use in this canvas object Translucency float64 // Set a translucency value \u0026gt; 0.\r\r\rcanvas.ImageFill\r\rcanvas.ImageFill\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype ImageFill\r#\rtype ImageFill int ImageFill defines the different type of ways an image can stretch to fill its space. const ( // ImageFillStretch will scale the image to match the Size() values. // This is the default and does not maintain aspect ratio. ImageFillStretch ImageFill = iota // ImageFillContain makes the image fit within the object Size(), // centrally and maintaining aspect ratio.\r\r\rcanvas.ImageScale\r\rcanvas.ImageScale\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype ImageScale\r#\rtype ImageScale int32 ImageScale defines the different scaling filters used to scaling images const ( // ImageScaleSmooth will scale the image using ApproxBiLinear filter (or GL equivalent) ImageScaleSmooth ImageScale = 0 // ImageScalePixels will scale the image using NearestNeighbor filter (or GL equivalent) ImageScalePixels ImageScale = 1 // ImageScaleFastest will scale the image using hardware GPU if available // // Since: 2.\r\r\rcanvas.Line\r\rcanvas.Line\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype Line\r#\rtype Line struct { Position1 fyne.Position // The current top-left position of the Line Position2 fyne.Position // The current bottomright position of the Line Hidden bool // Is this Line currently hidden StrokeColor color.Color // The line stroke color StrokeWidth float32 // The stroke width of the line } Line describes a colored line primitive in a Fyne canvas.\r\r\rcanvas.LinearGradient\r\rcanvas.LinearGradient\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype LinearGradient\r#\rtype LinearGradient struct { StartColor color.Color // The beginning color of the gradient EndColor color.Color // The end color of the gradient Angle float64 // The angle of the gradient (0/180 for vertical; 90/270 for horizontal) } LinearGradient defines a Gradient travelling straight at a given angle. The only supported values for the angle are 0.\r\r\rcanvas.RadialGradient\r\rcanvas.RadialGradient\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype RadialGradient\r#\rtype RadialGradient struct { StartColor color.Color // The beginning color of the gradient EndColor color.Color // The end color of the gradient // The offset of the center for generation of the gradient. // This is not a DP measure but relates to the width/height. // A value of 0.5 would move the center by the half width/height.\r\r\rcanvas.Raster\r\rcanvas.Raster\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype Raster\r#\rtype Raster struct { // Render the raster image from code Generator func(w, h int) image.Image // Set a translucency value \u0026gt; 0.0 to fade the raster Translucency float64 // Specify the type of scaling interpolation applied to the raster if it is not full-size // Since: 1.4.1 ScaleMode ImageScale } Raster describes a raster image area that can render in a Fyne canvas\r\r\rcanvas.Rectangle\r\rcanvas.Rectangle\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype Rectangle\r#\rtype Rectangle struct { FillColor color.Color // The rectangle fill color StrokeColor color.Color // The rectangle stroke color StrokeWidth float32 // The stroke width of the rectangle } Rectangle describes a colored rectangle primitive in a Fyne canvas func NewRectangle\r#\rfunc NewRectangle(color color.Color) *Rectangle NewRectangle returns a new Rectangle instance func (*Rectangle) Hide\r#\rfunc (r *Rectangle) Hide() Hide will set this object to not be visible.\r\r\rcanvas.Text\r\rcanvas.Text\r#\rimport \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\rtype Text\r#\rtype Text struct { Alignment fyne.TextAlign // The alignment of the text content Color color.Color // The main text draw color Text string // The string content of this Text TextSize float32 // Size of the text - if the Canvas scale is 1.0 this will be equivalent to point size TextStyle fyne.\r\r\r"},{"id":112,"href":"/fyne/docs/api/canvas/","title":"canvas","section":"canvas","content":"canvas\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Package canvas contains all of the primitive CanvasObjects that make up a Fyne GUI\nThe types implemented in this package are used as building blocks in order to build higher order functionality. These types are designed to be non-interactive, by design. If additional functonality is required, it\u0026rsquo;s usually a sign that this type should be used as part of a custom Widget.\nUsage\r#\r\rconst ( \t// DurationStandard is the time a standard interface animation will run. \t// \t// Since: 2.0 \tDurationStandard = time.Millisecond * 300 \t// DurationShort is the time a subtle or small transition should use. \t// \t// Since: 2.0 \tDurationShort = time.Millisecond * 150 ) func NewColorRGBAAnimation\r#\r\rfunc NewColorRGBAAnimation(start, stop color.Color, d time.Duration, fn func(color.Color)) *fyne.Animation NewColorRGBAAnimation sets up a new animation that will transition from the start to stop Color over the specified Duration. The colour transition will move linearly through the RGB colour space. The content of fn should apply the color values to an object and refresh it. You should call Start() on the returned animation to start it.\nSince: \r2.0\rfunc NewPositionAnimation\r#\r\rfunc NewPositionAnimation(start, stop fyne.Position, d time.Duration, fn func(fyne.Position)) *fyne.Animation NewPositionAnimation sets up a new animation that will transition from the start to stop Position over the specified Duration. The content of fn should apply the position value to an object for the change to be visible. You should call Start() on the returned animation to start it.\nSince: \r2.0\rfunc NewSizeAnimation\r#\r\rfunc NewSizeAnimation(start, stop fyne.Size, d time.Duration, fn func(fyne.Size)) *fyne.Animation NewSizeAnimation sets up a new animation that will transition from the start to stop Size over the specified Duration. The content of fn should apply the size value to an object for the change to be visible. You should call Start() on the returned animation to start it.\nSince: \r2.0\rfunc Refresh\r#\r\rfunc Refresh(obj fyne.CanvasObject) Refresh instructs the containing canvas to refresh the specified obj.\ntypes\r#\r\r \rCircle \rImage \rImageFill \rImageScale \rLine \rLinearGradient \rRadialGradient \rRaster \rRectangle \rText  "},{"id":113,"href":"/fyne/docs/api/canvas/circle/","title":"canvas.Circle","section":"canvas","content":"canvas.Circle\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype Circle\r#\r\rtype Circle struct { \tPosition1 fyne.Position // The current top-left position of the Circle \tPosition2 fyne.Position // The current bottomright position of the Circle \tHidden bool // Is this circle currently hidden  \tFillColor color.Color // The circle fill color \tStrokeColor color.Color // The circle stroke color \tStrokeWidth float32 // The stroke width of the circle } Circle describes a colored circle primitive in a Fyne canvas\nfunc NewCircle\r#\r\rfunc NewCircle(color color.Color) *Circle NewCircle returns a new Circle instance\nfunc (*Circle) Hide\r#\r\rfunc (l *Circle) Hide() Hide will set this circle to not be visible\nfunc (*Circle) MinSize\r#\r\rfunc (l *Circle) MinSize() fyne.Size MinSize for a Circle simply returns Size{1, 1} as there is no explicit content\nfunc (*Circle) Move\r#\r\rfunc (l *Circle) Move(pos fyne.Position) Move the circle object to a new position, relative to its parent / canvas\nfunc (*Circle) Position\r#\r\rfunc (l *Circle) Position() fyne.Position Position gets the current top-left position of this circle object, relative to its parent / canvas\nfunc (*Circle) Refresh\r#\r\rfunc (l *Circle) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*Circle) Resize\r#\r\rfunc (l *Circle) Resize(size fyne.Size) Resize sets a new bottom-right position for the circle object If it has a stroke width this will cause it to Refresh.\nfunc (*Circle) Show\r#\r\rfunc (l *Circle) Show() Show will set this circle to be visible\nfunc (*Circle) Size\r#\r\rfunc (l *Circle) Size() fyne.Size Size returns the current size of bounding box for this circle object\nfunc (*Circle) Visible\r#\r\rfunc (l *Circle) Visible() bool Visible returns true if this circle is visible, false otherwise\n"},{"id":114,"href":"/fyne/docs/api/canvas/image/","title":"canvas.Image","section":"canvas","content":"canvas.Image\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype Image\r#\r\rtype Image struct {  \t// one of the following sources will provide our image data \tFile string // Load the image from a file \tResource fyne.Resource // Load the image from an in-memory resource \tImage image.Image // Specify a loaded image to use in this canvas object  \tTranslucency float64 // Set a translucency value \u0026gt; 0.0 to fade the image \tFillMode ImageFill // Specify how the image should expand to fill or fit the available space \tScaleMode ImageScale // Specify the type of scaling interpolation applied to the image } Image describes a drawable image area that can render in a Fyne canvas The image may be a vector or a bitmap representation and it will fill the area. The fill mode can be changed by setting FillMode to a different ImageFill.\nfunc NewImageFromFile\r#\r\rfunc NewImageFromFile(file string) *Image NewImageFromFile creates a new image from a local file. Images returned from this method will scale to fit the canvas object. The method for scaling can be set using the Fill field.\nfunc NewImageFromImage\r#\r\rfunc NewImageFromImage(img image.Image) *Image NewImageFromImage returns a new Image instance that is rendered from the Go image.Image passed in. Images returned from this method will scale to fit the canvas object. The method for scaling can be set using the Fill field.\nfunc NewImageFromReader\r#\r\rfunc NewImageFromReader(read io.Reader, name string) *Image NewImageFromReader creates a new image from a data stream. The name parameter is required to uniquely identify this image (for caching etc). If the image in this io.Reader is an SVG, the name should end \u0026ldquo;.svg\u0026rdquo;. Images returned from this method will scale to fit the canvas object. The method for scaling can be set using the Fill field.\nSince: \r2.0\rfunc NewImageFromResource\r#\r\rfunc NewImageFromResource(res fyne.Resource) *Image NewImageFromResource creates a new image by loading the specified resource. Images returned from this method will scale to fit the canvas object. The method for scaling can be set using the Fill field.\nfunc NewImageFromURI\r#\r\rfunc NewImageFromURI(uri fyne.URI) *Image NewImageFromURI creates a new image from named resource. File URIs will read the file path and other schemes will download the data into a resource. HTTP and HTTPs URIs will use the GET method by default to request the resource. Images returned from this method will scale to fit the canvas object. The method for scaling can be set using the Fill field.\nSince: \r2.0\rfunc (*Image) Alpha\r#\r\rfunc (i *Image) Alpha() float64 Alpha is a convenience function that returns the alpha value for an image based on its Translucency value. The result is 1.0 - Translucency.\nfunc (*Image) Hide\r#\r\rfunc (r *Image) Hide() Hide will set this object to not be visible.\nfunc (*Image) MinSize\r#\r\rfunc (r *Image) MinSize() fyne.Size MinSize returns the specified minimum size, if set, or {1, 1} otherwise.\nfunc (*Image) Move\r#\r\rfunc (r *Image) Move(pos fyne.Position) Move the object to a new position, relative to its parent.\nfunc (*Image) Position\r#\r\rfunc (r *Image) Position() fyne.Position CurrentPosition gets the current position of this canvas object, relative to its parent.\nfunc (*Image) Refresh\r#\r\rfunc (i *Image) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*Image) Resize\r#\r\rfunc (i *Image) Resize(s fyne.Size) Resize on an image will scale the content or reposition it according to FillMode. It will normally cause a Refresh to ensure the pixels are recalculated.\nfunc (*Image) SetMinSize\r#\r\rfunc (r *Image) SetMinSize(size fyne.Size) SetMinSize specifies the smallest size this object should be.\nfunc (*Image) Show\r#\r\rfunc (r *Image) Show() Show will set this object to be visible.\nfunc (*Image) Size\r#\r\rfunc (r *Image) Size() fyne.Size CurrentSize returns the current size of this canvas object.\nfunc (*Image) Visible\r#\r\rfunc (r *Image) Visible() bool IsVisible returns true if this object is visible, false otherwise.\n"},{"id":115,"href":"/fyne/docs/api/canvas/imagefill/","title":"canvas.ImageFill","section":"canvas","content":"canvas.ImageFill\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype ImageFill\r#\r\rtype ImageFill int ImageFill defines the different type of ways an image can stretch to fill its space.\nconst ( \t// ImageFillStretch will scale the image to match the Size() values. \t// This is the default and does not maintain aspect ratio. \tImageFillStretch ImageFill = iota \t// ImageFillContain makes the image fit within the object Size(), \t// centrally and maintaining aspect ratio. \t// There may be transparent sections top and bottom or left and right. \tImageFillContain //(Fit) \t// ImageFillOriginal ensures that the container grows to the pixel dimensions \t// required to fit the original image. The aspect of the image will be maintained so, \t// as with ImageFillContain there may be transparent areas around the image. \t// Note that the minSize may be smaller than the image dimensions if scale \u0026gt; 1. \tImageFillOriginal ) "},{"id":116,"href":"/fyne/docs/api/canvas/imagescale/","title":"canvas.ImageScale","section":"canvas","content":"canvas.ImageScale\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype ImageScale\r#\r\rtype ImageScale int32 ImageScale defines the different scaling filters used to scaling images\nconst ( \t// ImageScaleSmooth will scale the image using ApproxBiLinear filter (or GL equivalent) \tImageScaleSmooth ImageScale = 0 \t// ImageScalePixels will scale the image using NearestNeighbor filter (or GL equivalent) \tImageScalePixels ImageScale = 1 \t// ImageScaleFastest will scale the image using hardware GPU if available \t// \t// Since: 2.0 \tImageScaleFastest ImageScale = 2 ) "},{"id":117,"href":"/fyne/docs/api/canvas/line/","title":"canvas.Line","section":"canvas","content":"canvas.Line\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype Line\r#\r\rtype Line struct { \tPosition1 fyne.Position // The current top-left position of the Line \tPosition2 fyne.Position // The current bottomright position of the Line \tHidden bool // Is this Line currently hidden  \tStrokeColor color.Color // The line stroke color \tStrokeWidth float32 // The stroke width of the line } Line describes a colored line primitive in a Fyne canvas. Lines are special as they can have a negative width or height to indicate an inverse slope (i.e. slope up vs down).\nfunc NewLine\r#\r\rfunc NewLine(color color.Color) *Line NewLine returns a new Line instance\nfunc (*Line) Hide\r#\r\rfunc (l *Line) Hide() Hide will set this line to not be visible\nfunc (*Line) MinSize\r#\r\rfunc (l *Line) MinSize() fyne.Size MinSize for a Line simply returns Size{1, 1} as there is no explicit content\nfunc (*Line) Move\r#\r\rfunc (l *Line) Move(pos fyne.Position) Move the line object to a new position, relative to its parent / canvas\nfunc (*Line) Position\r#\r\rfunc (l *Line) Position() fyne.Position Position gets the current top-left position of this line object, relative to its parent / canvas\nfunc (*Line) Refresh\r#\r\rfunc (l *Line) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*Line) Resize\r#\r\rfunc (l *Line) Resize(size fyne.Size) Resize sets a new bottom-right position for the line object and it will then be refreshed.\nfunc (*Line) Show\r#\r\rfunc (l *Line) Show() Show will set this line to be visible\nfunc (*Line) Size\r#\r\rfunc (l *Line) Size() fyne.Size Size returns the current size of bounding box for this line object\nfunc (*Line) Visible\r#\r\rfunc (l *Line) Visible() bool Visible returns true if this line// Show will set this circle to be visible is visible, false otherwise\n"},{"id":118,"href":"/fyne/docs/api/canvas/lineargradient/","title":"canvas.LinearGradient","section":"canvas","content":"canvas.LinearGradient\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype LinearGradient\r#\r\rtype LinearGradient struct { \tStartColor color.Color // The beginning color of the gradient \tEndColor color.Color // The end color of the gradient \tAngle float64 // The angle of the gradient (0/180 for vertical; 90/270 for horizontal) } LinearGradient defines a Gradient travelling straight at a given angle. The only supported values for the angle are 0.0 (vertical) and 90.0 (horizontal), currently.\nfunc NewHorizontalGradient\r#\r\rfunc NewHorizontalGradient(start, end color.Color) *LinearGradient NewHorizontalGradient creates a new horizontally travelling linear gradient. The start color will be at the left of the gradient and the end color will be at the right.\nfunc NewLinearGradient\r#\r\rfunc NewLinearGradient(start, end color.Color, angle float64) *LinearGradient NewLinearGradient creates a linear gradient at a the specified angle. The angle parameter is the degree angle along which the gradient is calculated. A NewHorizontalGradient uses 270 degrees and NewVerticalGradient is 0 degrees.\nfunc NewVerticalGradient\r#\r\rfunc NewVerticalGradient(start color.Color, end color.Color) *LinearGradient NewVerticalGradient creates a new vertically travelling linear gradient. The start color will be at the top of the gradient and the end color will be at the bottom.\nfunc (*LinearGradient) Generate\r#\r\rfunc (g *LinearGradient) Generate(iw, ih int) image.Image Generate calculates an image of the gradient with the specified width and height.\nfunc (*LinearGradient) Hide\r#\r\rfunc (r *LinearGradient) Hide() Hide will set this object to not be visible.\nfunc (*LinearGradient) MinSize\r#\r\rfunc (r *LinearGradient) MinSize() fyne.Size MinSize returns the specified minimum size, if set, or {1, 1} otherwise.\nfunc (*LinearGradient) Move\r#\r\rfunc (r *LinearGradient) Move(pos fyne.Position) Move the object to a new position, relative to its parent.\nfunc (*LinearGradient) Position\r#\r\rfunc (r *LinearGradient) Position() fyne.Position CurrentPosition gets the current position of this canvas object, relative to its parent.\nfunc (*LinearGradient) Refresh\r#\r\rfunc (g *LinearGradient) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*LinearGradient) Resize\r#\r\rfunc (r *LinearGradient) Resize(size fyne.Size) Resize sets a new size for the canvas object.\nfunc (*LinearGradient) SetMinSize\r#\r\rfunc (r *LinearGradient) SetMinSize(size fyne.Size) SetMinSize specifies the smallest size this object should be.\nfunc (*LinearGradient) Show\r#\r\rfunc (r *LinearGradient) Show() Show will set this object to be visible.\nfunc (*LinearGradient) Size\r#\r\rfunc (r *LinearGradient) Size() fyne.Size CurrentSize returns the current size of this canvas object.\nfunc (*LinearGradient) Visible\r#\r\rfunc (r *LinearGradient) Visible() bool IsVisible returns true if this object is visible, false otherwise.\n"},{"id":119,"href":"/fyne/docs/api/canvas/radialgradient/","title":"canvas.RadialGradient","section":"canvas","content":"canvas.RadialGradient\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype RadialGradient\r#\r\rtype RadialGradient struct { \tStartColor color.Color // The beginning color of the gradient \tEndColor color.Color // The end color of the gradient \t// The offset of the center for generation of the gradient. \t// This is not a DP measure but relates to the width/height. \t// A value of 0.5 would move the center by the half width/height. \tCenterOffsetX, CenterOffsetY float64 } RadialGradient defines a Gradient travelling radially from a center point outward.\nfunc NewRadialGradient\r#\r\rfunc NewRadialGradient(start, end color.Color) *RadialGradient NewRadialGradient creates a new radial gradient.\nfunc (*RadialGradient) Generate\r#\r\rfunc (g *RadialGradient) Generate(iw, ih int) image.Image Generate calculates an image of the gradient with the specified width and height.\nfunc (*RadialGradient) Hide\r#\r\rfunc (r *RadialGradient) Hide() Hide will set this object to not be visible.\nfunc (*RadialGradient) MinSize\r#\r\rfunc (r *RadialGradient) MinSize() fyne.Size MinSize returns the specified minimum size, if set, or {1, 1} otherwise.\nfunc (*RadialGradient) Move\r#\r\rfunc (r *RadialGradient) Move(pos fyne.Position) Move the object to a new position, relative to its parent.\nfunc (*RadialGradient) Position\r#\r\rfunc (r *RadialGradient) Position() fyne.Position CurrentPosition gets the current position of this canvas object, relative to its parent.\nfunc (*RadialGradient) Refresh\r#\r\rfunc (g *RadialGradient) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*RadialGradient) Resize\r#\r\rfunc (r *RadialGradient) Resize(size fyne.Size) Resize sets a new size for the canvas object.\nfunc (*RadialGradient) SetMinSize\r#\r\rfunc (r *RadialGradient) SetMinSize(size fyne.Size) SetMinSize specifies the smallest size this object should be.\nfunc (*RadialGradient) Show\r#\r\rfunc (r *RadialGradient) Show() Show will set this object to be visible.\nfunc (*RadialGradient) Size\r#\r\rfunc (r *RadialGradient) Size() fyne.Size CurrentSize returns the current size of this canvas object.\nfunc (*RadialGradient) Visible\r#\r\rfunc (r *RadialGradient) Visible() bool IsVisible returns true if this object is visible, false otherwise.\n"},{"id":120,"href":"/fyne/docs/api/canvas/raster/","title":"canvas.Raster","section":"canvas","content":"canvas.Raster\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype Raster\r#\r\rtype Raster struct {  \t// Render the raster image from code \tGenerator func(w, h int) image.Image  \t// Set a translucency value \u0026gt; 0.0 to fade the raster \tTranslucency float64 \t// Specify the type of scaling interpolation applied to the raster if it is not full-size \t// Since: 1.4.1 \tScaleMode ImageScale } Raster describes a raster image area that can render in a Fyne canvas\nfunc NewRaster\r#\r\rfunc NewRaster(generate func(w, h int) image.Image) *Raster NewRaster returns a new Image instance that is rendered dynamically using the specified generate function. Images returned from this method should draw dynamically to fill the width and height parameters passed to pixelColor.\nfunc NewRasterFromImage\r#\r\rfunc NewRasterFromImage(img image.Image) *Raster NewRasterFromImage returns a new Raster instance that is rendered from the Go image.Image passed in. Rasters returned from this method will map pixel for pixel to the screen starting img.Bounds().Min pixels from the top left of the canvas object. Truncates rather than scales the image. If smaller than the target space, the image will be padded with zero-pixels to the target size.\nfunc NewRasterWithPixels\r#\r\rfunc NewRasterWithPixels(pixelColor func(x, y, w, h int) color.Color) *Raster NewRasterWithPixels returns a new Image instance that is rendered dynamically by iterating over the specified pixelColor function for each x, y pixel. Images returned from this method should draw dynamically to fill the width and height parameters passed to pixelColor.\nfunc (*Raster) Alpha\r#\r\rfunc (r *Raster) Alpha() float64 Alpha is a convenience function that returns the alpha value for a raster based on its Translucency value. The result is 1.0 - Translucency.\nfunc (*Raster) Hide\r#\r\rfunc (r *Raster) Hide() Hide will set this object to not be visible.\nfunc (*Raster) MinSize\r#\r\rfunc (r *Raster) MinSize() fyne.Size MinSize returns the specified minimum size, if set, or {1, 1} otherwise.\nfunc (*Raster) Move\r#\r\rfunc (r *Raster) Move(pos fyne.Position) Move the object to a new position, relative to its parent.\nfunc (*Raster) Position\r#\r\rfunc (r *Raster) Position() fyne.Position CurrentPosition gets the current position of this canvas object, relative to its parent.\nfunc (*Raster) Refresh\r#\r\rfunc (r *Raster) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*Raster) Resize\r#\r\rfunc (r *Raster) Resize(s fyne.Size) Resize on a raster image causes the new size to be set and then calls Refresh. This causes the underlying data to be recalculated and a new output to be drawn.\nfunc (*Raster) SetMinSize\r#\r\rfunc (r *Raster) SetMinSize(size fyne.Size) SetMinSize specifies the smallest size this object should be.\nfunc (*Raster) Show\r#\r\rfunc (r *Raster) Show() Show will set this object to be visible.\nfunc (*Raster) Size\r#\r\rfunc (r *Raster) Size() fyne.Size CurrentSize returns the current size of this canvas object.\nfunc (*Raster) Visible\r#\r\rfunc (r *Raster) Visible() bool IsVisible returns true if this object is visible, false otherwise.\n"},{"id":121,"href":"/fyne/docs/api/canvas/rectangle/","title":"canvas.Rectangle","section":"canvas","content":"canvas.Rectangle\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype Rectangle\r#\r\rtype Rectangle struct { \tFillColor color.Color // The rectangle fill color \tStrokeColor color.Color // The rectangle stroke color \tStrokeWidth float32 // The stroke width of the rectangle } Rectangle describes a colored rectangle primitive in a Fyne canvas\nfunc NewRectangle\r#\r\rfunc NewRectangle(color color.Color) *Rectangle NewRectangle returns a new Rectangle instance\nfunc (*Rectangle) Hide\r#\r\rfunc (r *Rectangle) Hide() Hide will set this object to not be visible.\nfunc (*Rectangle) MinSize\r#\r\rfunc (r *Rectangle) MinSize() fyne.Size MinSize returns the specified minimum size, if set, or {1, 1} otherwise.\nfunc (*Rectangle) Move\r#\r\rfunc (r *Rectangle) Move(pos fyne.Position) Move the object to a new position, relative to its parent.\nfunc (*Rectangle) Position\r#\r\rfunc (r *Rectangle) Position() fyne.Position CurrentPosition gets the current position of this canvas object, relative to its parent.\nfunc (*Rectangle) Refresh\r#\r\rfunc (r *Rectangle) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*Rectangle) Resize\r#\r\rfunc (r *Rectangle) Resize(s fyne.Size) Resize on a rectangle updates the new size of this object. If it has a stroke width this will cause it to Refresh.\nfunc (*Rectangle) SetMinSize\r#\r\rfunc (r *Rectangle) SetMinSize(size fyne.Size) SetMinSize specifies the smallest size this object should be.\nfunc (*Rectangle) Show\r#\r\rfunc (r *Rectangle) Show() Show will set this object to be visible.\nfunc (*Rectangle) Size\r#\r\rfunc (r *Rectangle) Size() fyne.Size CurrentSize returns the current size of this canvas object.\nfunc (*Rectangle) Visible\r#\r\rfunc (r *Rectangle) Visible() bool IsVisible returns true if this object is visible, false otherwise.\n"},{"id":122,"href":"/fyne/docs/api/canvas/text/","title":"canvas.Text","section":"canvas","content":"canvas.Text\r#\r\r import \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; Usage\r#\r\rtype Text\r#\r\rtype Text struct { \tAlignment fyne.TextAlign // The alignment of the text content  \tColor color.Color // The main text draw color \tText string // The string content of this Text \tTextSize float32 // Size of the text - if the Canvas scale is 1.0 this will be equivalent to point size \tTextStyle fyne.TextStyle // The style of the text content } Text describes a text primitive in a Fyne canvas. A text object can have a style set which will apply to the whole string. No formatting or text parsing will be performed\nfunc NewText\r#\r\rfunc NewText(text string, color color.Color) *Text NewText returns a new Text implementation\nfunc (*Text) Hide\r#\r\rfunc (r *Text) Hide() Hide will set this object to not be visible.\nfunc (*Text) MinSize\r#\r\rfunc (t *Text) MinSize() fyne.Size MinSize returns the minimum size of this text object based on its font size and content. This is normally determined by the render implementation.\nfunc (*Text) Move\r#\r\rfunc (r *Text) Move(pos fyne.Position) Move the object to a new position, relative to its parent.\nfunc (*Text) Position\r#\r\rfunc (r *Text) Position() fyne.Position CurrentPosition gets the current position of this canvas object, relative to its parent.\nfunc (*Text) Refresh\r#\r\rfunc (t *Text) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*Text) Resize\r#\r\rfunc (r *Text) Resize(size fyne.Size) Resize sets a new size for the canvas object.\nfunc (*Text) SetMinSize\r#\r\rfunc (t *Text) SetMinSize(size fyne.Size) SetMinSize has no effect as the smallest size this canvas object can be is based on its font size and content.\nfunc (*Text) Show\r#\r\rfunc (r *Text) Show() Show will set this object to be visible.\nfunc (*Text) Size\r#\r\rfunc (r *Text) Size() fyne.Size CurrentSize returns the current size of this canvas object.\nfunc (*Text) Visible\r#\r\rfunc (r *Text) Visible() bool IsVisible returns true if this object is visible, false otherwise.\n"},{"id":123,"href":"/fyne/docs/api/container/","title":"container","section":"API Documentation","content":"\r\rcontainer\r\rcontainer\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Package container provides container widgets that are used to lay out and organise applications Usage\r#\rconst ( // ScrollBoth supports horizontal and vertical scrolling. ScrollBoth ScrollDirection = widget.ScrollBoth // ScrollHorizontalOnly specifies the scrolling should only happen left to right. ScrollHorizontalOnly = widget.ScrollHorizontalOnly // ScrollVerticalOnly specifies the scrolling should only happen top to bottom. ScrollVerticalOnly = widget.ScrollVerticalOnly // ScrollNone turns off scrolling for this container.\r\r\rcontainer.AppTabs\r\rcontainer.AppTabs\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\rtype AppTabs\r#\rtype AppTabs struct { widget.BaseWidget Items []*TabItem // Deprecated: Use `OnSelected func(*TabItem)` instead. OnChanged func(*TabItem) OnSelected func(*TabItem) OnUnselected func(*TabItem) } AppTabs container is used to split your application into various different areas identified by tabs. The tabs contain text and/or an icon and allow the user to switch between the content specified in each TabItem.\r\r\rcontainer.DocTabs\r\rcontainer.DocTabs\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\rtype DocTabs\r#\rtype DocTabs struct { widget.BaseWidget Items []*TabItem CreateTab func() *TabItem CloseIntercept func(*TabItem) OnClosed func(*TabItem) OnSelected func(*TabItem) OnUnselected func(*TabItem) } DocTabs container is used to display various pieces of content identified by tabs. The tabs contain text and/or an icon and allow the user to switch between the content specified in each TabItem.\r\r\rcontainer.Scroll\r\rcontainer.Scroll\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\rtype Scroll\r#\rtype Scroll = widget.Scroll Scroll defines a container that is smaller than the Content. The Offset is used to determine the position of the child widgets within the container. Since: 1.4\rfunc NewHScroll\r#\rfunc NewHScroll(content fyne.CanvasObject) *Scroll NewHScroll create a scrollable parent wrapping the specified content. Note that this may cause the MinSize.Width to be smaller than that of the passed object.\r\r\rcontainer.ScrollDirection\r\rcontainer.ScrollDirection\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\rtype ScrollDirection\r#\rtype ScrollDirection = widget.ScrollDirection ScrollDirection represents the directions in which a Scroll container can scroll its child content. Since: 1.4\r\r\rcontainer.Split\r\rcontainer.Split\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\rtype Split\r#\rtype Split struct { widget.BaseWidget Offset float64 Horizontal bool Leading fyne.CanvasObject Trailing fyne.CanvasObject } Split defines a container whose size is split between two children. Since: 1.4\rfunc NewHSplit\r#\rfunc NewHSplit(leading, trailing fyne.CanvasObject) *Split NewHSplit creates a horizontally arranged container with the specified leading and trailing elements. A vertical split bar that can be dragged will be added between the elements.\r\r\rcontainer.TabItem\r\rcontainer.TabItem\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\rtype TabItem\r#\rtype TabItem struct { Text string Icon fyne.Resource Content fyne.CanvasObject } TabItem represents a single view in a tab view. The Text and Icon are used for the tab button and the Content is shown when the corresponding tab is active. Since: 1.4\rfunc NewTabItem\r#\rfunc NewTabItem(text string, content fyne.CanvasObject) *TabItem NewTabItem creates a new item for a tabbed widget - each item specifies the content and a label for its tab.\r\r\rcontainer.TabLocation\r\rcontainer.TabLocation\r#\rimport \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\rtype TabLocation\r#\rtype TabLocation int TabLocation is the location where the tabs of a tab container should be rendered Since: 1.4\rconst ( TabLocationTop TabLocation = iota TabLocationLeading TabLocationBottom TabLocationTrailing ) TabLocation values\r\r\r"},{"id":124,"href":"/fyne/docs/api/container/","title":"container","section":"container","content":"container\r#\r\r import \u0026#34;fyne.io/fyne/v2/container\u0026#34; Package container provides container widgets that are used to lay out and organise applications\nUsage\r#\r\rconst ( \t// ScrollBoth supports horizontal and vertical scrolling. \tScrollBoth ScrollDirection = widget.ScrollBoth \t// ScrollHorizontalOnly specifies the scrolling should only happen left to right. \tScrollHorizontalOnly = widget.ScrollHorizontalOnly \t// ScrollVerticalOnly specifies the scrolling should only happen top to bottom. \tScrollVerticalOnly = widget.ScrollVerticalOnly \t// ScrollNone turns off scrolling for this container. \t// \t// Since: 2.1 \tScrollNone = widget.ScrollNone ) Constants for valid values of ScrollDirection.\nfunc New\r#\r\rfunc New(layout fyne.Layout, objects ...fyne.CanvasObject) *fyne.Container New returns a new Container instance holding the specified CanvasObjects which will be laid out according to the specified Layout.\nSince: \r2.0\rfunc NewAdaptiveGrid\r#\r\rfunc NewAdaptiveGrid(rowcols int, objects ...fyne.CanvasObject) *fyne.Container NewAdaptiveGrid creates a new container with the specified objects and using the grid layout. When in a horizontal arrangement the rowcols parameter will specify the column count, when in vertical it will specify the rows. On mobile this will dynamically refresh when device is rotated.\nSince: \r1.4\rfunc NewBorder\r#\r\rfunc NewBorder(top, bottom, left, right fyne.CanvasObject, objects ...fyne.CanvasObject) *fyne.Container NewBorder creates a new container with the specified objects and using the border layout. The top, bottom, left and right parameters specify the items that should be placed around edges, the remaining elements will be in the center. Nil can be used to an edge if it should not be filled.\nSince: \r1.4\rfunc NewCenter\r#\r\rfunc NewCenter(objects ...fyne.CanvasObject) *fyne.Container NewCenter creates a new container with the specified objects centered in the available space.\nSince: \r1.4\rfunc NewGridWithColumns\r#\r\rfunc NewGridWithColumns(cols int, objects ...fyne.CanvasObject) *fyne.Container NewGridWithColumns creates a new container with the specified objects and using the grid layout with a specified number of columns. The number of rows will depend on how many children are in the container.\nSince: \r1.4\rfunc NewGridWithRows\r#\r\rfunc NewGridWithRows(rows int, objects ...fyne.CanvasObject) *fyne.Container NewGridWithRows creates a new container with the specified objects and using the grid layout with a specified number of rows. The number of columns will depend on how many children are in the container.\nSince: \r1.4\rfunc NewGridWrap\r#\r\rfunc NewGridWrap(size fyne.Size, objects ...fyne.CanvasObject) *fyne.Container NewGridWrap creates a new container with the specified objects and using the gridwrap layout. Every element will be resized to the size parameter and the content will arrange along a row and flow to a new row if the elements don\u0026rsquo;t fit.\nSince: \r1.4\rfunc NewHBox\r#\r\rfunc NewHBox(objects ...fyne.CanvasObject) *fyne.Container NewHBox creates a new container with the specified objects and using the HBox layout. The objects will be placed in the container from left to right.\nSince: \r1.4\rfunc NewMax\r#\r\rfunc NewMax(objects ...fyne.CanvasObject) *fyne.Container NewMax creates a new container with the specified objects filling the available space.\nSince: \r1.4\rfunc NewPadded\r#\r\rfunc NewPadded(objects ...fyne.CanvasObject) *fyne.Container NewPadded creates a new container with the specified objects inset by standard padding size.\nSince: \r1.4\rfunc NewVBox\r#\r\rfunc NewVBox(objects ...fyne.CanvasObject) *fyne.Container NewVBox creates a new container with the specified objects and using the VBox layout. The objects will be stacked in the container from top to bottom.\nSince: \r1.4\rfunc NewWithoutLayout\r#\r\rfunc NewWithoutLayout(objects ...fyne.CanvasObject) *fyne.Container NewWithoutLayout returns a new Container instance holding the specified CanvasObjects that are manually arranged.\nSince: \r2.0\rtypes\r#\r\r \rAppTabs \rDocTabs \rScroll \rScrollDirection \rSplit \rTabItem \rTabLocation  "},{"id":125,"href":"/fyne/docs/api/container/apptabs/","title":"container.AppTabs","section":"container","content":"container.AppTabs\r#\r\r import \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\r\rtype AppTabs\r#\r\rtype AppTabs struct { \twidget.BaseWidget  \tItems []*TabItem  \t// Deprecated: Use `OnSelected func(*TabItem)` instead. \tOnChanged func(*TabItem) \tOnSelected func(*TabItem) \tOnUnselected func(*TabItem) } AppTabs container is used to split your application into various different areas identified by tabs. The tabs contain text and/or an icon and allow the user to switch between the content specified in each TabItem. Each item is represented by a button at the edge of the container.\nSince: \r1.4\rfunc NewAppTabs\r#\r\rfunc NewAppTabs(items ...*TabItem) *AppTabs NewAppTabs creates a new tab container that allows the user to choose between different areas of an app.\nSince: \r1.4\rfunc (*AppTabs) Append\r#\r\rfunc (t *AppTabs) Append(item *TabItem) Append adds a new TabItem to the end of the tab bar.\nfunc (*AppTabs) CreateRenderer\r#\r\rfunc (t *AppTabs) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nImplements: \rfyne.Widget\rfunc (*AppTabs) CurrentTab\r#\r\rfunc (t *AppTabs) CurrentTab() *TabItem CurrentTab returns the currently selected TabItem.\nDeprecated: Use `AppTabs.Selected() *TabItem` instead.\rfunc (*AppTabs) CurrentTabIndex\r#\r\rfunc (t *AppTabs) CurrentTabIndex() int CurrentTabIndex returns the index of the currently selected TabItem.\nDeprecated: Use `AppTabs.SelectedIndex() int` instead.\rfunc (*AppTabs) ExtendBaseWidget\r#\r\rfunc (t *AppTabs) ExtendBaseWidget(wid fyne.Widget) ExtendBaseWidget is used by an extending widget to make use of BaseWidget functionality.\nDeprecated: Support for extending containers is being removed\rfunc (*AppTabs) Hide\r#\r\rfunc (t *AppTabs) Hide() Hide hides the widget.\nImplements: \rfyne.CanvasObject\rfunc (*AppTabs) MinSize\r#\r\rfunc (t *AppTabs) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nImplements: \rfyne.CanvasObject\rfunc (*AppTabs) Remove\r#\r\rfunc (t *AppTabs) Remove(item *TabItem) Remove tab by value.\nfunc (*AppTabs) RemoveIndex\r#\r\rfunc (t *AppTabs) RemoveIndex(index int) RemoveIndex removes tab by index.\nfunc (*AppTabs) Select\r#\r\rfunc (t *AppTabs) Select(item *TabItem) Select sets the specified TabItem to be selected and its content visible.\nfunc (*AppTabs) SelectIndex\r#\r\rfunc (t *AppTabs) SelectIndex(index int) SelectIndex sets the TabItem at the specific index to be selected and its content visible.\nfunc (*AppTabs) SelectTab\r#\r\rfunc (t *AppTabs) SelectTab(item *TabItem) SelectTab sets the specified TabItem to be selected and its content visible.\nDeprecated: Use `AppTabs.Select(*TabItem)` instead.\rfunc (*AppTabs) SelectTabIndex\r#\r\rfunc (t *AppTabs) SelectTabIndex(index int) SelectTabIndex sets the TabItem at the specific index to be selected and its content visible.\nDeprecated: Use `AppTabs.SelectIndex(int)` instead.\rfunc (*AppTabs) Selected\r#\r\rfunc (t *AppTabs) Selected() *TabItem Selected returns the currently selected TabItem.\nfunc (*AppTabs) SelectedIndex\r#\r\rfunc (t *AppTabs) SelectedIndex() int SelectedIndex returns the index of the currently selected TabItem.\nfunc (*AppTabs) SetItems\r#\r\rfunc (t *AppTabs) SetItems(items []*TabItem) SetItems sets the container\u0026rsquo;s items and refreshes.\nfunc (*AppTabs) SetTabLocation\r#\r\rfunc (t *AppTabs) SetTabLocation(l TabLocation) SetTabLocation sets the location of the tab bar\nfunc (*AppTabs) Show\r#\r\rfunc (t *AppTabs) Show() Show this widget, if it was previously hidden\nImplements: \rfyne.CanvasObject\r"},{"id":126,"href":"/fyne/docs/api/container/doctabs/","title":"container.DocTabs","section":"container","content":"container.DocTabs\r#\r\r import \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\r\rtype DocTabs\r#\r\rtype DocTabs struct { \twidget.BaseWidget  \tItems []*TabItem  \tCreateTab func() *TabItem \tCloseIntercept func(*TabItem) \tOnClosed func(*TabItem) \tOnSelected func(*TabItem) \tOnUnselected func(*TabItem) } DocTabs container is used to display various pieces of content identified by tabs. The tabs contain text and/or an icon and allow the user to switch between the content specified in each TabItem. Each item is represented by a button at the edge of the container.\nSince: \r2.1\rfunc NewDocTabs\r#\r\rfunc NewDocTabs(items ...*TabItem) *DocTabs NewDocTabs creates a new tab container that allows the user to choose between various pieces of content.\nSince: \r2.1\rfunc (*DocTabs) Append\r#\r\rfunc (t *DocTabs) Append(item *TabItem) Append adds a new TabItem to the end of the tab bar.\nfunc (*DocTabs) CreateRenderer\r#\r\rfunc (t *DocTabs) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nImplements: \rfyne.Widget\rfunc (*DocTabs) Hide\r#\r\rfunc (t *DocTabs) Hide() Hide hides the widget.\nImplements: \rfyne.CanvasObject\rfunc (*DocTabs) MinSize\r#\r\rfunc (t *DocTabs) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nImplements: \rfyne.CanvasObject\rfunc (*DocTabs) Remove\r#\r\rfunc (t *DocTabs) Remove(item *TabItem) Remove tab by value.\nfunc (*DocTabs) RemoveIndex\r#\r\rfunc (t *DocTabs) RemoveIndex(index int) RemoveIndex removes tab by index.\nfunc (*DocTabs) Select\r#\r\rfunc (t *DocTabs) Select(item *TabItem) Select sets the specified TabItem to be selected and its content visible.\nfunc (*DocTabs) SelectIndex\r#\r\rfunc (t *DocTabs) SelectIndex(index int) SelectIndex sets the TabItem at the specific index to be selected and its content visible.\nfunc (*DocTabs) Selected\r#\r\rfunc (t *DocTabs) Selected() *TabItem Selected returns the currently selected TabItem.\nfunc (*DocTabs) SelectedIndex\r#\r\rfunc (t *DocTabs) SelectedIndex() int SelectedIndex returns the index of the currently selected TabItem.\nfunc (*DocTabs) SetItems\r#\r\rfunc (t *DocTabs) SetItems(items []*TabItem) SetItems sets the container\u0026rsquo;s items and refreshes.\nfunc (*DocTabs) SetTabLocation\r#\r\rfunc (t *DocTabs) SetTabLocation(l TabLocation) SetTabLocation sets the location of the tab bar\nfunc (*DocTabs) Show\r#\r\rfunc (t *DocTabs) Show() Show this widget, if it was previously hidden\nImplements: \rfyne.CanvasObject\r"},{"id":127,"href":"/fyne/docs/api/container/scroll/","title":"container.Scroll","section":"container","content":"container.Scroll\r#\r\r import \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\r\rtype Scroll\r#\r\rtype Scroll = widget.Scroll Scroll defines a container that is smaller than the Content. The Offset is used to determine the position of the child widgets within the container.\nSince: \r1.4\rfunc NewHScroll\r#\r\rfunc NewHScroll(content fyne.CanvasObject) *Scroll NewHScroll create a scrollable parent wrapping the specified content. Note that this may cause the MinSize.Width to be smaller than that of the passed object.\nSince: \r1.4\rfunc NewScroll\r#\r\rfunc NewScroll(content fyne.CanvasObject) *Scroll NewScroll creates a scrollable parent wrapping the specified content. Note that this may cause the MinSize to be smaller than that of the passed object.\nSince: \r1.4\rfunc NewVScroll\r#\r\rfunc NewVScroll(content fyne.CanvasObject) *Scroll NewVScroll a scrollable parent wrapping the specified content. Note that this may cause the MinSize.Height to be smaller than that of the passed object.\nSince: \r1.4\r"},{"id":128,"href":"/fyne/docs/api/container/scrolldirection/","title":"container.ScrollDirection","section":"container","content":"container.ScrollDirection\r#\r\r import \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\r\rtype ScrollDirection\r#\r\rtype ScrollDirection = widget.ScrollDirection ScrollDirection represents the directions in which a Scroll container can scroll its child content.\nSince: \r1.4\r"},{"id":129,"href":"/fyne/docs/api/container/split/","title":"container.Split","section":"container","content":"container.Split\r#\r\r import \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\r\rtype Split\r#\r\rtype Split struct { \twidget.BaseWidget \tOffset float64 \tHorizontal bool \tLeading fyne.CanvasObject \tTrailing fyne.CanvasObject } Split defines a container whose size is split between two children.\nSince: \r1.4\rfunc NewHSplit\r#\r\rfunc NewHSplit(leading, trailing fyne.CanvasObject) *Split NewHSplit creates a horizontally arranged container with the specified leading and trailing elements. A vertical split bar that can be dragged will be added between the elements.\nSince: \r1.4\rfunc NewVSplit\r#\r\rfunc NewVSplit(top, bottom fyne.CanvasObject) *Split NewVSplit creates a vertically arranged container with the specified top and bottom elements. A horizontal split bar that can be dragged will be added between the elements.\nSince: \r1.4\rfunc (*Split) CreateRenderer\r#\r\rfunc (s *Split) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Split) ExtendBaseWidget\r#\r\rfunc (s *Split) ExtendBaseWidget(wid fyne.Widget) ExtendBaseWidget is used by an extending widget to make use of BaseWidget functionality.\nDeprecated: Support for extending containers is being removed\rfunc (*Split) SetOffset\r#\r\rfunc (s *Split) SetOffset(offset float64) SetOffset sets the offset (0.0 to 1.0) of the Split divider. 0.0 - Leading is min size, Trailing uses all remaining space. 0.5 - Leading \u0026amp; Trailing equally share the available space. 1.0 - Trailing is min size, Leading uses all remaining space.\n"},{"id":130,"href":"/fyne/docs/api/container/tabitem/","title":"container.TabItem","section":"container","content":"container.TabItem\r#\r\r import \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\r\rtype TabItem\r#\r\rtype TabItem struct { \tText string \tIcon fyne.Resource \tContent fyne.CanvasObject } TabItem represents a single view in a tab view. The Text and Icon are used for the tab button and the Content is shown when the corresponding tab is active.\nSince: \r1.4\rfunc NewTabItem\r#\r\rfunc NewTabItem(text string, content fyne.CanvasObject) *TabItem NewTabItem creates a new item for a tabbed widget - each item specifies the content and a label for its tab.\nSince: \r1.4\rfunc NewTabItemWithIcon\r#\r\rfunc NewTabItemWithIcon(text string, icon fyne.Resource, content fyne.CanvasObject) *TabItem NewTabItemWithIcon creates a new item for a tabbed widget - each item specifies the content and a label with an icon for its tab.\nSince: \r1.4\r"},{"id":131,"href":"/fyne/docs/api/container/tablocation/","title":"container.TabLocation","section":"container","content":"container.TabLocation\r#\r\r import \u0026#34;fyne.io/fyne/v2/container\u0026#34; Usage\r#\r\rtype TabLocation\r#\r\rtype TabLocation int TabLocation is the location where the tabs of a tab container should be rendered\nSince: \r1.4\rconst ( \tTabLocationTop TabLocation = iota \tTabLocationLeading \tTabLocationBottom \tTabLocationTrailing ) TabLocation values\n"},{"id":132,"href":"/fyne/docs/api/data/","title":"data","section":"API Documentation","content":"\r\rbinding\r\rbinding\rbinding\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtypes\r#\rBool BoolList DataItem DataList DataListener DataMap ExternalBool ExternalBoolList ExternalFloat ExternalFloatList ExternalInt ExternalIntList ExternalRune ExternalRuneList ExternalString ExternalStringList ExternalURI ExternalURIList ExternalUntyped ExternalUntypedList ExternalUntypedMap Float FloatList Int IntList Rune RuneList String StringList Struct URI URIList Untyped UntypedList UntypedMap binding.Bool\rbinding.Bool\r#\rimport \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; Usage\r#\rtype Bool\r#\rtype Bool interface { DataItem Get() (bool, error) Set(bool) error } Bool supports binding a bool value.\r\r\rvalidation\r\rvalidation\rvalidation\r#\rimport \u0026#34;fyne.io/fyne/v2/data/validation\u0026#34; Package validation provides validation for data inside widgets Usage\r#\rfunc NewRegexp\r#\rfunc NewRegexp(regexpstr, reason string) fyne.StringValidator NewRegexp creates a new validator that uses regular expression parsing. The validator will return nil if valid, otherwise returns an error with a reason text. Since: 1.4\rfunc NewTime\r#\rfunc NewTime(format string) fyne.StringValidator NewTime creates a new validator that verifies times using time.\r\r\r"},{"id":133,"href":"/fyne/docs/api/driver/desktop/","title":"desktop","section":"driver","content":"\r\rdesktop\r\rdesktop\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Package desktop provides desktop specific driver functionality. Usage\r#\rconst ( // KeyNone represents no key KeyNone fyne.KeyName = \u0026#34;\u0026#34; // KeyShiftLeft represents the left shift key KeyShiftLeft fyne.KeyName = \u0026#34;LeftShift\u0026#34; // KeyShiftRight represents the right shift key KeyShiftRight fyne.KeyName = \u0026#34;RightShift\u0026#34; // KeyControlLeft represents the left control key KeyControlLeft fyne.KeyName = \u0026#34;LeftControl\u0026#34; // KeyControlRight represents the right control key KeyControlRight fyne.\r\r\rdesktop.Canvas\r\rdesktop.Canvas\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype Canvas\r#\rtype Canvas interface { OnKeyDown() func(*fyne.KeyEvent) SetOnKeyDown(func(*fyne.KeyEvent)) OnKeyUp() func(*fyne.KeyEvent) SetOnKeyUp(func(*fyne.KeyEvent)) } Canvas defines the desktop specific extensions to a fyne.Canvas.\r\r\rdesktop.Cursor\r\rdesktop.Cursor\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype Cursor\r#\rtype Cursor interface { // Image returns the image for the given cursor, or nil if none should be shown. // It also returns the x and y pixels that should act as the hot-spot (measured from top left corner). Image() (image.Image, int, int) } Cursor interface is used for objects that desire a specific cursor.\r\r\rdesktop.Cursorable\r\rdesktop.Cursorable\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype Cursorable\r#\rtype Cursorable interface { Cursor() Cursor } Cursorable describes any CanvasObject that needs a cursor change\r\r\rdesktop.CustomShortcut\r\rdesktop.CustomShortcut\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype CustomShortcut\r#\rtype CustomShortcut struct { fyne.KeyName Modifier } CustomShortcut describes a shortcut desktop event. func (*CustomShortcut) ShortcutName\r#\rfunc (cs *CustomShortcut) ShortcutName() string ShortcutName returns the shortcut name associated to the event\r\r\rdesktop.Driver\r\rdesktop.Driver\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype Driver\r#\rtype Driver interface { // Create a new borderless window that is centered on screen CreateSplashWindow() fyne.Window } Driver represents the extended capabilities of a desktop driver\r\r\rdesktop.Hoverable\r\rdesktop.Hoverable\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype Hoverable\r#\rtype Hoverable interface { // MouseIn is a hook that is called if the mouse pointer enters the element. MouseIn(*MouseEvent) // MouseMoved is a hook that is called if the mouse pointer moved over the element. MouseMoved(*MouseEvent) // MouseOut is a hook that is called if the mouse pointer leaves the element. MouseOut() } Hoverable is used when a canvas object wishes to know if a pointer device moves over it.\r\r\rdesktop.Keyable\r\rdesktop.Keyable\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype Keyable\r#\rtype Keyable interface { fyne.Focusable KeyDown(*fyne.KeyEvent) KeyUp(*fyne.KeyEvent) } Keyable describes any focusable canvas object that can accept desktop key events. This is the traditional key down and up event that is not applicable to all devices.\r\r\rdesktop.Modifier\r\rdesktop.Modifier\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype Modifier\r#\rtype Modifier int Modifier captures any key modifiers (shift etc) pressed during this key event const ( // ShiftModifier represents a shift key being held ShiftModifier Modifier = 1 \u0026lt;\u0026lt; iota // ControlModifier represents the ctrl key being held ControlModifier // AltModifier represents either alt keys being held AltModifier // SuperModifier represents either super keys being held SuperModifier ) \r\rdesktop.Mouseable\r\rdesktop.Mouseable\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype Mouseable\r#\rtype Mouseable interface { MouseDown(*MouseEvent) MouseUp(*MouseEvent) } Mouseable represents desktop mouse events that can be sent to CanvasObjects\r\r\rdesktop.MouseButton\r\rdesktop.MouseButton\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype MouseButton\r#\rtype MouseButton int MouseButton represents a single button in a desktop MouseEvent const ( // MouseButtonPrimary is the most common mouse button - on some systems the only one. // This will normally be on the left side of a mouse. // // Since: 2.0 MouseButtonPrimary MouseButton = 1 \u0026lt;\u0026lt; iota // MouseButtonSecondary is the secondary button on most mouse input devices.\r\r\rdesktop.MouseEvent\r\rdesktop.MouseEvent\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype MouseEvent\r#\rtype MouseEvent struct { fyne.PointEvent Button MouseButton Modifier Modifier } MouseEvent contains data relating to desktop mouse events\r\r\rdesktop.StandardCursor\r\rdesktop.StandardCursor\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\rtype StandardCursor\r#\rtype StandardCursor int StandardCursor represents a standard Fyne cursor. These values were previously of type fyne.Cursor. Since: 2.0\rconst ( // DefaultCursor is the default cursor typically an arrow DefaultCursor StandardCursor = iota // TextCursor is the cursor often used to indicate text selection TextCursor // CrosshairCursor is the cursor often used to indicate bitmaps CrosshairCursor // PointerCursor is the cursor often used to indicate a link PointerCursor // HResizeCursor is the cursor often used to indicate horizontal resize HResizeCursor // VResizeCursor is the cursor often used to indicate vertical resize VResizeCursor // HiddenCursor will cause the cursor to not be shown HiddenCursor ) func (StandardCursor) Image\r#\rfunc (d StandardCursor) Image() (image.\r\r\r"},{"id":134,"href":"/fyne/docs/api/driver/desktop/","title":"desktop","section":"desktop","content":"desktop\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Package desktop provides desktop specific driver functionality.\nUsage\r#\r\rconst ( \t// KeyNone represents no key \tKeyNone fyne.KeyName = \u0026#34;\u0026#34; \t// KeyShiftLeft represents the left shift key \tKeyShiftLeft fyne.KeyName = \u0026#34;LeftShift\u0026#34; \t// KeyShiftRight represents the right shift key \tKeyShiftRight fyne.KeyName = \u0026#34;RightShift\u0026#34; \t// KeyControlLeft represents the left control key \tKeyControlLeft fyne.KeyName = \u0026#34;LeftControl\u0026#34; \t// KeyControlRight represents the right control key \tKeyControlRight fyne.KeyName = \u0026#34;RightControl\u0026#34; \t// KeyAltLeft represents the left alt key \tKeyAltLeft fyne.KeyName = \u0026#34;LeftAlt\u0026#34; \t// KeyAltRight represents the right alt key \tKeyAltRight fyne.KeyName = \u0026#34;RightAlt\u0026#34; \t// KeySuperLeft represents the left \u0026#34;Windows\u0026#34; key (or \u0026#34;Command\u0026#34; key on macOS) \tKeySuperLeft fyne.KeyName = \u0026#34;LeftSuper\u0026#34; \t// KeySuperRight represents the right \u0026#34;Windows\u0026#34; key (or \u0026#34;Command\u0026#34; key on macOS) \tKeySuperRight fyne.KeyName = \u0026#34;RightSuper\u0026#34; \t// KeyMenu represents the left or right menu / application key \tKeyMenu fyne.KeyName = \u0026#34;Menu\u0026#34; \t// KeyPrintScreen represents the key used to cause a screen capture \tKeyPrintScreen fyne.KeyName = \u0026#34;PrintScreen\u0026#34;  \t// KeyCapsLock represents the caps lock key, tapping once is the down event then again is the up \tKeyCapsLock fyne.KeyName = \u0026#34;CapsLock\u0026#34; ) types\r#\r\r \rCanvas \rCursor \rCursorable \rCustomShortcut \rDriver \rHoverable \rKeyable \rModifier \rMouseButton \rMouseEvent \rMouseable \rStandardCursor  "},{"id":135,"href":"/fyne/docs/api/driver/desktop/canvas/","title":"desktop.Canvas","section":"desktop","content":"desktop.Canvas\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype Canvas\r#\r\rtype Canvas interface { \tOnKeyDown() func(*fyne.KeyEvent) \tSetOnKeyDown(func(*fyne.KeyEvent)) \tOnKeyUp() func(*fyne.KeyEvent) \tSetOnKeyUp(func(*fyne.KeyEvent)) } Canvas defines the desktop specific extensions to a fyne.Canvas.\n"},{"id":136,"href":"/fyne/docs/api/driver/desktop/cursor/","title":"desktop.Cursor","section":"desktop","content":"desktop.Cursor\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype Cursor\r#\r\rtype Cursor interface { \t// Image returns the image for the given cursor, or nil if none should be shown. \t// It also returns the x and y pixels that should act as the hot-spot (measured from top left corner). \tImage() (image.Image, int, int) } Cursor interface is used for objects that desire a specific cursor.\nSince: \r2.0\r"},{"id":137,"href":"/fyne/docs/api/driver/desktop/cursorable/","title":"desktop.Cursorable","section":"desktop","content":"desktop.Cursorable\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype Cursorable\r#\r\rtype Cursorable interface { \tCursor() Cursor } Cursorable describes any CanvasObject that needs a cursor change\n"},{"id":138,"href":"/fyne/docs/api/driver/desktop/customshortcut/","title":"desktop.CustomShortcut","section":"desktop","content":"desktop.CustomShortcut\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype CustomShortcut\r#\r\rtype CustomShortcut struct { \tfyne.KeyName \tModifier } CustomShortcut describes a shortcut desktop event.\nfunc (*CustomShortcut) ShortcutName\r#\r\rfunc (cs *CustomShortcut) ShortcutName() string ShortcutName returns the shortcut name associated to the event\n"},{"id":139,"href":"/fyne/docs/api/driver/desktop/driver/","title":"desktop.Driver","section":"desktop","content":"desktop.Driver\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype Driver\r#\r\rtype Driver interface { \t// Create a new borderless window that is centered on screen \tCreateSplashWindow() fyne.Window } Driver represents the extended capabilities of a desktop driver\n"},{"id":140,"href":"/fyne/docs/api/driver/desktop/hoverable/","title":"desktop.Hoverable","section":"desktop","content":"desktop.Hoverable\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype Hoverable\r#\r\rtype Hoverable interface { \t// MouseIn is a hook that is called if the mouse pointer enters the element. \tMouseIn(*MouseEvent) \t// MouseMoved is a hook that is called if the mouse pointer moved over the element. \tMouseMoved(*MouseEvent) \t// MouseOut is a hook that is called if the mouse pointer leaves the element. \tMouseOut() } Hoverable is used when a canvas object wishes to know if a pointer device moves over it.\n"},{"id":141,"href":"/fyne/docs/api/driver/desktop/keyable/","title":"desktop.Keyable","section":"desktop","content":"desktop.Keyable\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype Keyable\r#\r\rtype Keyable interface { \tfyne.Focusable  \tKeyDown(*fyne.KeyEvent) \tKeyUp(*fyne.KeyEvent) } Keyable describes any focusable canvas object that can accept desktop key events. This is the traditional key down and up event that is not applicable to all devices.\n"},{"id":142,"href":"/fyne/docs/api/driver/desktop/modifier/","title":"desktop.Modifier","section":"desktop","content":"desktop.Modifier\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype Modifier\r#\r\rtype Modifier int Modifier captures any key modifiers (shift etc) pressed during this key event\nconst ( \t// ShiftModifier represents a shift key being held \tShiftModifier Modifier = 1 \u0026lt;\u0026lt; iota \t// ControlModifier represents the ctrl key being held \tControlModifier \t// AltModifier represents either alt keys being held \tAltModifier \t// SuperModifier represents either super keys being held \tSuperModifier ) "},{"id":143,"href":"/fyne/docs/api/driver/desktop/mouseable/","title":"desktop.Mouseable","section":"desktop","content":"desktop.Mouseable\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype Mouseable\r#\r\rtype Mouseable interface { \tMouseDown(*MouseEvent) \tMouseUp(*MouseEvent) } Mouseable represents desktop mouse events that can be sent to CanvasObjects\n"},{"id":144,"href":"/fyne/docs/api/driver/desktop/mousebutton/","title":"desktop.MouseButton","section":"desktop","content":"desktop.MouseButton\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype MouseButton\r#\r\rtype MouseButton int MouseButton represents a single button in a desktop MouseEvent\nconst ( \t// MouseButtonPrimary is the most common mouse button - on some systems the only one. \t// This will normally be on the left side of a mouse. \t// \t// Since: 2.0 \tMouseButtonPrimary MouseButton = 1 \u0026lt;\u0026lt; iota  \t// MouseButtonSecondary is the secondary button on most mouse input devices. \t// This will normally be on the right side of a mouse. \t// \t// Since: 2.0 \tMouseButtonSecondary  \t// MouseButtonTertiary is the middle button on the mouse, assuming it has one. \t// \t// Since: 2.0 \tMouseButtonTertiary  \t// LeftMouseButton is the most common mouse button - on some systems the only one. \t// \t// Deprecated: use MouseButtonPrimary which will adapt to mouse configuration. \tLeftMouseButton = MouseButtonPrimary  \t// RightMouseButton is the secondary button on most mouse input devices. \t// \t// Deprecated: use MouseButtonSecondary which will adapt to mouse configuration. \tRightMouseButton = MouseButtonSecondary ) "},{"id":145,"href":"/fyne/docs/api/driver/desktop/mouseevent/","title":"desktop.MouseEvent","section":"desktop","content":"desktop.MouseEvent\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype MouseEvent\r#\r\rtype MouseEvent struct { \tfyne.PointEvent \tButton MouseButton \tModifier Modifier } MouseEvent contains data relating to desktop mouse events\n"},{"id":146,"href":"/fyne/docs/api/driver/desktop/standardcursor/","title":"desktop.StandardCursor","section":"desktop","content":"desktop.StandardCursor\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Usage\r#\r\rtype StandardCursor\r#\r\rtype StandardCursor int StandardCursor represents a standard Fyne cursor. These values were previously of type fyne.Cursor.\nSince: \r2.0\rconst ( \t// DefaultCursor is the default cursor typically an arrow \tDefaultCursor StandardCursor = iota \t// TextCursor is the cursor often used to indicate text selection \tTextCursor \t// CrosshairCursor is the cursor often used to indicate bitmaps \tCrosshairCursor \t// PointerCursor is the cursor often used to indicate a link \tPointerCursor \t// HResizeCursor is the cursor often used to indicate horizontal resize \tHResizeCursor \t// VResizeCursor is the cursor often used to indicate vertical resize \tVResizeCursor \t// HiddenCursor will cause the cursor to not be shown \tHiddenCursor ) func (StandardCursor) Image\r#\r\rfunc (d StandardCursor) Image() (image.Image, int, int) Image is not used for any of the StandardCursor types.\nSince: \r2.0\r"},{"id":147,"href":"/fyne/docs/api/dialog/","title":"dialog","section":"API Documentation","content":"\r\rdialog\r\rdialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Package dialog defines standard dialog windows for application GUIs. Usage\r#\rfunc ShowColorPicker\r#\rfunc ShowColorPicker(title, message string, callback func(c color.Color), parent fyne.Window) ShowColorPicker creates and shows a color dialog. The callback is triggered when the user selects a color. Since: 1.4\rfunc ShowConfirm\r#\rfunc ShowConfirm(title, message string, callback func(bool), parent fyne.Window) ShowConfirm shows a dialog over the specified window for a user confirmation.\r\r\rdialog.ColorPickerDialog\r\rdialog.ColorPickerDialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\rtype ColorPickerDialog\r#\rtype ColorPickerDialog struct { Advanced bool } ColorPickerDialog is a simple dialog window that displays a color picker. Since: 1.4\rfunc NewColorPicker\r#\rfunc NewColorPicker(title, message string, callback func(c color.Color), parent fyne.Window) *ColorPickerDialog NewColorPicker creates a color dialog and returns the handle. Using the returned type you should call Show() and then set its color through SetColor().\r\r\rdialog.ConfirmDialog\r\rdialog.ConfirmDialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\rtype ConfirmDialog\r#\rtype ConfirmDialog struct { } ConfirmDialog is like the standard Dialog but with an additional confirmation button func NewConfirm\r#\rfunc NewConfirm(title, message string, callback func(bool), parent fyne.Window) *ConfirmDialog NewConfirm creates a dialog over the specified window for user confirmation. The title is used for the dialog window and message is the content. The callback is executed when the user decides.\r\r\rdialog.Dialog\r\rdialog.Dialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\rtype Dialog\r#\rtype Dialog interface { Show() Hide() SetDismissText(label string) SetOnClosed(closed func()) Refresh() Resize(size fyne.Size) // Since: 2.1 MinSize() fyne.Size } Dialog is the common API for any dialog window with a single dismiss button func NewCustom\r#\rfunc NewCustom(title, dismiss string, content fyne.CanvasObject, parent fyne.Window) Dialog NewCustom creates and returns a dialog over the specified application using custom content.\r\r\rdialog.EntryDialog\r\rdialog.EntryDialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\rtype EntryDialog\r#\rtype EntryDialog struct { } EntryDialog is a variation of a dialog which prompts the user to enter some text. Deprecated: Use dialog.NewFormDialog() or dialog.ShowFormDialog() with a widget.Entry inside instead.\rfunc NewEntryDialog\r#\rfunc NewEntryDialog(title, message string, onConfirm func(string), parent fyne.Window) *EntryDialog NewEntryDialog creates a dialog over the specified window for the user to enter a value.\r\r\rdialog.FileDialog\r\rdialog.FileDialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\rtype FileDialog\r#\rtype FileDialog struct { } FileDialog is a dialog containing a file picker for use in opening or saving files. func NewFileOpen\r#\rfunc NewFileOpen(callback func(fyne.URIReadCloser, error), parent fyne.Window) *FileDialog NewFileOpen creates a file dialog allowing the user to choose a file to open. The callback function will run when the dialog closes. The URI will be nil when the user cancels or when nothing is selected.\r\r\rdialog.ProgressDialog\r\rdialog.ProgressDialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\rtype ProgressDialog\r#\rtype ProgressDialog struct { } ProgressDialog is a simple dialog window that displays text and a progress bar. Deprecated: Create a new custom dialog with a widget.ProgressBar() inside.\rfunc NewProgress\r#\rfunc NewProgress(title, message string, parent fyne.Window) *ProgressDialog NewProgress creates a progress dialog and returns the handle. Using the returned type you should call Show() and then set its value through SetValue().\r\r\rdialog.ProgressInfiniteDialog\r\rdialog.ProgressInfiniteDialog\r#\rimport \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\rtype ProgressInfiniteDialog\r#\rtype ProgressInfiniteDialog struct { } ProgressInfiniteDialog is a simple dialog window that displays text and a infinite progress bar. Deprecated: Create a new custom dialog with a widget.ProgressBarInfinite() inside.\rfunc NewProgressInfinite\r#\rfunc NewProgressInfinite(title, message string, parent fyne.Window) *ProgressInfiniteDialog NewProgressInfinite creates a infinite progress dialog and returns the handle. Using the returned type you should call Show().\r\r\r"},{"id":148,"href":"/fyne/docs/api/dialog/","title":"dialog","section":"dialog","content":"dialog\r#\r\r import \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Package dialog defines standard dialog windows for application GUIs.\nUsage\r#\r\rfunc ShowColorPicker\r#\r\rfunc ShowColorPicker(title, message string, callback func(c color.Color), parent fyne.Window) ShowColorPicker creates and shows a color dialog. The callback is triggered when the user selects a color.\nSince: \r1.4\rfunc ShowConfirm\r#\r\rfunc ShowConfirm(title, message string, callback func(bool), parent fyne.Window) ShowConfirm shows a dialog over the specified window for a user confirmation. The title is used for the dialog window and message is the content. The callback is executed when the user decides.\nfunc ShowCustom\r#\r\rfunc ShowCustom(title, dismiss string, content fyne.CanvasObject, parent fyne.Window) ShowCustom shows a dialog over the specified application using custom content. The button will have the dismiss text set. The MinSize() of the CanvasObject passed will be used to set the size of the window.\nfunc ShowCustomConfirm\r#\r\rfunc ShowCustomConfirm(title, confirm, dismiss string, content fyne.CanvasObject, \tcallback func(bool), parent fyne.Window) ShowCustomConfirm shows a dialog over the specified application using custom content. The cancel button will have the dismiss text set and the \u0026ldquo;OK\u0026rdquo; will use the confirm text. The response callback is called on user action. The MinSize() of the CanvasObject passed will be used to set the size of the window.\nfunc ShowEntryDialog\r#\r\rfunc ShowEntryDialog(title, message string, onConfirm func(string), parent fyne.Window) ShowEntryDialog creates a new entry dialog and shows it immediately.\nDeprecated: Use dialog.ShowFormDialog() with a widget.Entry inside instead.\rfunc ShowError\r#\r\rfunc ShowError(err error, parent fyne.Window) ShowError shows a dialog over the specified window for an application error. The message is extracted from the provided error (should not be nil).\nfunc ShowFileOpen\r#\r\rfunc ShowFileOpen(callback func(fyne.URIReadCloser, error), parent fyne.Window) ShowFileOpen creates and shows a file dialog allowing the user to choose a file to open. The callback function will run when the dialog closes. The URI will be nil when the user cancels or when nothing is selected.\nThe dialog will appear over the window specified.\nfunc ShowFileSave\r#\r\rfunc ShowFileSave(callback func(fyne.URIWriteCloser, error), parent fyne.Window) ShowFileSave creates and shows a file dialog allowing the user to choose a file to save to (new or overwrite). If the user chooses an existing file they will be asked if they are sure. The callback function will run when the dialog closes. The URI will be nil when the user cancels or when nothing is selected.\nThe dialog will appear over the window specified.\nfunc ShowFolderOpen\r#\r\rfunc ShowFolderOpen(callback func(fyne.ListableURI, error), parent fyne.Window) ShowFolderOpen creates and shows a file dialog allowing the user to choose a folder to open. The callback function will run when the dialog closes. The URI will be nil when the user cancels or when nothing is selected.\nThe dialog will appear over the window specified.\nSince: \r1.4\rfunc ShowForm\r#\r\rfunc ShowForm(title, confirm, dismiss string, content []*widget.FormItem, callback func(bool), parent fyne.Window) ShowForm shows a dialog over the specified application using the provided FormItems. The cancel button will have the dismiss text set and the confirm button will use the confirm text. The response callback is called on user action after validation passes. If any Validatable widget reports that validation has failed, then the confirm button will be disabled. The initial state of the confirm button will reflect the initial validation state of the items added to the form dialog. The MinSize() of the CanvasObject passed will be used to set the size of the window.\nSince: \r2.0\rfunc ShowInformation\r#\r\rfunc ShowInformation(title, message string, parent fyne.Window) ShowInformation shows a dialog over the specified window for user information. The title is used for the dialog window and message is the content.\ntypes\r#\r\r \rColorPickerDialog \rConfirmDialog \rDialog \rEntryDialog \rFileDialog \rProgressDialog \rProgressInfiniteDialog  "},{"id":149,"href":"/fyne/docs/api/dialog/colorpickerdialog/","title":"dialog.ColorPickerDialog","section":"dialog","content":"dialog.ColorPickerDialog\r#\r\r import \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\r\rtype ColorPickerDialog\r#\r\rtype ColorPickerDialog struct { \tAdvanced bool } ColorPickerDialog is a simple dialog window that displays a color picker.\nSince: \r1.4\rfunc NewColorPicker\r#\r\rfunc NewColorPicker(title, message string, callback func(c color.Color), parent fyne.Window) *ColorPickerDialog NewColorPicker creates a color dialog and returns the handle. Using the returned type you should call Show() and then set its color through SetColor(). The callback is triggered when the user selects a color.\nSince: \r1.4\rfunc (ColorPickerDialog) Hide\r#\r\rfunc (d ColorPickerDialog) Hide() func (ColorPickerDialog) MinSize\r#\r\rfunc (d ColorPickerDialog) MinSize() fyne.Size MinSize returns the size that this dialog should not shrink below\nSince: \r2.1\rfunc (*ColorPickerDialog) Refresh\r#\r\rfunc (p *ColorPickerDialog) Refresh() Refresh causes this dialog to be updated\nfunc (ColorPickerDialog) Resize\r#\r\rfunc (d ColorPickerDialog) Resize(size fyne.Size) Resize dialog, call this function after dialog show\nfunc (*ColorPickerDialog) SetColor\r#\r\rfunc (p *ColorPickerDialog) SetColor(c color.Color) SetColor updates the color of the color picker.\nfunc (ColorPickerDialog) SetDismissText\r#\r\rfunc (d ColorPickerDialog) SetDismissText(label string) SetDismissText allows custom text to be set in the confirmation button\nfunc (ColorPickerDialog) SetOnClosed\r#\r\rfunc (d ColorPickerDialog) SetOnClosed(closed func()) SetOnClosed allows to set a callback function that is called when the dialog is closed\nfunc (*ColorPickerDialog) Show\r#\r\rfunc (p *ColorPickerDialog) Show() Show causes this dialog to be displayed\n"},{"id":150,"href":"/fyne/docs/api/dialog/confirmdialog/","title":"dialog.ConfirmDialog","section":"dialog","content":"dialog.ConfirmDialog\r#\r\r import \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\r\rtype ConfirmDialog\r#\r\rtype ConfirmDialog struct { } ConfirmDialog is like the standard Dialog but with an additional confirmation button\nfunc NewConfirm\r#\r\rfunc NewConfirm(title, message string, callback func(bool), parent fyne.Window) *ConfirmDialog NewConfirm creates a dialog over the specified window for user confirmation. The title is used for the dialog window and message is the content. The callback is executed when the user decides. After creation you should call Show().\nfunc (ConfirmDialog) Hide\r#\r\rfunc (d ConfirmDialog) Hide() func (ConfirmDialog) MinSize\r#\r\rfunc (d ConfirmDialog) MinSize() fyne.Size MinSize returns the size that this dialog should not shrink below\nSince: \r2.1\rfunc (ConfirmDialog) Refresh\r#\r\rfunc (d ConfirmDialog) Refresh() func (ConfirmDialog) Resize\r#\r\rfunc (d ConfirmDialog) Resize(size fyne.Size) Resize dialog, call this function after dialog show\nfunc (*ConfirmDialog) SetConfirmText\r#\r\rfunc (d *ConfirmDialog) SetConfirmText(label string) SetConfirmText allows custom text to be set in the confirmation button\nfunc (ConfirmDialog) SetDismissText\r#\r\rfunc (d ConfirmDialog) SetDismissText(label string) SetDismissText allows custom text to be set in the confirmation button\nfunc (ConfirmDialog) SetOnClosed\r#\r\rfunc (d ConfirmDialog) SetOnClosed(closed func()) SetOnClosed allows to set a callback function that is called when the dialog is closed\nfunc (ConfirmDialog) Show\r#\r\rfunc (d ConfirmDialog) Show() "},{"id":151,"href":"/fyne/docs/api/dialog/dialog/","title":"dialog.Dialog","section":"dialog","content":"dialog.Dialog\r#\r\r import \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\r\rtype Dialog\r#\r\rtype Dialog interface { \tShow() \tHide() \tSetDismissText(label string) \tSetOnClosed(closed func()) \tRefresh() \tResize(size fyne.Size)  \t// Since: 2.1 \tMinSize() fyne.Size } Dialog is the common API for any dialog window with a single dismiss button\nfunc NewCustom\r#\r\rfunc NewCustom(title, dismiss string, content fyne.CanvasObject, parent fyne.Window) Dialog NewCustom creates and returns a dialog over the specified application using custom content. The button will have the dismiss text set. The MinSize() of the CanvasObject passed will be used to set the size of the window.\nfunc NewCustomConfirm\r#\r\rfunc NewCustomConfirm(title, confirm, dismiss string, content fyne.CanvasObject, \tcallback func(bool), parent fyne.Window) Dialog NewCustomConfirm creates and returns a dialog over the specified application using custom content. The cancel button will have the dismiss text set and the \u0026ldquo;OK\u0026rdquo; will use the confirm text. The response callback is called on user action. The MinSize() of the CanvasObject passed will be used to set the size of the window.\nfunc NewError\r#\r\rfunc NewError(err error, parent fyne.Window) Dialog NewError creates a dialog over the specified window for an application error. The message is extracted from the provided error (should not be nil). After creation you should call Show().\nfunc NewForm\r#\r\rfunc NewForm(title, confirm, dismiss string, items []*widget.FormItem, callback func(bool), parent fyne.Window) Dialog NewForm creates and returns a dialog over the specified application using the provided FormItems. The cancel button will have the dismiss text set and the confirm button will use the confirm text. The response callback is called on user action after validation passes. If any Validatable widget reports that validation has failed, then the confirm button will be disabled. The initial state of the confirm button will reflect the initial validation state of the items added to the form dialog.\nSince: \r2.0\rfunc NewInformation\r#\r\rfunc NewInformation(title, message string, parent fyne.Window) Dialog NewInformation creates a dialog over the specified window for user information. The title is used for the dialog window and message is the content. After creation you should call Show().\n"},{"id":152,"href":"/fyne/docs/api/dialog/entrydialog/","title":"dialog.EntryDialog","section":"dialog","content":"dialog.EntryDialog\r#\r\r import \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\r\rtype EntryDialog\r#\r\rtype EntryDialog struct { } EntryDialog is a variation of a dialog which prompts the user to enter some text.\nDeprecated: Use dialog.NewFormDialog() or dialog.ShowFormDialog() with a widget.Entry inside instead.\rfunc NewEntryDialog\r#\r\rfunc NewEntryDialog(title, message string, onConfirm func(string), parent fyne.Window) *EntryDialog NewEntryDialog creates a dialog over the specified window for the user to enter a value.\nonConfirm is a callback that runs when the user enters a string of text and clicks the \u0026ldquo;confirm\u0026rdquo; button. May be nil.\nDeprecated: Use dialog.NewFormDialog() with a widget.Entry inside instead.\rfunc (*EntryDialog) SetOnClosed\r#\r\rfunc (i *EntryDialog) SetOnClosed(callback func()) SetOnClosed changes the callback which is run when the dialog is closed, which is nil by default.\nThe callback is called unconditionally whether the user confirms or cancels.\nNote that the callback will be called after onConfirm, if both are non-nil. This way onConfirm can potential modify state that this callback needs to get the user input when the user confirms, while also being able to handle the case where the user cancelled.\nfunc (*EntryDialog) SetPlaceholder\r#\r\rfunc (i *EntryDialog) SetPlaceholder(s string) SetPlaceholder defines the placeholder text for the entry\nfunc (*EntryDialog) SetText\r#\r\rfunc (i *EntryDialog) SetText(s string) SetText changes the current text value of the entry dialog, this can be useful for setting a default value.\n"},{"id":153,"href":"/fyne/docs/api/dialog/filedialog/","title":"dialog.FileDialog","section":"dialog","content":"dialog.FileDialog\r#\r\r import \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\r\rtype FileDialog\r#\r\rtype FileDialog struct { } FileDialog is a dialog containing a file picker for use in opening or saving files.\nfunc NewFileOpen\r#\r\rfunc NewFileOpen(callback func(fyne.URIReadCloser, error), parent fyne.Window) *FileDialog NewFileOpen creates a file dialog allowing the user to choose a file to open. The callback function will run when the dialog closes. The URI will be nil when the user cancels or when nothing is selected.\nThe dialog will appear over the window specified when Show() is called.\nfunc NewFileSave\r#\r\rfunc NewFileSave(callback func(fyne.URIWriteCloser, error), parent fyne.Window) *FileDialog NewFileSave creates a file dialog allowing the user to choose a file to save to (new or overwrite). If the user chooses an existing file they will be asked if they are sure. The callback function will run when the dialog closes. The URI will be nil when the user cancels or when nothing is selected.\nThe dialog will appear over the window specified when Show() is called.\nfunc NewFolderOpen\r#\r\rfunc NewFolderOpen(callback func(fyne.ListableURI, error), parent fyne.Window) *FileDialog NewFolderOpen creates a file dialog allowing the user to choose a folder to open. The callback function will run when the dialog closes. The URI will be nil when the user cancels or when nothing is selected.\nThe dialog will appear over the window specified when Show() is called.\nSince: \r1.4\rfunc (*FileDialog) Hide\r#\r\rfunc (f *FileDialog) Hide() Hide hides the file dialog.\nfunc (*FileDialog) MinSize\r#\r\rfunc (f *FileDialog) MinSize() fyne.Size MinSize returns the size that this dialog should not shrink below\nSince: \r2.1\rfunc (*FileDialog) Refresh\r#\r\rfunc (f *FileDialog) Refresh() Refresh causes this dialog to be updated\nfunc (*FileDialog) Resize\r#\r\rfunc (f *FileDialog) Resize(size fyne.Size) Resize dialog to the requested size, if there is sufficient space. If the parent window is not large enough then the size will be reduced to fit.\nfunc (*FileDialog) SetDismissText\r#\r\rfunc (f *FileDialog) SetDismissText(label string) SetDismissText allows custom text to be set in the confirmation button\nfunc (*FileDialog) SetFileName\r#\r\rfunc (f *FileDialog) SetFileName(fileName string) SetFileName sets the filename in a FileDialog in save mode. This is normally called before the dialog is shown.\nfunc (*FileDialog) SetFilter\r#\r\rfunc (f *FileDialog) SetFilter(filter storage.FileFilter) SetFilter sets a filter for limiting files that can be chosen in the file dialog.\nfunc (*FileDialog) SetLocation\r#\r\rfunc (f *FileDialog) SetLocation(u fyne.ListableURI) SetLocation tells this FileDirectory which location to display. This is normally called before the dialog is shown.\nSince: \r1.4\rfunc (*FileDialog) SetOnClosed\r#\r\rfunc (f *FileDialog) SetOnClosed(closed func()) SetOnClosed sets a callback function that is called when the dialog is closed.\nfunc (*FileDialog) Show\r#\r\rfunc (f *FileDialog) Show() Show shows the file dialog.\n"},{"id":154,"href":"/fyne/docs/api/dialog/progressdialog/","title":"dialog.ProgressDialog","section":"dialog","content":"dialog.ProgressDialog\r#\r\r import \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\r\rtype ProgressDialog\r#\r\rtype ProgressDialog struct { } ProgressDialog is a simple dialog window that displays text and a progress bar.\nDeprecated: Create a new custom dialog with a widget.ProgressBar() inside.\rfunc NewProgress\r#\r\rfunc NewProgress(title, message string, parent fyne.Window) *ProgressDialog NewProgress creates a progress dialog and returns the handle. Using the returned type you should call Show() and then set its value through SetValue().\nDeprecated: Create a new custom dialog with a widget.ProgressBar() inside.\rfunc (ProgressDialog) Hide\r#\r\rfunc (d ProgressDialog) Hide() func (ProgressDialog) MinSize\r#\r\rfunc (d ProgressDialog) MinSize() fyne.Size MinSize returns the size that this dialog should not shrink below\nSince: \r2.1\rfunc (ProgressDialog) Refresh\r#\r\rfunc (d ProgressDialog) Refresh() func (ProgressDialog) Resize\r#\r\rfunc (d ProgressDialog) Resize(size fyne.Size) Resize dialog, call this function after dialog show\nfunc (ProgressDialog) SetDismissText\r#\r\rfunc (d ProgressDialog) SetDismissText(label string) SetDismissText allows custom text to be set in the confirmation button\nfunc (ProgressDialog) SetOnClosed\r#\r\rfunc (d ProgressDialog) SetOnClosed(closed func()) SetOnClosed allows to set a callback function that is called when the dialog is closed\nfunc (*ProgressDialog) SetValue\r#\r\rfunc (p *ProgressDialog) SetValue(v float64) SetValue updates the value of the progress bar - this should be between 0.0 and 1.0.\nfunc (ProgressDialog) Show\r#\r\rfunc (d ProgressDialog) Show() "},{"id":155,"href":"/fyne/docs/api/dialog/progressinfinitedialog/","title":"dialog.ProgressInfiniteDialog","section":"dialog","content":"dialog.ProgressInfiniteDialog\r#\r\r import \u0026#34;fyne.io/fyne/v2/dialog\u0026#34; Usage\r#\r\rtype ProgressInfiniteDialog\r#\r\rtype ProgressInfiniteDialog struct { } ProgressInfiniteDialog is a simple dialog window that displays text and a infinite progress bar.\nDeprecated: Create a new custom dialog with a widget.ProgressBarInfinite() inside.\rfunc NewProgressInfinite\r#\r\rfunc NewProgressInfinite(title, message string, parent fyne.Window) *ProgressInfiniteDialog NewProgressInfinite creates a infinite progress dialog and returns the handle. Using the returned type you should call Show().\nDeprecated: Create a new custom dialog with a widget.ProgressBarInfinite() inside.\rfunc (*ProgressInfiniteDialog) Hide\r#\r\rfunc (d *ProgressInfiniteDialog) Hide() Hide this dialog and stop the infinite progress goroutine\nfunc (ProgressInfiniteDialog) MinSize\r#\r\rfunc (d ProgressInfiniteDialog) MinSize() fyne.Size MinSize returns the size that this dialog should not shrink below\nSince: \r2.1\rfunc (ProgressInfiniteDialog) Refresh\r#\r\rfunc (d ProgressInfiniteDialog) Refresh() func (ProgressInfiniteDialog) Resize\r#\r\rfunc (d ProgressInfiniteDialog) Resize(size fyne.Size) Resize dialog, call this function after dialog show\nfunc (ProgressInfiniteDialog) SetDismissText\r#\r\rfunc (d ProgressInfiniteDialog) SetDismissText(label string) SetDismissText allows custom text to be set in the confirmation button\nfunc (ProgressInfiniteDialog) SetOnClosed\r#\r\rfunc (d ProgressInfiniteDialog) SetOnClosed(closed func()) SetOnClosed allows to set a callback function that is called when the dialog is closed\nfunc (ProgressInfiniteDialog) Show\r#\r\rfunc (d ProgressInfiniteDialog) Show() "},{"id":156,"href":"/fyne/docs/api/driver/","title":"driver","section":"API Documentation","content":"\r\rdesktop\r\rdesktop\rdesktop\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; Package desktop provides desktop specific driver functionality. Usage\r#\rconst ( // KeyNone represents no key KeyNone fyne.KeyName = \u0026#34;\u0026#34; // KeyShiftLeft represents the left shift key KeyShiftLeft fyne.KeyName = \u0026#34;LeftShift\u0026#34; // KeyShiftRight represents the right shift key KeyShiftRight fyne.KeyName = \u0026#34;RightShift\u0026#34; // KeyControlLeft represents the left control key KeyControlLeft fyne.KeyName = \u0026#34;LeftControl\u0026#34; // KeyControlRight represents the right control key KeyControlRight fyne.\rdesktop.\r\r\rmobile\r\rmobile\rmobile\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Package mobile provides mobile specific driver functionality. Usage\r#\rtypes\r#\rDevice KeyboardType Keyboardable TouchEvent Touchable mobile.Device\rmobile.Device\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\rtype Device\r#\rtype Device interface { // Request that the mobile device show the touch screen keyboard (standard layout) ShowVirtualKeyboard() // Request that the mobile device show the touch screen keyboard (custom layout) ShowVirtualKeyboardType(KeyboardType) // Request that the mobile device dismiss the touch screen keyboard HideVirtualKeyboard() } Device describes functionality only available on mobile\rmobile.\r\r\rsoftware\r\rsoftware\rsoftware\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/software\u0026#34; Usage\r#\rfunc NewCanvas\r#\rfunc NewCanvas() test.WindowlessCanvas NewCanvas creates a new canvas in memory that can render without hardware support func Render\r#\rfunc Render(obj fyne.CanvasObject, t fyne.Theme) image.Image Render takes a canvas object and renders it to a regular Go image using the provided Theme. The returned image will be set to the object\u0026rsquo;s minimum size. Use the theme.LightTheme() or theme.\r\r\r"},{"id":157,"href":"/fyne/docs/extend/extending-widgets/","title":"Extending Widgets","section":"Extending Fyne","content":"The standard Fyne widgets provide the minimum functionality and customisation to support most use-cases. It may be required at certain times to have more advanced functionality. Rather than have developers build their own widgets it is possible to extend the existing ones.\nFor example we will extend the icon widget to support being tapped. To do this we declare a new struct that embeds the widget.Icon type. We create a constructor function that calls the important ExtendBaseWidget function.\nimport ( \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  type tappableIcon struct { \twidget.Icon }  func newTappableIcon(res fyne.Resource) *tappableIcon { \ticon := \u0026amp;tappableIcon{} \ticon.ExtendBaseWidget(icon) \ticon.SetResource(res)  \treturn icon }  Note: a widget constructor like widget.NewIcon may not be used for extension since it already calls ExtendBaseWidget.\n We then add new functions to implement the fyne.Tappable interface, with those functions added the new Tapped function will be called every time the user taps our new icon. The interface required has two functions, Tapped(*PointEvent) and TappedSecondary(*PointEvent), so we will add both.\nimport \u0026#34;log\u0026#34;  func (t *tappableIcon) Tapped(_ *fyne.PointEvent) { \tlog.Println(\u0026#34;I have been tapped\u0026#34;) }  func (t *tappableIcon) TappedSecondary(_ *fyne.PointEvent) { } We can test this new widget using a simple application as follows.\nimport (  \u0026#34;fyne.io/fyne/v2/app\u0026#34;  \u0026#34;fyne.io/fyne/v2/theme\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Tappable\u0026#34;) \tw.SetContent(newTappableIcon(theme.FyneLogo())) \tw.ShowAndRun() } "},{"id":158,"href":"/fyne/docs/faq/","title":"Frequently Asked Questions","section":"Frequently Asked Questions","content":"As the Fyne toolkit presents a different approach to the traditional design of GUI tookits in some ways we have compiled this selection of answers to frequently asked questions. The content is grouped into the following areas.\n \rLayout and widget size \rTheme and customisation   If you have more questions please get in touch.\n"},{"id":159,"href":"/fyne/docs/api/","title":"fyne","section":"API Documentation","content":"fyne\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Package fyne describes the objects and components available to any Fyne app. These can all be created, manipulated and tested without rendering (for speed). Your main package should use the app package to create an application with a default driver that will render your UI.\nA simple application may look like this:\n package main   import \u0026#34;fyne.io/fyne/v2/app\u0026#34;  import \u0026#34;fyne.io/fyne/v2/container\u0026#34;  import \u0026#34;fyne.io/fyne/v2/widget\u0026#34;   func main() {  a := app.New()  w := a.NewWindow(\u0026#34;Hello\u0026#34;)   hello := widget.NewLabel(\u0026#34;Hello Fyne!\u0026#34;)  w.SetContent(container.NewVBox(  hello,  widget.NewButton(\u0026#34;Hi!\u0026#34;, func() {  hello.SetText(\u0026#34;Welcome :)\u0026#34;)  }),  ))   w.ShowAndRun()  } Usage\r#\r\rconst AnimationRepeatForever = -1 AnimationRepeatForever is an AnimationCount value that indicates it should not stop looping.\nSince: \r2.0\rvar ( \t// AnimationEaseInOut is the default easing, it starts slowly, accelerates to the middle and slows to the end. \t// \t// Since: 2.0 \tAnimationEaseInOut = animationEaseInOut \t// AnimationEaseIn starts slowly and accelerates to the end. \t// \t// Since: 2.0 \tAnimationEaseIn = animationEaseIn \t// AnimationEaseOut starts at speed and slows to the end. \t// \t// Since: 2.0 \tAnimationEaseOut = animationEaseOut \t// AnimationLinear is a linear mapping for animations that progress uniformly through their duration. \t// \t// Since: 2.0 \tAnimationLinear = animationLinear ) func IsHorizontal\r#\r\rfunc IsHorizontal(orient DeviceOrientation) bool IsHorizontal is a helper utility that determines if a passed orientation is horizontal\nfunc IsVertical\r#\r\rfunc IsVertical(orient DeviceOrientation) bool IsVertical is a helper utility that determines if a passed orientation is vertical\nfunc LogError\r#\r\rfunc LogError(reason string, err error) LogError reports an error to the command line with the specified err cause, if not nil. The function also reports basic information about the code location.\nfunc Max\r#\r\rfunc Max(x, y float32) float32 Max returns the larger of the passed values.\nfunc Min\r#\r\rfunc Min(x, y float32) float32 Min returns the smaller of the passed values.\nfunc SetCurrentApp\r#\r\rfunc SetCurrentApp(current App) SetCurrentApp is an internal function to set the app instance currently running.\ntypes\r#\r\r \rAnimation \rAnimationCurve \rApp \rBuildType \rCanvas \rCanvasObject \rClipboard \rContainer \rDelta \rDevice \rDeviceOrientation \rDisableable \rDoubleTappable \rDragEvent \rDraggable \rDriver \rFocusable \rHardwareKey \rKeyEvent \rKeyName \rLayout \rLegacyTheme \rLifecycle \rListableURI \rMainMenu \rMenu \rMenuItem \rNotification \rOverlayStack \rPointEvent \rPosition \rPreferences \rResource \rScrollEvent \rScrollable \rSecondaryTappable \rSettings \rShortcut \rShortcutCopy \rShortcutCut \rShortcutHandler \rShortcutPaste \rShortcutSelectAll \rShortcutable \rSize \rStaticResource \rStorage \rStringValidator \rTabbable \rTappable \rTextAlign \rTextStyle \rTextWrap \rTheme \rThemeColorName \rThemeIconName \rThemeSizeName \rThemeVariant \rURI \rURIReadCloser \rURIWriteCloser \rValidatable \rVector2 \rWidget \rWidgetRenderer \rWindow  "},{"id":160,"href":"/fyne/docs/api/animation/","title":"fyne.Animation","section":"API Documentation","content":"fyne.Animation\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Animation\r#\r\rtype Animation struct { \tAutoReverse bool \tCurve AnimationCurve \tDuration time.Duration \tRepeatCount int \tTick func(float32) } Animation represents an animated element within a Fyne canvas. These animations may control individual objects or entire scenes.\nSince: \r2.0\rfunc NewAnimation\r#\r\rfunc NewAnimation(d time.Duration, fn func(float32)) *Animation NewAnimation creates a very basic animation where the callback function will be called for every rendered frame between time.Now() and the specified duration. The callback values start at 0.0 and will be 1.0 when the animation completes.\nSince: \r2.0\rfunc (*Animation) Start\r#\r\rfunc (a *Animation) Start() Start registers the animation with the application run-loop and starts its execution.\nfunc (*Animation) Stop\r#\r\rfunc (a *Animation) Stop() Stop will end this animation and remove it from the run-loop.\n"},{"id":161,"href":"/fyne/docs/api/animationcurve/","title":"fyne.AnimationCurve","section":"API Documentation","content":"fyne.AnimationCurve\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype AnimationCurve\r#\r\rtype AnimationCurve func(float32) float32 AnimationCurve represents an animation algorithm for calculating the progress through a timeline. Custom animations can be provided by implementing the \u0026ldquo;func(float32) float32\u0026rdquo; definition. The input parameter will start at 0.0 when an animation starts and travel up to 1.0 at which point it will end. A linear animation would return the same output value as is passed in.\n"},{"id":162,"href":"/fyne/docs/api/app/","title":"fyne.App","section":"API Documentation","content":"fyne.App\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype App\r#\r\rtype App interface { \t// Create a new window for the application. \t// The first window to open is considered the \u0026#34;master\u0026#34; and when closed \t// the application will exit. \tNewWindow(title string) Window  \t// Open a URL in the default browser application. \tOpenURL(url *url.URL) error  \t// Icon returns the application icon, this is used in various ways \t// depending on operating system. \t// This is also the default icon for new windows. \tIcon() Resource  \t// SetIcon sets the icon resource used for this application instance. \tSetIcon(Resource)  \t// Run the application - this starts the event loop and waits until Quit() \t// is called or the last window closes. \t// This should be called near the end of a main() function as it will block. \tRun()  \t// Calling Quit on the application will cause the application to exit \t// cleanly, closing all open windows. \t// This function does no thing on a mobile device as the application lifecycle is \t// managed by the operating system. \tQuit()  \t// Driver returns the driver that is rendering this application. \t// Typically not needed for day to day work, mostly internal functionality. \tDriver() Driver  \t// UniqueID returns the application unique identifier, if set. \t// This must be set for use of the Preferences() functions... see NewWithId(string) \tUniqueID() string  \t// SendNotification sends a system notification that will be displayed in the operating system\u0026#39;s notification area. \tSendNotification(*Notification)  \t// Settings return the globally set settings, determining theme and so on. \tSettings() Settings  \t// Preferences returns the application preferences, used for storing configuration and state \tPreferences() Preferences  \t// Storage returns a storage handler specific to this application. \tStorage() Storage  \t// Lifecycle returns a type that allows apps to hook in to lifecycle events. \tLifecycle() Lifecycle } An App is the definition of a graphical application. Apps can have multiple windows, it will exit when the first window to be shown is closed. You can also cause the app to exit by calling Quit(). To start an application you need to call Run() somewhere in your main() function. Alternatively use the window.ShowAndRun() function for your main window.\nfunc CurrentApp\r#\r\rfunc CurrentApp() App CurrentApp returns the current application, for which there is only 1 per process.\n"},{"id":163,"href":"/fyne/docs/api/buildtype/","title":"fyne.BuildType","section":"API Documentation","content":"fyne.BuildType\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype BuildType\r#\r\rtype BuildType int BuildType defines different modes that an application can be built using.\nconst ( \t// BuildStandard is the normal build mode - it is not debug, test or release mode. \tBuildStandard BuildType = iota \t// BuildDebug is used when a developer would like more information and visual output for app debugging. \tBuildDebug \t// BuildRelease is a final production build, it is like BuildStandard but will use distribution certificates. \t// A release build is typically going to connect to live services and is not usually used during development. \tBuildRelease ) "},{"id":164,"href":"/fyne/docs/api/canvas/","title":"fyne.Canvas","section":"API Documentation","content":"fyne.Canvas\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Canvas\r#\r\rtype Canvas interface { \tContent() CanvasObject \tSetContent(CanvasObject)  \tRefresh(CanvasObject)  \t// Focus makes the provided item focused. \t// The item has to be added to the contents of the canvas before calling this. \tFocus(Focusable) \t// FocusNext focuses the next focusable item. \t// If no item is currently focused, the first focusable item is focused. \t// If the last focusable item is currently focused, the first focusable item is focused. \t// \t// Since: 2.0 \tFocusNext() \t// FocusPrevious focuses the previous focusable item. \t// If no item is currently focused, the last focusable item is focused. \t// If the first focusable item is currently focused, the last focusable item is focused. \t// \t// Since: 2.0 \tFocusPrevious() \tUnfocus() \tFocused() Focusable  \t// Size returns the current size of this canvas \tSize() Size \t// Scale returns the current scale (multiplication factor) this canvas uses to render \t// The pixel size of a CanvasObject can be found by multiplying by this value. \tScale() float32  \t// Overlays returns the overlay stack. \tOverlays() OverlayStack  \tOnTypedRune() func(rune) \tSetOnTypedRune(func(rune)) \tOnTypedKey() func(*KeyEvent) \tSetOnTypedKey(func(*KeyEvent)) \tAddShortcut(shortcut Shortcut, handler func(shortcut Shortcut)) \tRemoveShortcut(shortcut Shortcut)  \tCapture() image.Image  \t// PixelCoordinateForPosition returns the x and y pixel coordinate for a given position on this canvas. \t// This can be used to find absolute pixel positions or pixel offsets relative to an object top left. \tPixelCoordinateForPosition(Position) (int, int)  \t// InteractiveArea returns the position and size of the central interactive area. \t// Operating system elements may overlap the portions outside this area and widgets should avoid being outside. \t// \t// Since: 1.4 \tInteractiveArea() (Position, Size) } Canvas defines a graphical canvas to which a CanvasObject or Container can be added. Each canvas has a scale which is automatically applied during the render process.\n"},{"id":165,"href":"/fyne/docs/api/canvasobject/","title":"fyne.CanvasObject","section":"API Documentation","content":"fyne.CanvasObject\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype CanvasObject\r#\r\rtype CanvasObject interface {  \t// MinSize returns the minimum size this object needs to be drawn. \tMinSize() Size \t// Move moves this object to the given position relative to its parent. \t// This should only be called if your object is not in a container with a layout manager. \tMove(Position) \t// Position returns the current position of the object relative to its parent. \tPosition() Position \t// Resize resizes this object to the given size. \t// This should only be called if your object is not in a container with a layout manager. \tResize(Size) \t// Size returns the current size of this object. \tSize() Size  \t// Hide hides this object. \tHide() \t// Visible returns whether this object is visible or not. \tVisible() bool \t// Show shows this object. \tShow()  \t// Refresh must be called if this object should be redrawn because its inner state changed. \tRefresh() } CanvasObject describes any graphical object that can be added to a canvas. Objects have a size and position that can be controlled through this API. MinSize is used to determine the minimum size which this object should be displayed. An object will be visible by default but can be hidden with Hide() and re-shown with Show().\nNote: If this object is controlled as part of a Layout you should not call Resize(Size) or Move(Position).\n"},{"id":166,"href":"/fyne/docs/api/clipboard/","title":"fyne.Clipboard","section":"API Documentation","content":"fyne.Clipboard\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Clipboard\r#\r\rtype Clipboard interface { \t// Content returns the clipboard content \tContent() string \t// SetContent sets the clipboard content \tSetContent(content string) } Clipboard represents the system clipboard interface\n"},{"id":167,"href":"/fyne/docs/api/container/","title":"fyne.Container","section":"API Documentation","content":"fyne.Container\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Container\r#\r\rtype Container struct { \tHidden bool // Is this Container hidden  \tLayout Layout // The Layout algorithm for arranging child CanvasObjects \tObjects []CanvasObject // The set of CanvasObjects this container holds } Container is a CanvasObject that contains a collection of child objects. The layout of the children is set by the specified Layout.\nfunc NewContainer\r#\r\rfunc NewContainer(objects ...CanvasObject) *Container NewContainer returns a new Container instance holding the specified CanvasObjects.\nDeprecated: Use container.NewWithoutLayout() to create a container that uses manual layout.\rfunc NewContainerWithLayout\r#\r\rfunc NewContainerWithLayout(layout Layout, objects ...CanvasObject) *Container NewContainerWithLayout returns a new Container instance holding the specified CanvasObjects which will be laid out according to the specified Layout.\nDeprecated: Use container.New() instead\rfunc NewContainerWithoutLayout\r#\r\rfunc NewContainerWithoutLayout(objects ...CanvasObject) *Container NewContainerWithoutLayout returns a new Container instance holding the specified CanvasObjects that are manually arranged.\nDeprecated: Use container.NewWithoutLayout() instead\rfunc (*Container) Add\r#\r\rfunc (c *Container) Add(add CanvasObject) Add appends the specified object to the items this container manages.\nSince: \r1.4\rfunc (*Container) AddObject\r#\r\rfunc (c *Container) AddObject(o CanvasObject) AddObject adds another CanvasObject to the set this Container holds.\nDeprecated: Use replacement Add() function\rfunc (*Container) Hide\r#\r\rfunc (c *Container) Hide() Hide sets this container, and all its children, to be not visible.\nfunc (*Container) MinSize\r#\r\rfunc (c *Container) MinSize() Size MinSize calculates the minimum size of a Container. This is delegated to the Layout, if specified, otherwise it will mimic MaxLayout.\nfunc (*Container) Move\r#\r\rfunc (c *Container) Move(pos Position) Move the container (and all its children) to a new position, relative to its parent.\nfunc (*Container) Position\r#\r\rfunc (c *Container) Position() Position Position gets the current position of this Container, relative to its parent.\nfunc (*Container) Refresh\r#\r\rfunc (c *Container) Refresh() Refresh causes this object to be redrawn in it\u0026rsquo;s current state\nfunc (*Container) Remove\r#\r\rfunc (c *Container) Remove(rem CanvasObject) Remove updates the contents of this container to no longer include the specified object.\nfunc (*Container) Resize\r#\r\rfunc (c *Container) Resize(size Size) Resize sets a new size for the Container.\nfunc (*Container) Show\r#\r\rfunc (c *Container) Show() Show sets this container, and all its children, to be visible.\nfunc (*Container) Size\r#\r\rfunc (c *Container) Size() Size Size returns the current size of this container.\nfunc (*Container) Visible\r#\r\rfunc (c *Container) Visible() bool Visible returns true if the container is currently visible, false otherwise.\n"},{"id":168,"href":"/fyne/docs/api/delta/","title":"fyne.Delta","section":"API Documentation","content":"fyne.Delta\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Delta\r#\r\rtype Delta struct { \tDX, DY float32 } Delta is a generic X, Y coordinate, size or movement representation.\nfunc NewDelta\r#\r\rfunc NewDelta(dx float32, dy float32) Delta NewDelta returns a newly allocated Delta representing a movement in the X and Y axis.\nfunc (Delta) Components\r#\r\rfunc (v Delta) Components() (float32, float32) Components returns the X and Y elements of this Delta.\nfunc (Delta) IsZero\r#\r\rfunc (v Delta) IsZero() bool IsZero returns whether the Position is at the zero-point.\n"},{"id":169,"href":"/fyne/docs/api/device/","title":"fyne.Device","section":"API Documentation","content":"fyne.Device\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Device\r#\r\rtype Device interface { \tOrientation() DeviceOrientation \tIsMobile() bool \tHasKeyboard() bool \tSystemScaleForWindow(Window) float32 } Device provides information about the devices the code is running on\nfunc CurrentDevice\r#\r\rfunc CurrentDevice() Device CurrentDevice returns the device information for the current hardware (via the driver)\n"},{"id":170,"href":"/fyne/docs/api/deviceorientation/","title":"fyne.DeviceOrientation","section":"API Documentation","content":"fyne.DeviceOrientation\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype DeviceOrientation\r#\r\rtype DeviceOrientation int DeviceOrientation represents the different ways that a mobile device can be held\nconst ( \t// OrientationVertical is the default vertical orientation \tOrientationVertical DeviceOrientation = iota \t// OrientationVerticalUpsideDown is the portrait orientation held upside down \tOrientationVerticalUpsideDown \t// OrientationHorizontalLeft is used to indicate a landscape orientation with the top to the left \tOrientationHorizontalLeft \t// OrientationHorizontalRight is used to indicate a landscape orientation with the top to the right \tOrientationHorizontalRight ) "},{"id":171,"href":"/fyne/docs/api/disableable/","title":"fyne.Disableable","section":"API Documentation","content":"fyne.Disableable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Disableable\r#\r\rtype Disableable interface { \tEnable() \tDisable() \tDisabled() bool } Disableable describes any CanvasObject that can be disabled. This is primarily used with objects that also implement the Tappable interface.\n"},{"id":172,"href":"/fyne/docs/api/doubletappable/","title":"fyne.DoubleTappable","section":"API Documentation","content":"fyne.DoubleTappable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype DoubleTappable\r#\r\rtype DoubleTappable interface { \tDoubleTapped(*PointEvent) } DoubleTappable describes any CanvasObject that can also be double tapped.\n"},{"id":173,"href":"/fyne/docs/api/dragevent/","title":"fyne.DragEvent","section":"API Documentation","content":"fyne.DragEvent\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype DragEvent\r#\r\rtype DragEvent struct { \tPointEvent \tDragged Delta } DragEvent defines the parameters of a pointer or other drag event. The DraggedX and DraggedY fields show how far the item was dragged since the last event.\n"},{"id":174,"href":"/fyne/docs/api/draggable/","title":"fyne.Draggable","section":"API Documentation","content":"fyne.Draggable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Draggable\r#\r\rtype Draggable interface { \tDragged(*DragEvent) \tDragEnd() } Draggable indicates that a CanvasObject can be dragged. This is used for any item that the user has indicated should be moved across the screen.\n"},{"id":175,"href":"/fyne/docs/api/driver/","title":"fyne.Driver","section":"API Documentation","content":"fyne.Driver\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Driver\r#\r\rtype Driver interface { \t// CreateWindow creates a new UI Window. \tCreateWindow(string) Window \t// AllWindows returns a slice containing all app windows. \tAllWindows() []Window  \t// RenderedTextSize returns the size required to render the given string of specified \t// font size and style. It also returns the height to text baseline, measured from the top. \tRenderedTextSize(text string, fontSize float32, style TextStyle) (size Size, baseline float32)  \t// CanvasForObject returns the canvas that is associated with a given CanvasObject. \tCanvasForObject(CanvasObject) Canvas \t// AbsolutePositionForObject returns the position of a given CanvasObject relative to the top/left of a canvas. \tAbsolutePositionForObject(CanvasObject) Position  \t// Device returns the device that the application is currently running on. \tDevice() Device \t// Run starts the main event loop of the driver. \tRun() \t// Quit closes the driver and open windows, then exit the application. \t// On some some operating systems this does nothing, for example iOS and Android. \tQuit()  \t// StartAnimation registers a new animation with this driver and requests it be started. \tStartAnimation(*Animation) \t// StopAnimation stops an animation and unregisters from this driver. \tStopAnimation(*Animation) } Driver defines an abstract concept of a Fyne render driver. Any implementation must provide at least these methods.\n"},{"id":176,"href":"/fyne/docs/api/focusable/","title":"fyne.Focusable\"","section":"API Documentation","content":"fyne.Focusable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Focusable\r#\r\rtype Focusable interface { \t// FocusGained is a hook called by the focus handling logic after this object gained the focus. \tFocusGained() \t// FocusLost is a hook called by the focus handling logic after this object lost the focus. \tFocusLost()  \t// TypedRune is a hook called by the input handling logic on text input events if this object is focused. \tTypedRune(rune) \t// TypedKey is a hook called by the input handling logic on key events if this object is focused. \tTypedKey(*KeyEvent) } Focusable describes any CanvasObject that can respond to being focused. It will receive the FocusGained and FocusLost events appropriately. When focused it will also have TypedRune called as text is input and TypedKey called when other keys are pressed.\nNote: You must not change canvas state (including overlays or focus) in FocusGained or FocusLost or you would end up with a dead-lock.\n"},{"id":177,"href":"/fyne/docs/api/hardwarekey/","title":"fyne.HardwareKey","section":"API Documentation","content":"fyne.HardwareKey\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype HardwareKey\r#\r\rtype HardwareKey struct { \t// ScanCode represents a hardware ID for (normally desktop) keyboard events. \tScanCode int } HardwareKey contains information associated with physical key events Most applications should use KeyName for cross-platform compatibility.\n"},{"id":178,"href":"/fyne/docs/api/keyevent/","title":"fyne.KeyEvent","section":"API Documentation","content":"fyne.KeyEvent\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype KeyEvent\r#\r\rtype KeyEvent struct { \t// Name describes the keyboard event that is consistent across platforms. \tName KeyName \t// Physical is a platform specific field that reports the hardware information of physical keyboard events. \tPhysical HardwareKey } KeyEvent describes a keyboard input event.\n"},{"id":179,"href":"/fyne/docs/api/keyname/","title":"fyne.KeyName","section":"API Documentation","content":"fyne.KeyName\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype KeyName\r#\r\rtype KeyName string KeyName represents the name of a key that has been pressed\nconst ( \t// KeyEscape is the \u0026#34;esc\u0026#34; key \tKeyEscape KeyName = \u0026#34;Escape\u0026#34; \t// KeyReturn is the carriage return (main keyboard) \tKeyReturn KeyName = \u0026#34;Return\u0026#34; \t// KeyTab is the tab advance key \tKeyTab KeyName = \u0026#34;Tab\u0026#34; \t// KeyBackspace is the delete-before-cursor key \tKeyBackspace KeyName = \u0026#34;BackSpace\u0026#34; \t// KeyInsert is the insert mode key \tKeyInsert KeyName = \u0026#34;Insert\u0026#34; \t// KeyDelete is the delete-after-cursor key \tKeyDelete KeyName = \u0026#34;Delete\u0026#34; \t// KeyRight is the right arrow key \tKeyRight KeyName = \u0026#34;Right\u0026#34; \t// KeyLeft is the left arrow key \tKeyLeft KeyName = \u0026#34;Left\u0026#34; \t// KeyDown is the down arrow key \tKeyDown KeyName = \u0026#34;Down\u0026#34; \t// KeyUp is the up arrow key \tKeyUp KeyName = \u0026#34;Up\u0026#34; \t// KeyPageUp is the page up num-pad key \tKeyPageUp KeyName = \u0026#34;Prior\u0026#34; \t// KeyPageDown is the page down num-pad key \tKeyPageDown KeyName = \u0026#34;Next\u0026#34; \t// KeyHome is the line-home key \tKeyHome KeyName = \u0026#34;Home\u0026#34; \t// KeyEnd is the line-end key \tKeyEnd KeyName = \u0026#34;End\u0026#34;  \t// KeyF1 is the first function key \tKeyF1 KeyName = \u0026#34;F1\u0026#34; \t// KeyF2 is the second function key \tKeyF2 KeyName = \u0026#34;F2\u0026#34; \t// KeyF3 is the third function key \tKeyF3 KeyName = \u0026#34;F3\u0026#34; \t// KeyF4 is the fourth function key \tKeyF4 KeyName = \u0026#34;F4\u0026#34; \t// KeyF5 is the fifth function key \tKeyF5 KeyName = \u0026#34;F5\u0026#34; \t// KeyF6 is the sixth function key \tKeyF6 KeyName = \u0026#34;F6\u0026#34; \t// KeyF7 is the seventh function key \tKeyF7 KeyName = \u0026#34;F7\u0026#34; \t// KeyF8 is the eighth function key \tKeyF8 KeyName = \u0026#34;F8\u0026#34; \t// KeyF9 is the ninth function key \tKeyF9 KeyName = \u0026#34;F9\u0026#34; \t// KeyF10 is the tenth function key \tKeyF10 KeyName = \u0026#34;F10\u0026#34; \t// KeyF11 is the eleventh function key \tKeyF11 KeyName = \u0026#34;F11\u0026#34; \t// KeyF12 is the twelfth function key \tKeyF12 KeyName = \u0026#34;F12\u0026#34;  \t// KeyEnter is the enter/ return key (keypad) \tKeyEnter KeyName = \u0026#34;KP_Enter\u0026#34;  \t// Key0 represents the key 0 \tKey0 KeyName = \u0026#34;0\u0026#34; \t// Key1 represents the key 1 \tKey1 KeyName = \u0026#34;1\u0026#34; \t// Key2 represents the key 2 \tKey2 KeyName = \u0026#34;2\u0026#34; \t// Key3 represents the key 3 \tKey3 KeyName = \u0026#34;3\u0026#34; \t// Key4 represents the key 4 \tKey4 KeyName = \u0026#34;4\u0026#34; \t// Key5 represents the key 5 \tKey5 KeyName = \u0026#34;5\u0026#34; \t// Key6 represents the key 6 \tKey6 KeyName = \u0026#34;6\u0026#34; \t// Key7 represents the key 7 \tKey7 KeyName = \u0026#34;7\u0026#34; \t// Key8 represents the key 8 \tKey8 KeyName = \u0026#34;8\u0026#34; \t// Key9 represents the key 9 \tKey9 KeyName = \u0026#34;9\u0026#34; \t// KeyA represents the key A \tKeyA KeyName = \u0026#34;A\u0026#34; \t// KeyB represents the key B \tKeyB KeyName = \u0026#34;B\u0026#34; \t// KeyC represents the key C \tKeyC KeyName = \u0026#34;C\u0026#34; \t// KeyD represents the key D \tKeyD KeyName = \u0026#34;D\u0026#34; \t// KeyE represents the key E \tKeyE KeyName = \u0026#34;E\u0026#34; \t// KeyF represents the key F \tKeyF KeyName = \u0026#34;F\u0026#34; \t// KeyG represents the key G \tKeyG KeyName = \u0026#34;G\u0026#34; \t// KeyH represents the key H \tKeyH KeyName = \u0026#34;H\u0026#34; \t// KeyI represents the key I \tKeyI KeyName = \u0026#34;I\u0026#34; \t// KeyJ represents the key J \tKeyJ KeyName = \u0026#34;J\u0026#34; \t// KeyK represents the key K \tKeyK KeyName = \u0026#34;K\u0026#34; \t// KeyL represents the key L \tKeyL KeyName = \u0026#34;L\u0026#34; \t// KeyM represents the key M \tKeyM KeyName = \u0026#34;M\u0026#34; \t// KeyN represents the key N \tKeyN KeyName = \u0026#34;N\u0026#34; \t// KeyO represents the key O \tKeyO KeyName = \u0026#34;O\u0026#34; \t// KeyP represents the key P \tKeyP KeyName = \u0026#34;P\u0026#34; \t// KeyQ represents the key Q \tKeyQ KeyName = \u0026#34;Q\u0026#34; \t// KeyR represents the key R \tKeyR KeyName = \u0026#34;R\u0026#34; \t// KeyS represents the key S \tKeyS KeyName = \u0026#34;S\u0026#34; \t// KeyT represents the key T \tKeyT KeyName = \u0026#34;T\u0026#34; \t// KeyU represents the key U \tKeyU KeyName = \u0026#34;U\u0026#34; \t// KeyV represents the key V \tKeyV KeyName = \u0026#34;V\u0026#34; \t// KeyW represents the key W \tKeyW KeyName = \u0026#34;W\u0026#34; \t// KeyX represents the key X \tKeyX KeyName = \u0026#34;X\u0026#34; \t// KeyY represents the key Y \tKeyY KeyName = \u0026#34;Y\u0026#34; \t// KeyZ represents the key Z \tKeyZ KeyName = \u0026#34;Z\u0026#34;  \t// KeySpace is the space key \tKeySpace KeyName = \u0026#34;Space\u0026#34; \t// KeyApostrophe is the key \u0026#34;\u0026#39;\u0026#34; \tKeyApostrophe KeyName = \u0026#34;\u0026#39;\u0026#34; \t// KeyComma is the key \u0026#34;,\u0026#34; \tKeyComma KeyName = \u0026#34;,\u0026#34; \t// KeyMinus is the key \u0026#34;-\u0026#34; \tKeyMinus KeyName = \u0026#34;-\u0026#34; \t// KeyPeriod is the key \u0026#34;.\u0026#34; (full stop) \tKeyPeriod KeyName = \u0026#34;.\u0026#34; \t// KeySlash is the key \u0026#34;/\u0026#34; \tKeySlash KeyName = \u0026#34;/\u0026#34; \t// KeyBackslash is the key \u0026#34;\\\u0026#34; \tKeyBackslash KeyName = \u0026#34;\\\\\u0026#34; \t// KeyLeftBracket is the key \u0026#34;[\u0026#34; \tKeyLeftBracket KeyName = \u0026#34;[\u0026#34; \t// KeyRightBracket is the key \u0026#34;]\u0026#34; \tKeyRightBracket KeyName = \u0026#34;]\u0026#34; \t// KeySemicolon is the key \u0026#34;;\u0026#34; \tKeySemicolon KeyName = \u0026#34;;\u0026#34; \t// KeyEqual is the key \u0026#34;=\u0026#34; \tKeyEqual KeyName = \u0026#34;=\u0026#34; \t// KeyAsterisk is the keypad key \u0026#34;*\u0026#34; \tKeyAsterisk KeyName = \u0026#34;*\u0026#34; \t// KeyPlus is the keypad key \u0026#34;+\u0026#34; \tKeyPlus KeyName = \u0026#34;+\u0026#34; \t// KeyBackTick is the key \u0026#34;`\u0026#34; on a US keyboard \tKeyBackTick KeyName = \u0026#34;`\u0026#34;  \t// KeyUnknown is used for key events where the underlying hardware generated an \t// event that Fyne could not decode. \t// \t// Since: 2.1 \tKeyUnknown KeyName = \u0026#34;\u0026#34; ) "},{"id":180,"href":"/fyne/docs/api/layout/","title":"fyne.Layout","section":"API Documentation","content":"fyne.Layout\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Layout\r#\r\rtype Layout interface { \t// Layout will manipulate the listed CanvasObjects Size and Position \t// to fit within the specified size. \tLayout([]CanvasObject, Size) \t// MinSize calculates the smallest size that will fit the listed \t// CanvasObjects using this Layout algorithm. \tMinSize(objects []CanvasObject) Size } Layout defines how CanvasObjects may be laid out in a specified Size.\n"},{"id":181,"href":"/fyne/docs/api/legacytheme/","title":"fyne.LegacyTheme","section":"API Documentation","content":"fyne.LegacyTheme\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype LegacyTheme\r#\r\rtype LegacyTheme interface { \tBackgroundColor() color.Color \tButtonColor() color.Color \tDisabledButtonColor() color.Color \tTextColor() color.Color \tDisabledTextColor() color.Color \tPlaceHolderColor() color.Color \tPrimaryColor() color.Color \tHoverColor() color.Color \tFocusColor() color.Color \tScrollBarColor() color.Color \tShadowColor() color.Color  \tTextSize() int \tTextFont() Resource \tTextBoldFont() Resource \tTextItalicFont() Resource \tTextBoldItalicFont() Resource \tTextMonospaceFont() Resource  \tPadding() int \tIconInlineSize() int \tScrollBarSize() int \tScrollBarSmallSize() int } LegacyTheme defines the requirements of any Fyne theme. This was previously called Theme and is kept for simpler transition of applications built before v2.0.0.\nSince: \r2.0\r"},{"id":182,"href":"/fyne/docs/api/lifecycle/","title":"fyne.Lifecycle","section":"API Documentation","content":"fyne.Lifecycle\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Lifecycle\r#\r\rtype Lifecycle interface { \t// SetOnEnteredForeground hooks into the app becoming foreground and gaining focus. \tSetOnEnteredForeground(func()) \t// SetOnExitedForeground hooks into the app losing input focus and going into the background. \tSetOnExitedForeground(func()) \t// SetOnStarted hooks into an event that says the app is now running. \tSetOnStarted(func()) \t// SetOnStopped hooks into an event that says the app is no longer running. \tSetOnStopped(func()) } Lifecycle represents the various phases that an app can transition through.\nSince: \r2.1\r"},{"id":183,"href":"/fyne/docs/api/listableuri/","title":"fyne.ListableURI","section":"API Documentation","content":"fyne.ListableURI\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ListableURI\r#\r\rtype ListableURI interface { \tURI  \t// List returns a list of child URIs of this URI. \tList() ([]URI, error) } ListableURI represents a URI that can have child items, most commonly a directory on disk in the native filesystem.\nSince: \r1.4\r"},{"id":184,"href":"/fyne/docs/api/mainmenu/","title":"fyne.MainMenu","section":"API Documentation","content":"fyne.MainMenu\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype MainMenu\r#\r\rtype MainMenu struct { \tItems []*Menu } MainMenu defines the data required to show a menu bar (desktop) or other appropriate top level menu.\nfunc NewMainMenu\r#\r\rfunc NewMainMenu(items ...*Menu) *MainMenu NewMainMenu creates a top level menu structure used by fyne.Window for displaying a menubar (or appropriate equivalent).\n"},{"id":185,"href":"/fyne/docs/api/menu/","title":"fyne.Menu","section":"API Documentation","content":"fyne.Menu\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Menu\r#\r\rtype Menu struct { \tLabel string \tItems []*MenuItem } Menu stores the information required for a standard menu. A menu can pop down from a MainMenu or could be a pop out menu.\nfunc NewMenu\r#\r\rfunc NewMenu(label string, items ...*MenuItem) *Menu NewMenu creates a new menu given the specified label (to show in a MainMenu) and list of items to display.\n"},{"id":186,"href":"/fyne/docs/api/menuitem/","title":"fyne.MenuItem","section":"API Documentation","content":"fyne.MenuItem\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype MenuItem\r#\r\rtype MenuItem struct { \tChildMenu *Menu \t// Since: 2.1 \tIsQuit bool \tIsSeparator bool \tLabel string \tAction func() \t// Since: 2.1 \tDisabled bool \t// Since: 2.1 \tChecked bool } MenuItem is a single item within any menu, it contains a display Label and Action function that is called when tapped.\nfunc NewMenuItem\r#\r\rfunc NewMenuItem(label string, action func()) *MenuItem NewMenuItem creates a new menu item from the passed label and action parameters.\nfunc NewMenuItemSeparator\r#\r\rfunc NewMenuItemSeparator() *MenuItem NewMenuItemSeparator creates a menu item that is to be used as a separator.\n"},{"id":187,"href":"/fyne/docs/api/notification/","title":"fyne.Notification","section":"API Documentation","content":"fyne.Notification\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Notification\r#\r\rtype Notification struct { \tTitle, Content string } Notification represents a user notification that can be sent to the operating system.\nfunc NewNotification\r#\r\rfunc NewNotification(title, content string) *Notification NewNotification creates a notification that can be passed to App.SendNotification.\n"},{"id":188,"href":"/fyne/docs/api/overlaystack/","title":"fyne.OverlayStack","section":"API Documentation","content":"fyne.OverlayStack\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype OverlayStack\r#\r\rtype OverlayStack interface { \t// Add adds an overlay on the top of the overlay stack. \tAdd(overlay CanvasObject) \t// List returns the overlays currently on the overlay stack. \tList() []CanvasObject \t// Remove removes the given object and all objects above it from the overlay stack. \tRemove(overlay CanvasObject) \t// Top returns the top-most object of the overlay stack. \tTop() CanvasObject } OverlayStack is a stack of CanvasObjects intended to be used as overlays of a Canvas.\n"},{"id":189,"href":"/fyne/docs/api/pointevent/","title":"fyne.PointEvent","section":"API Documentation","content":"fyne.PointEvent\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype PointEvent\r#\r\rtype PointEvent struct { \tAbsolutePosition Position // The absolute position of the event \tPosition Position // The relative position of the event } PointEvent describes a pointer input event. The position is relative to the top-left of the CanvasObject this is triggered on.\n"},{"id":190,"href":"/fyne/docs/api/position/","title":"fyne.Position","section":"API Documentation","content":"fyne.Position\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Position\r#\r\rtype Position struct { \tX float32 // The position from the parent\u0026#39;s left edge \tY float32 // The position from the parent\u0026#39;s top edge } Position describes a generic X, Y coordinate relative to a parent Canvas or CanvasObject.\nfunc NewPos\r#\r\rfunc NewPos(x float32, y float32) Position NewPos returns a newly allocated Position representing the specified coordinates.\nfunc (Position) Add\r#\r\rfunc (p Position) Add(v Vector2) Position Add returns a new Position that is the result of offsetting the current position by p2 X and Y.\nfunc (Position) Components\r#\r\rfunc (p Position) Components() (float32, float32) Components returns the X and Y elements of this Position\nfunc (Position) IsZero\r#\r\rfunc (p Position) IsZero() bool IsZero returns whether the Position is at the zero-point.\nfunc (Position) Subtract\r#\r\rfunc (p Position) Subtract(v Vector2) Position Subtract returns a new Position that is the result of offsetting the current position by p2 -X and -Y.\n"},{"id":191,"href":"/fyne/docs/api/preferences/","title":"fyne.Preferences","section":"API Documentation","content":"fyne.Preferences\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Preferences\r#\r\rtype Preferences interface { \t// Bool looks up a boolean value for the key \tBool(key string) bool \t// BoolWithFallback looks up a boolean value and returns the given fallback if not found \tBoolWithFallback(key string, fallback bool) bool \t// SetBool saves a boolean value for the given key \tSetBool(key string, value bool)  \t// Float looks up a float64 value for the key \tFloat(key string) float64 \t// FloatWithFallback looks up a float64 value and returns the given fallback if not found \tFloatWithFallback(key string, fallback float64) float64 \t// SetFloat saves a float64 value for the given key \tSetFloat(key string, value float64)  \t// Int looks up an integer value for the key \tInt(key string) int \t// IntWithFallback looks up an integer value and returns the given fallback if not found \tIntWithFallback(key string, fallback int) int \t// SetInt saves an integer value for the given key \tSetInt(key string, value int)  \t// String looks up a string value for the key \tString(key string) string \t// StringWithFallback looks up a string value and returns the given fallback if not found \tStringWithFallback(key, fallback string) string \t// SetString saves a string value for the given key \tSetString(key string, value string)  \t// RemoveValue removes a value for the given key (not currently supported on iOS) \tRemoveValue(key string)  \t// AddChangeListener allows code to be notified when some preferences change. This will fire on any update. \tAddChangeListener(func()) } Preferences describes the ways that an app can save and load user preferences\n"},{"id":192,"href":"/fyne/docs/api/resource/","title":"fyne.Resource","section":"API Documentation","content":"fyne.Resource\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Resource\r#\r\rtype Resource interface { \tName() string \tContent() []byte } Resource represents a single binary resource, such as an image or font. A resource has an identifying name and byte array content. The serialised path of a resource can be obtained which may result in a blocking filesystem write operation.\nfunc LoadResourceFromPath\r#\r\rfunc LoadResourceFromPath(path string) (Resource, error) LoadResourceFromPath creates a new StaticResource in memory using the contents of the specified file.\nfunc LoadResourceFromURLString\r#\r\rfunc LoadResourceFromURLString(urlStr string) (Resource, error) LoadResourceFromURLString creates a new StaticResource in memory using the body of the specified URL.\n"},{"id":193,"href":"/fyne/docs/api/scrollable/","title":"fyne.Scrollable","section":"API Documentation","content":"fyne.Scrollable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Scrollable\r#\r\rtype Scrollable interface { \tScrolled(*ScrollEvent) } Scrollable describes any CanvasObject that can also be scrolled. This is mostly used to implement the widget.ScrollContainer.\n"},{"id":194,"href":"/fyne/docs/api/scrollevent/","title":"fyne.ScrollEvent","section":"API Documentation","content":"fyne.ScrollEvent\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ScrollEvent\r#\r\rtype ScrollEvent struct { \tPointEvent \tScrolled Delta } ScrollEvent defines the parameters of a pointer or other scroll event. The DeltaX and DeltaY represent how large the scroll was in two dimensions.\n"},{"id":195,"href":"/fyne/docs/api/secondarytappable/","title":"fyne.SecondaryTappable","section":"API Documentation","content":"fyne.SecondaryTappable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype SecondaryTappable\r#\r\rtype SecondaryTappable interface { \tTappedSecondary(*PointEvent) } SecondaryTappable describes a CanvasObject that can be right-clicked or long-tapped.\n"},{"id":196,"href":"/fyne/docs/api/settings/","title":"fyne.Settings","section":"API Documentation","content":"fyne.Settings\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Settings\r#\r\rtype Settings interface { \tTheme() Theme \tSetTheme(Theme) \t// ThemeVariant defines which preferred version of a theme should be used (i.e. light or dark) \t// \t// Since: 2.0 \tThemeVariant() ThemeVariant \tScale() float32 \t// PrimaryColor indicates a user preference for a named primary color \t// \t// Since: 1.4 \tPrimaryColor() string  \tAddChangeListener(chan Settings) \tBuildType() BuildType } Settings describes the application configuration available.\n"},{"id":197,"href":"/fyne/docs/api/shortcut/","title":"fyne.Shortcut","section":"API Documentation","content":"fyne.Shortcut\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Shortcut\r#\r\rtype Shortcut interface { \tShortcutName() string } Shortcut is the interface used to describe a shortcut action\n"},{"id":198,"href":"/fyne/docs/api/shortcutable/","title":"fyne.Shortcutable","section":"API Documentation","content":"fyne.Shortcutable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Shortcutable\r#\r\rtype Shortcutable interface { \tTypedShortcut(Shortcut) } Shortcutable describes any CanvasObject that can respond to shortcut commands (quit, cut, copy, and paste).\n"},{"id":199,"href":"/fyne/docs/api/shortcutcopy/","title":"fyne.ShortcutCopy","section":"API Documentation","content":"fyne.ShortcutCopy\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ShortcutCopy\r#\r\rtype ShortcutCopy struct { \tClipboard Clipboard } ShortcutCopy describes a shortcut copy action.\nfunc (*ShortcutCopy) ShortcutName\r#\r\rfunc (se *ShortcutCopy) ShortcutName() string ShortcutName returns the shortcut name\n"},{"id":200,"href":"/fyne/docs/api/shortcutcut/","title":"fyne.ShortcutCut","section":"API Documentation","content":"fyne.ShortcutCut\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ShortcutCut\r#\r\rtype ShortcutCut struct { \tClipboard Clipboard } ShortcutCut describes a shortcut cut action.\nfunc (*ShortcutCut) ShortcutName\r#\r\rfunc (se *ShortcutCut) ShortcutName() string ShortcutName returns the shortcut name\n"},{"id":201,"href":"/fyne/docs/api/shortcuthandler/","title":"fyne.ShortcutHandler","section":"API Documentation","content":"fyne.ShortcutHandler\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ShortcutHandler\r#\r\rtype ShortcutHandler struct { } ShortcutHandler is a default implementation of the shortcut handler for the canvasObject\nfunc (*ShortcutHandler) AddShortcut\r#\r\rfunc (sh *ShortcutHandler) AddShortcut(shortcut Shortcut, handler func(shortcut Shortcut)) AddShortcut register an handler to be executed when the shortcut action is triggered\nfunc (*ShortcutHandler) RemoveShortcut\r#\r\rfunc (sh *ShortcutHandler) RemoveShortcut(shortcut Shortcut) RemoveShortcut removes a registered shortcut\nfunc (*ShortcutHandler) TypedShortcut\r#\r\rfunc (sh *ShortcutHandler) TypedShortcut(shortcut Shortcut) TypedShortcut handle the registered shortcut\n"},{"id":202,"href":"/fyne/docs/api/shortcutpaste/","title":"fyne.ShortcutPaste","section":"API Documentation","content":"fyne.ShortcutPaste\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ShortcutPaste\r#\r\rtype ShortcutPaste struct { \tClipboard Clipboard } ShortcutPaste describes a shortcut paste action.\nfunc (*ShortcutPaste) ShortcutName\r#\r\rfunc (se *ShortcutPaste) ShortcutName() string ShortcutName returns the shortcut name\n"},{"id":203,"href":"/fyne/docs/api/shortcutselectall/","title":"fyne.ShortcutSelectAll","section":"API Documentation","content":"fyne.ShortcutSelectAll\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ShortcutSelectAll\r#\r\rtype ShortcutSelectAll struct{} ShortcutSelectAll describes a shortcut selectAll action.\nfunc (*ShortcutSelectAll) ShortcutName\r#\r\rfunc (se *ShortcutSelectAll) ShortcutName() string ShortcutName returns the shortcut name\n"},{"id":204,"href":"/fyne/docs/api/size/","title":"fyne.Size","section":"API Documentation","content":"fyne.Size\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Size\r#\r\rtype Size struct { \tWidth float32 // The number of units along the X axis. \tHeight float32 // The number of units along the Y axis. } Size describes something with width and height.\nfunc MeasureText\r#\r\rfunc MeasureText(text string, size float32, style TextStyle) Size MeasureText uses the current driver to calculate the size of text when rendered.\nfunc NewSize\r#\r\rfunc NewSize(w float32, h float32) Size NewSize returns a newly allocated Size of the specified dimensions.\nfunc (Size) Add\r#\r\rfunc (s Size) Add(v Vector2) Size Add returns a new Size that is the result of increasing the current size by s2 Width and Height.\nfunc (Size) Components\r#\r\rfunc (s Size) Components() (float32, float32) Components returns the Width and Height elements of this Size\nfunc (Size) IsZero\r#\r\rfunc (s Size) IsZero() bool IsZero returns whether the Size has zero width and zero height.\nfunc (Size) Max\r#\r\rfunc (s Size) Max(v Vector2) Size Max returns a new Size that is the maximum of the current Size and s2.\nfunc (Size) Min\r#\r\rfunc (s Size) Min(v Vector2) Size Min returns a new Size that is the minimum of the current Size and s2.\nfunc (Size) Subtract\r#\r\rfunc (s Size) Subtract(v Vector2) Size Subtract returns a new Size that is the result of decreasing the current size by s2 Width and Height.\n"},{"id":205,"href":"/fyne/docs/api/staticresource/","title":"fyne.StaticResource","section":"API Documentation","content":"fyne.StaticResource\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype StaticResource\r#\r\rtype StaticResource struct { \tStaticName string \tStaticContent []byte } StaticResource is a bundled resource compiled into the application. These resources are normally generated by the fyne_bundle command included in the Fyne toolkit.\nfunc NewStaticResource\r#\r\rfunc NewStaticResource(name string, content []byte) *StaticResource NewStaticResource returns a new static resource object with the specified name and content. Creating a new static resource in memory results in sharable binary data that may be serialised to the location returned by CachePath().\nfunc (*StaticResource) Content\r#\r\rfunc (r *StaticResource) Content() []byte Content returns the bytes of the bundled resource, no compression is applied but any compression on the resource is retained.\nfunc (*StaticResource) GoString\r#\r\rfunc (r *StaticResource) GoString() string GoString converts a Resource object to Go code. This is useful if serialising to a Go file for compilation into a binary.\nfunc (*StaticResource) Name\r#\r\rfunc (r *StaticResource) Name() string Name returns the unique name of this resource, usually matching the file it was generated from.\n"},{"id":206,"href":"/fyne/docs/api/storage/","title":"fyne.Storage","section":"API Documentation","content":"fyne.Storage\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Storage\r#\r\rtype Storage interface { \tRootURI() URI  \tCreate(name string) (URIWriteCloser, error) \tOpen(name string) (URIReadCloser, error) \tSave(name string) (URIWriteCloser, error) \tRemove(name string) error  \tList() []string } Storage is used to manage file storage inside an application sandbox. The files managed by this interface are unique to the current application.\n"},{"id":207,"href":"/fyne/docs/api/stringvalidator/","title":"fyne.StringValidator","section":"API Documentation","content":"fyne.StringValidator\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype StringValidator\r#\r\rtype StringValidator func(string) error StringValidator is a function signature for validating string inputs.\nSince: \r1.4\r"},{"id":208,"href":"/fyne/docs/api/tabbable/","title":"fyne.Tabbable","section":"API Documentation","content":"fyne.Tabbable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Tabbable\r#\r\rtype Tabbable interface { \t// AcceptsTab() is a hook called by the key press handling logic. \t// If it returns true then the Tab key events will be sent using TypedKey. \tAcceptsTab() bool } Tabbable describes any object that needs to accept the Tab key presses.\nSince: \r2.1\r"},{"id":209,"href":"/fyne/docs/api/tappable/","title":"fyne.Tappable","section":"API Documentation","content":"fyne.Tappable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Tappable\r#\r\rtype Tappable interface { \tTapped(*PointEvent) } Tappable describes any CanvasObject that can also be tapped. This should be implemented by buttons etc that wish to handle pointer interactions.\n"},{"id":210,"href":"/fyne/docs/api/textalign/","title":"fyne.TextAlign","section":"API Documentation","content":"fyne.TextAlign\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype TextAlign\r#\r\rtype TextAlign int TextAlign represents the horizontal alignment of text within a widget or canvas object.\nconst ( \t// TextAlignLeading specifies a left alignment for left-to-right languages. \tTextAlignLeading TextAlign = iota \t// TextAlignCenter places the text centrally within the available space. \tTextAlignCenter \t// TextAlignTrailing will align the text right for a left-to-right language. \tTextAlignTrailing ) "},{"id":211,"href":"/fyne/docs/api/textstyle/","title":"fyne.TextStyle","section":"API Documentation","content":"fyne.TextStyle\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype TextStyle\r#\r\rtype TextStyle struct { \tBold bool // Should text be bold \tItalic bool // Should text be italic \tMonospace bool // Use the system monospace font instead of regular  \t// Since: 2.1 \tTabWidth int // Width of tabs in spaces } TextStyle represents the styles that can be applied to a text canvas object or text based widget.\n"},{"id":212,"href":"/fyne/docs/api/textwrap/","title":"fyne.TextWrap","section":"API Documentation","content":"fyne.TextWrap\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype TextWrap\r#\r\rtype TextWrap int TextWrap represents how text longer than the widget\u0026rsquo;s width will be wrapped.\nconst ( \t// TextWrapOff extends the widget\u0026#39;s width to fit the text, no wrapping is applied. \tTextWrapOff TextWrap = iota \t// TextTruncate trims the text to the widget\u0026#39;s width, no wrapping is applied. \t// If an entry is asked to truncate it will provide scrolling capabilities. \tTextTruncate \t// TextWrapBreak trims the line of characters to the widget\u0026#39;s width adding the excess as new line. \t// An Entry with text wrapping will scroll vertically if there is not enough space for all the text. \tTextWrapBreak \t// TextWrapWord trims the line of words to the widget\u0026#39;s width adding the excess as new line. \t// An Entry with text wrapping will scroll vertically if there is not enough space for all the text. \tTextWrapWord ) "},{"id":213,"href":"/fyne/docs/api/theme/","title":"fyne.Theme","section":"API Documentation","content":"fyne.Theme\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Theme\r#\r\rtype Theme interface { \tColor(ThemeColorName, ThemeVariant) color.Color \tFont(TextStyle) Resource \tIcon(ThemeIconName) Resource \tSize(ThemeSizeName) float32 } Theme defines the method to look up colors, sizes and fonts that make up a Fyne theme.\nSince: \r2.0\r"},{"id":214,"href":"/fyne/docs/api/themecolorname/","title":"fyne.ThemeColorName","section":"API Documentation","content":"fyne.ThemeColorName\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ThemeColorName\r#\r\rtype ThemeColorName string ThemeColorName is used to look up a colour based on its name.\nSince: \r2.0\r"},{"id":215,"href":"/fyne/docs/api/themeiconname/","title":"fyne.ThemeIconName","section":"API Documentation","content":"fyne.ThemeIconName\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ThemeIconName\r#\r\rtype ThemeIconName string ThemeIconName is used to look up an icon based on its name.\nSince: \r2.0\r"},{"id":216,"href":"/fyne/docs/api/themesizename/","title":"fyne.ThemeSizeName","section":"API Documentation","content":"fyne.ThemeSizeName\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ThemeSizeName\r#\r\rtype ThemeSizeName string ThemeSizeName is used to look up a size based on its name.\nSince: \r2.0\r"},{"id":217,"href":"/fyne/docs/api/themevariant/","title":"fyne.ThemeVariant","section":"API Documentation","content":"fyne.ThemeVariant\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype ThemeVariant\r#\r\rtype ThemeVariant uint ThemeVariant indicates a variation of a theme, such as light or dark.\nSince: \r2.0\r"},{"id":218,"href":"/fyne/docs/api/uri/","title":"fyne.URI","section":"API Documentation","content":"fyne.URI\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype URI\r#\r\rtype URI interface { \tfmt.Stringer  \t// Extension should return the file extension of the resource \t// referenced by the URI. For example, the Extension() of \t// \u0026#39;file://foo/bar.baz\u0026#39; is \u0026#39;baz\u0026#39;. May return an empty string if the \t// referenced resource has none. \tExtension() string  \t// Name should return the base name of the item referenced by the URI. \t// For example, the Name() of \u0026#39;file://foo/bar.baz\u0026#39; is \u0026#39;bar.baz\u0026#39;. \tName() string  \t// MimeType should return the content type of the resource referenced \t// by the URI. The returned string should be in the format described \t// by Section 5 of RFC2045 (\u0026#34;Content-Type Header Field\u0026#34;). \tMimeType() string  \t// Scheme should return the URI scheme of the URI as defined by IETF \t// RFC3986. For example, the Scheme() of \u0026#39;file://foo/bar.baz` is \t// \u0026#39;file\u0026#39;. \t// \t// Scheme should always return the scheme in all lower-case characters. \tScheme() string  \t// Authority should return the URI authority, as defined by IETF \t// RFC3986. \t// \t// NOTE: the RFC3986 can be obtained by combining the User and Host \t// Fields of net/url\u0026#39;s URL structure. Consult IETF RFC3986, section \t// 3.2, pp. 17. \t// \t// Since: 2.0 \tAuthority() string  \t// Path should return the URI path, as defined by IETF RFC3986. \t// \t// Since: 2.0 \tPath() string  \t// Query should return the URI query, as defined by IETF RFC3986. \t// \t// Since: 2.0 \tQuery() string  \t// Fragment should return the URI fragment, as defined by IETF \t// RFC3986. \t// \t// Since: 2.0 \tFragment() string } URI represents the identifier of a resource on a target system. This resource may be a file or another data source such as an app or file sharing system.\nIn general, it is expected that URI implementations follow IETF RFC3896. Implementations are highly recommended to utilize net/url to implement URI parsing methods, especially Scheme(), AUthority(), Path(), Query(), and Fragment().\n"},{"id":219,"href":"/fyne/docs/api/urireadcloser/","title":"fyne.URIReadCloser","section":"API Documentation","content":"fyne.URIReadCloser\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype URIReadCloser\r#\r\rtype URIReadCloser interface { \tio.ReadCloser  \tURI() URI } URIReadCloser represents a cross platform data stream from a file or provider of data. It may refer to an item on a filesystem or data in another application that we have access to.\n"},{"id":220,"href":"/fyne/docs/api/uriwritecloser/","title":"fyne.URIWriteCloser","section":"API Documentation","content":"fyne.URIWriteCloser\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype URIWriteCloser\r#\r\rtype URIWriteCloser interface { \tio.WriteCloser  \tURI() URI } URIWriteCloser represents a cross platform data writer for a file resource. This will normally refer to a local file resource.\n"},{"id":221,"href":"/fyne/docs/api/validatable/","title":"fyne.Validatable","section":"API Documentation","content":"fyne.Validatable\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Validatable\r#\r\rtype Validatable interface { \tValidate() error  \t// SetOnValidationChanged is used to set the callback that will be triggered when the validation state changes. \t// The function might be overwritten by a parent that cares about child validation (e.g. widget.Form). \tSetOnValidationChanged(func(error)) } Validatable is an interface for specifying if a widget is validatable.\nSince: \r1.4\r"},{"id":222,"href":"/fyne/docs/api/vector2/","title":"fyne.Vector2","section":"API Documentation","content":"fyne.Vector2\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Vector2\r#\r\rtype Vector2 interface { \tComponents() (float32, float32) \tIsZero() bool } Vector2 marks geometry types that can operate as a coordinate vector.\n"},{"id":223,"href":"/fyne/docs/api/widget/","title":"fyne.Widget","section":"API Documentation","content":"fyne.Widget\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Widget\r#\r\rtype Widget interface { \tCanvasObject  \t// CreateRenderer returns a new WidgetRenderer for this widget. \t// This should not be called by regular code, it is used internally to render a widget. \tCreateRenderer() WidgetRenderer } Widget defines the standard behaviours of any widget. This extends the CanvasObject - a widget behaves in the same basic way but will encapsulate many child objects to create the rendered widget.\n"},{"id":224,"href":"/fyne/docs/api/widgetrenderer/","title":"fyne.WidgetRenderer","section":"API Documentation","content":"fyne.WidgetRenderer\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype WidgetRenderer\r#\r\rtype WidgetRenderer interface { \t// Destroy is for internal use. \tDestroy() \t// Layout is a hook that is called if the widget needs to be laid out. \t// This should never call Refresh. \tLayout(Size) \t// MinSize returns the minimum size of the widget that is rendered by this renderer. \tMinSize() Size \t// Objects returns all objects that should be drawn. \tObjects() []CanvasObject \t// Refresh is a hook that is called if the widget has updated and needs to be redrawn. \t// This might trigger a Layout. \tRefresh() } WidgetRenderer defines the behaviour of a widget\u0026rsquo;s implementation. This is returned from a widget\u0026rsquo;s declarative object through the CreateRenderer() function and should be exactly one instance per widget in memory.\n"},{"id":225,"href":"/fyne/docs/api/window/","title":"fyne.Window","section":"API Documentation","content":"fyne.Window\r#\r\r import \u0026#34;fyne.io/fyne/v2\u0026#34; Usage\r#\r\rtype Window\r#\r\rtype Window interface { \t// Title returns the current window title. \t// This is typically displayed in the window decorations. \tTitle() string \t// SetTitle updates the current title of the window. \tSetTitle(string)  \t// FullScreen returns whether or not this window is currently full screen. \tFullScreen() bool \t// SetFullScreen changes the requested fullScreen property \t// true for a fullScreen window and false to unset this. \tSetFullScreen(bool)  \t// Resize this window to the requested content size. \t// The result may not be exactly as desired due to various desktop or \t// platform constraints. \tResize(Size)  \t// RequestFocus attempts to raise and focus this window. \t// This should only be called when you are sure the user would want this window \t// to steal focus from any current focused window. \tRequestFocus()  \t// FixedSize returns whether or not this window should disable resizing. \tFixedSize() bool \t// SetFixedSize sets a hint that states whether the window should be a fixed \t// size or allow resizing. \tSetFixedSize(bool)  \t// CenterOnScreen places a window at the center of the monitor \t// the Window object is currently positioned on. \tCenterOnScreen()  \t// Padded, normally true, states whether the window should have inner \t// padding so that components do not touch the window edge. \tPadded() bool \t// SetPadded allows applications to specify that a window should have \t// no inner padding. Useful for fullscreen or graphic based applications. \tSetPadded(bool)  \t// Icon returns the window icon, this is used in various ways \t// depending on operating system. \t// Most commonly this is displayed on the window border or task switcher. \tIcon() Resource  \t// SetIcon sets the icon resource used for this window. \t// If none is set should return the application icon. \tSetIcon(Resource)  \t// SetMaster indicates that closing this window should exit the app \tSetMaster()  \t// MainMenu gets the content of the window\u0026#39;s top level menu. \tMainMenu() *MainMenu  \t// SetMainMenu adds a top level menu to this window. \t// The way this is rendered will depend on the loaded driver. \tSetMainMenu(*MainMenu)  \t// SetOnClosed sets a function that runs when the window is closed. \tSetOnClosed(func())  \t// SetCloseIntercept sets a function that runs instead of closing if defined. \t// Close() should be called explicitly in the interceptor to close the window. \t// \t// Since: 1.4 \tSetCloseIntercept(func())  \t// Show the window on screen. \tShow() \t// Hide the window from the user. \t// This will not destroy the window or cause the app to exit. \tHide() \t// Close the window. \t// If it is the only open window, or the \u0026#34;master\u0026#34; window the app will Quit. \tClose()  \t// ShowAndRun is a shortcut to show the window and then run the application. \t// This should be called near the end of a main() function as it will block. \tShowAndRun()  \t// Content returns the content of this window. \tContent() CanvasObject \t// SetContent sets the content of this window. \tSetContent(CanvasObject) \t// Canvas returns the canvas context to render in the window. \t// This can be useful to set a key handler for the window, for example. \tCanvas() Canvas  \t// Clipboard returns the system clipboard \tClipboard() Clipboard } Window describes a user interface window. Depending on the platform an app may have many windows or just the one.\n"},{"id":226,"href":"/fyne/docs/api/layout/","title":"layout","section":"API Documentation","content":"\r\rlayout\r\rlayout\r#\rimport \u0026#34;fyne.io/fyne/v2/layout\u0026#34; Package layout defines the various layouts available to Fyne apps Usage\r#\rfunc NewAdaptiveGridLayout\r#\rfunc NewAdaptiveGridLayout(rowcols int) fyne.Layout NewAdaptiveGridLayout returns a new grid layout which uses columns when horizontal but rows when vertical. func NewBorderLayout\r#\rfunc NewBorderLayout(top, bottom, left, right fyne.CanvasObject) fyne.Layout NewBorderLayout creates a new BorderLayout instance with top, bottom, left and right objects set. All other items in the container will fill the centre space\r\r\rlayout.Spacer\r\rlayout.Spacer\r#\rimport \u0026#34;fyne.io/fyne/v2/layout\u0026#34; Usage\r#\rtype Spacer\r#\rtype Spacer struct { FixHorizontal bool FixVertical bool } Spacer is any simple object that can be used in a box layout to space out child objects func (*Spacer) ExpandHorizontal\r#\rfunc (s *Spacer) ExpandHorizontal() bool ExpandHorizontal returns whether or not this spacer expands on the horizontal axis func (*Spacer) ExpandVertical\r#\rfunc (s *Spacer) ExpandVertical() bool ExpandVertical returns whether or not this spacer expands on the vertical axis\r\r\rlayout.SpacerObject\r\rlayout.SpacerObject\r#\rimport \u0026#34;fyne.io/fyne/v2/layout\u0026#34; Usage\r#\rtype SpacerObject\r#\rtype SpacerObject interface { ExpandVertical() bool ExpandHorizontal() bool } SpacerObject is any object that can be used to space out child objects\r\r\r"},{"id":227,"href":"/fyne/docs/api/layout/","title":"layout","section":"layout","content":"layout\r#\r\r import \u0026#34;fyne.io/fyne/v2/layout\u0026#34; Package layout defines the various layouts available to Fyne apps\nUsage\r#\r\rfunc NewAdaptiveGridLayout\r#\r\rfunc NewAdaptiveGridLayout(rowcols int) fyne.Layout NewAdaptiveGridLayout returns a new grid layout which uses columns when horizontal but rows when vertical.\nfunc NewBorderLayout\r#\r\rfunc NewBorderLayout(top, bottom, left, right fyne.CanvasObject) fyne.Layout NewBorderLayout creates a new BorderLayout instance with top, bottom, left and right objects set. All other items in the container will fill the centre space\nfunc NewCenterLayout\r#\r\rfunc NewCenterLayout() fyne.Layout NewCenterLayout creates a new CenterLayout instance\nfunc NewFormLayout\r#\r\rfunc NewFormLayout() fyne.Layout NewFormLayout returns a new FormLayout instance\nfunc NewGridLayout\r#\r\rfunc NewGridLayout(cols int) fyne.Layout NewGridLayout returns a grid layout arranged in a specified number of columns. The number of rows will depend on how many children are in the container that uses this layout.\nfunc NewGridLayoutWithColumns\r#\r\rfunc NewGridLayoutWithColumns(cols int) fyne.Layout NewGridLayoutWithColumns returns a new grid layout that specifies a column count and wrap to new rows when needed.\nfunc NewGridLayoutWithRows\r#\r\rfunc NewGridLayoutWithRows(rows int) fyne.Layout NewGridLayoutWithRows returns a new grid layout that specifies a row count that creates new rows as required.\nfunc NewGridWrapLayout\r#\r\rfunc NewGridWrapLayout(size fyne.Size) fyne.Layout NewGridWrapLayout returns a new GridWrapLayout instance\nfunc NewHBoxLayout\r#\r\rfunc NewHBoxLayout() fyne.Layout NewHBoxLayout returns a horizontal box layout for stacking a number of child canvas objects or widgets left to right.\nfunc NewMaxLayout\r#\r\rfunc NewMaxLayout() fyne.Layout NewMaxLayout creates a new MaxLayout instance\nfunc NewPaddedLayout\r#\r\rfunc NewPaddedLayout() fyne.Layout NewPaddedLayout creates a new PaddedLayout instance\nSince: \r1.4\rfunc NewSpacer\r#\r\rfunc NewSpacer() fyne.CanvasObject NewSpacer returns a spacer object which can fill vertical and horizontal space. This is primarily used with a box layout.\nfunc NewVBoxLayout\r#\r\rfunc NewVBoxLayout() fyne.Layout NewVBoxLayout returns a vertical box layout for stacking a number of child canvas objects or widgets top to bottom.\ntypes\r#\r\r \rSpacer \rSpacerObject  "},{"id":228,"href":"/fyne/docs/api/layout/spacer/","title":"layout.Spacer","section":"layout","content":"layout.Spacer\r#\r\r import \u0026#34;fyne.io/fyne/v2/layout\u0026#34; Usage\r#\r\rtype Spacer\r#\r\rtype Spacer struct { \tFixHorizontal bool \tFixVertical bool } Spacer is any simple object that can be used in a box layout to space out child objects\nfunc (*Spacer) ExpandHorizontal\r#\r\rfunc (s *Spacer) ExpandHorizontal() bool ExpandHorizontal returns whether or not this spacer expands on the horizontal axis\nfunc (*Spacer) ExpandVertical\r#\r\rfunc (s *Spacer) ExpandVertical() bool ExpandVertical returns whether or not this spacer expands on the vertical axis\nfunc (*Spacer) Hide\r#\r\rfunc (s *Spacer) Hide() Hide removes this Spacer from layout calculations\nfunc (*Spacer) MinSize\r#\r\rfunc (s *Spacer) MinSize() fyne.Size MinSize returns a 0 size as a Spacer can shrink to no actual size\nfunc (*Spacer) Move\r#\r\rfunc (s *Spacer) Move(pos fyne.Position) Move sets a new position for the Spacer - this will be called by the layout\nfunc (*Spacer) Position\r#\r\rfunc (s *Spacer) Position() fyne.Position Position returns the current position of this Spacer\nfunc (*Spacer) Refresh\r#\r\rfunc (s *Spacer) Refresh() Refresh does nothing for a spacer but is part of the CanvasObject definition\nfunc (*Spacer) Resize\r#\r\rfunc (s *Spacer) Resize(size fyne.Size) Resize sets a new size for the Spacer - this will be called by the layout\nfunc (*Spacer) Show\r#\r\rfunc (s *Spacer) Show() Show sets the Spacer to be part of the layout calculations\nfunc (*Spacer) Size\r#\r\rfunc (s *Spacer) Size() fyne.Size Size returns the current size of this Spacer\nfunc (*Spacer) Visible\r#\r\rfunc (s *Spacer) Visible() bool Visible returns true if this spacer should affect the layout\n"},{"id":229,"href":"/fyne/docs/api/layout/spacerobject/","title":"layout.SpacerObject","section":"layout","content":"layout.SpacerObject\r#\r\r import \u0026#34;fyne.io/fyne/v2/layout\u0026#34; Usage\r#\r\rtype SpacerObject\r#\r\rtype SpacerObject interface { \tExpandVertical() bool \tExpandHorizontal() bool } SpacerObject is any object that can be used to space out child objects\n"},{"id":230,"href":"/fyne/docs/api/driver/mobile/","title":"mobile","section":"driver","content":"\r\rmobile\r\rmobile\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Package mobile provides mobile specific driver functionality. Usage\r#\rtypes\r#\rDevice KeyboardType Keyboardable TouchEvent Touchable \r\rmobile.Device\r\rmobile.Device\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\rtype Device\r#\rtype Device interface { // Request that the mobile device show the touch screen keyboard (standard layout) ShowVirtualKeyboard() // Request that the mobile device show the touch screen keyboard (custom layout) ShowVirtualKeyboardType(KeyboardType) // Request that the mobile device dismiss the touch screen keyboard HideVirtualKeyboard() } Device describes functionality only available on mobile\r\r\rmobile.Keyboardable\r\rmobile.Keyboardable\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\rtype Keyboardable\r#\rtype Keyboardable interface { fyne.Focusable Keyboard() KeyboardType } Keyboardable describes any CanvasObject that needs a keyboard\r\r\rmobile.KeyboardType\r\rmobile.KeyboardType\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\rtype KeyboardType\r#\rtype KeyboardType int32 KeyboardType represents a type of virtual keyboard const ( // DefaultKeyboard is the keyboard with default input style and \u0026#34;return\u0026#34; return key DefaultKeyboard KeyboardType = iota // SingleLineKeyboard is the keyboard with default input style and \u0026#34;Done\u0026#34; return key SingleLineKeyboard // NumberKeyboard is the keyboard with number input style and \u0026#34;Done\u0026#34; return key NumberKeyboard // PasswordKeyboard is used to ensure that text is not leaked to 3rd party keyboard providers PasswordKeyboard ) \r\rmobile.Touchable\r\rmobile.Touchable\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\rtype Touchable\r#\rtype Touchable interface { TouchDown(*TouchEvent) TouchUp(*TouchEvent) TouchCancel(*TouchEvent) } Touchable represents mobile touch events that can be sent to CanvasObjects\r\r\rmobile.TouchEvent\r\rmobile.TouchEvent\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\rtype TouchEvent\r#\rtype TouchEvent struct { fyne.PointEvent } TouchEvent contains data relating to mobile touch events\r\r\r"},{"id":231,"href":"/fyne/docs/api/driver/mobile/","title":"mobile","section":"mobile","content":"mobile\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Package mobile provides mobile specific driver functionality.\nUsage\r#\r\rtypes\r#\r\r \rDevice \rKeyboardType \rKeyboardable \rTouchEvent \rTouchable  "},{"id":232,"href":"/fyne/docs/api/driver/mobile/device/","title":"mobile.Device","section":"mobile","content":"mobile.Device\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\r\rtype Device\r#\r\rtype Device interface { \t// Request that the mobile device show the touch screen keyboard (standard layout) \tShowVirtualKeyboard() \t// Request that the mobile device show the touch screen keyboard (custom layout) \tShowVirtualKeyboardType(KeyboardType) \t// Request that the mobile device dismiss the touch screen keyboard \tHideVirtualKeyboard() } Device describes functionality only available on mobile\n"},{"id":233,"href":"/fyne/docs/api/driver/mobile/keyboardable/","title":"mobile.Keyboardable","section":"mobile","content":"mobile.Keyboardable\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\r\rtype Keyboardable\r#\r\rtype Keyboardable interface { \tfyne.Focusable  \tKeyboard() KeyboardType } Keyboardable describes any CanvasObject that needs a keyboard\n"},{"id":234,"href":"/fyne/docs/api/driver/mobile/keyboardtype/","title":"mobile.KeyboardType","section":"mobile","content":"mobile.KeyboardType\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\r\rtype KeyboardType\r#\r\rtype KeyboardType int32 KeyboardType represents a type of virtual keyboard\nconst ( \t// DefaultKeyboard is the keyboard with default input style and \u0026#34;return\u0026#34; return key \tDefaultKeyboard KeyboardType = iota \t// SingleLineKeyboard is the keyboard with default input style and \u0026#34;Done\u0026#34; return key \tSingleLineKeyboard \t// NumberKeyboard is the keyboard with number input style and \u0026#34;Done\u0026#34; return key \tNumberKeyboard \t// PasswordKeyboard is used to ensure that text is not leaked to 3rd party keyboard providers \tPasswordKeyboard ) "},{"id":235,"href":"/fyne/docs/api/driver/mobile/touchable/","title":"mobile.Touchable","section":"mobile","content":"mobile.Touchable\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\r\rtype Touchable\r#\r\rtype Touchable interface { \tTouchDown(*TouchEvent) \tTouchUp(*TouchEvent) \tTouchCancel(*TouchEvent) } Touchable represents mobile touch events that can be sent to CanvasObjects\n"},{"id":236,"href":"/fyne/docs/api/driver/mobile/touchevent/","title":"mobile.TouchEvent","section":"mobile","content":"mobile.TouchEvent\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; Usage\r#\r\rtype TouchEvent\r#\r\rtype TouchEvent struct { \tfyne.PointEvent } TouchEvent contains data relating to mobile touch events\n"},{"id":237,"href":"/fyne/docs/api/storage/repository/","title":"repository","section":"storage","content":"\r\rrepository.CopyableRepository\u0026#34;\r\rrepository.CopyableRepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype CopyableRepository\r#\rtype CopyableRepository interface { Repository // Copy will be used to implement calls to storage.Copy() for the // registered scheme of this repository. // // A generic implementation is provided by GenericCopy(). // // NOTE: the first parameter is the source, the second is the // destination. // // NOTE: if storage.\r\r\rrepository.CustomURIRepository\u0026#34;\r\rrepository.CustomURIRepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype CustomURIRepository\r#\rtype CustomURIRepository interface { Repository // ParseURI will be used to implement calls to storage.ParseURI() // for the registered scheme of this repository. ParseURI(string) (fyne.URI, error) } CustomURIRepository is an extension of the repository interface which allows the behavior of storage.ParseURI to be overridden. This is only needed if you wish to generate custom URI types, rather than using Fyne\u0026rsquo;s URI implementation and net/url based parsing.\r\r\rrepository.HierarchicalRepository\u0026#34;\r\rrepository.HierarchicalRepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype HierarchicalRepository\r#\rtype HierarchicalRepository interface { Repository // Parent will be used to implement calls to storage.Parent() for the // registered scheme of this repository. // // A generic implementation is provided in GenericParent(), which // is based on the RFC3986 definition of a URI parent. // // Since: 2.0 Parent(fyne.\r\r\rrepository.ListableRepository\u0026#34;\r\rrepository.ListableRepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype ListableRepository\r#\rtype ListableRepository interface { Repository // CanList will be used to implement calls to storage.Listable() for // the registered scheme of this repository. // // Since: 2.0 CanList(u fyne.URI) (bool, error) // List will be used to implement calls to storage.List() for the // registered scheme of this repository.\r\r\rrepository.MovableRepository\u0026#34;\r\rrepository.MovableRepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype MovableRepository\r#\rtype MovableRepository interface { Repository // Move will be used to implement calls to storage.Move() for the // registered scheme of this repository. // // A generic implementation is provided by GenericMove(). // // NOTE: the first parameter is the source, the second is the // destination. // // NOTE: if storage.\r\r\rrepository.Repository\u0026#34;\r\rrepository.Repository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype Repository\r#\rtype Repository interface { // Exists will be used to implement calls to storage.Exists() for the // registered scheme of this repository. // // Since: 2.0 Exists(u fyne.URI) (bool, error) // Reader will be used to implement calls to storage.Reader() // for the registered scheme of this repository. // // Since: 2.\r\r\rrepository.WritableRepository\u0026#34;\r\rrepository.WritableRepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype WritableRepository\r#\rtype WritableRepository interface { Repository // Writer will be used to implement calls to storage.WriterTo() for // the registered scheme of this repository. // // Since: 2.0 Writer(u fyne.URI) (fyne.URIWriteCloser, error) // CanWrite will be used to implement calls to storage.CanWrite() for // the registered scheme of this repository.\r\r\rrepository\u0026#34;\r\rrepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rvar ( // ErrOperationNotSupported may be thrown by certain functions in the storage // or repository packages which operate on URIs if an operation is attempted // that is not supported for the scheme relevant to the URI, normally because // the underlying repository has either not implemented the relevant function, // or has explicitly returned this error.\r\r\r"},{"id":238,"href":"/fyne/docs/api/storage/repository/copyablerepository/","title":"repository.CopyableRepository\"","section":"repository","content":"repository.CopyableRepository\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\r\rtype CopyableRepository\r#\r\rtype CopyableRepository interface { \tRepository  \t// Copy will be used to implement calls to storage.Copy() for the \t// registered scheme of this repository. \t// \t// A generic implementation is provided by GenericCopy(). \t// \t// NOTE: the first parameter is the source, the second is the \t// destination. \t// \t// NOTE: if storage.Copy() is given two URIs of different schemes, it \t// is possible that only the source URI will be of the type this \t// repository is registered to handle. In such cases, implementations \t// are suggested to fail-over to GenericCopy(). \t// \t// Since: 2.0 \tCopy(fyne.URI, fyne.URI) error } CopyableRepository is an extension of the Repository interface which also supports copying referenced resources from one URI to another.\nSince: \r2.0\r"},{"id":239,"href":"/fyne/docs/api/storage/repository/customurirepository/","title":"repository.CustomURIRepository\"","section":"repository","content":"repository.CustomURIRepository\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\r\rtype CustomURIRepository\r#\r\rtype CustomURIRepository interface { \tRepository  \t// ParseURI will be used to implement calls to storage.ParseURI() \t// for the registered scheme of this repository. \tParseURI(string) (fyne.URI, error) } CustomURIRepository is an extension of the repository interface which allows the behavior of storage.ParseURI to be overridden. This is only needed if you wish to generate custom URI types, rather than using Fyne\u0026rsquo;s URI implementation and net/url based parsing.\nNOTE: even for URIs with non-RFC3986-compliant encoding, the URI MUST begin with \u0026lsquo;scheme:\u0026rsquo;, or storage.ParseURI() will not be able to determine which storage repository to delegate to for parsing.\nSince: \r2.0\r"},{"id":240,"href":"/fyne/docs/api/storage/repository/hierarchicalrepository/","title":"repository.HierarchicalRepository\"","section":"repository","content":"repository.HierarchicalRepository\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\r\rtype HierarchicalRepository\r#\r\rtype HierarchicalRepository interface { \tRepository  \t// Parent will be used to implement calls to storage.Parent() for the \t// registered scheme of this repository. \t// \t// A generic implementation is provided in GenericParent(), which \t// is based on the RFC3986 definition of a URI parent. \t// \t// Since: 2.0 \tParent(fyne.URI) (fyne.URI, error)  \t// Child will be used to implement calls to storage.Child() for \t// the registered scheme of this repository. \t// \t// A generic implementation is provided in GenericParent(), which \t// is based on RFC3986. \t// \t// Since: 2.0 \tChild(fyne.URI, string) (fyne.URI, error) } HierarchicalRepository is an extension of the Repository interface which also supports determining the parent and child items of a URI.\nSince: \r2.0\r"},{"id":241,"href":"/fyne/docs/api/storage/repository/listablerepository/","title":"repository.ListableRepository\"","section":"repository","content":"repository.ListableRepository\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\r\rtype ListableRepository\r#\r\rtype ListableRepository interface { \tRepository  \t// CanList will be used to implement calls to storage.Listable() for \t// the registered scheme of this repository. \t// \t// Since: 2.0 \tCanList(u fyne.URI) (bool, error)  \t// List will be used to implement calls to storage.List() for the \t// registered scheme of this repository. \t// \t// Since: 2.0 \tList(u fyne.URI) ([]fyne.URI, error)  \t// CreateListable will be used to implement calls to \t// storage.CreateListable() for the registered scheme of this \t// repository. \t// \t// Since: 2.0 \tCreateListable(u fyne.URI) error } ListableRepository is an extension of the Repository interface which also supports obtaining directory listings (generally analogous to a directory listing) for URIs of the scheme it is registered to.\nSince: \r2.0\r"},{"id":242,"href":"/fyne/docs/api/storage/repository/movablerepository/","title":"repository.MovableRepository\"","section":"repository","content":"repository.MovableRepository\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\r\rtype MovableRepository\r#\r\rtype MovableRepository interface { \tRepository  \t// Move will be used to implement calls to storage.Move() for the \t// registered scheme of this repository. \t// \t// A generic implementation is provided by GenericMove(). \t// \t// NOTE: the first parameter is the source, the second is the \t// destination. \t// \t// NOTE: if storage.Move() is given two URIs of different schemes, it \t// is possible that only the source URI will be of the type this \t// repository is registered to handle. In such cases, implementations \t// are suggested to fail-over to GenericMove(). \t// \t// Since: 2.0 \tMove(fyne.URI, fyne.URI) error } MovableRepository is an extension of the Repository interface which also supports moving referenced resources from one URI to another.\nNote: both Moveable and Movable are correct spellings, but Movable is newer and more accepted. Source: https://grammarist.com/spelling/movable-moveable/\nSince: \r2.0\r"},{"id":243,"href":"/fyne/docs/api/storage/repository/repository/","title":"repository.Repository\"","section":"repository","content":"repository.Repository\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\r\rtype Repository\r#\r\rtype Repository interface {  \t// Exists will be used to implement calls to storage.Exists() for the \t// registered scheme of this repository. \t// \t// Since: 2.0 \tExists(u fyne.URI) (bool, error)  \t// Reader will be used to implement calls to storage.Reader() \t// for the registered scheme of this repository. \t// \t// Since: 2.0 \tReader(u fyne.URI) (fyne.URIReadCloser, error)  \t// CanRead will be used to implement calls to storage.CanRead() for the \t// registered scheme of this repository. \t// \t// Since: 2.0 \tCanRead(u fyne.URI) (bool, error)  \t// Destroy is called when the repository is un-registered from a given \t// URI scheme. \t// \t// The string parameter will be the URI scheme that the repository was \t// registered for. This may be useful for repositories that need to \t// handle more than one URI scheme internally. \t// \t// Since: 2.0 \tDestroy(string) } Repository represents a storage repository, which is a set of methods which implement specific functions on a URI. Repositories are registered to handle specific URI schemes, and the higher-level functions that operate on URIs internally look up an appropriate method from the relevant Repository.\nThe repository interface includes only methods which must be implemented at a minimum. Without implementing all of the methods in this interface, a URI would not be usable in a useful way. Additional functionality can be exposed by using interfaces which extend Repository.\nRepositories are registered to handle a specific URI scheme (or schemes) using the Register() method. When a higher-level URI function such as storage.Copy() is called, the storage package will internally look up the repository associated with the scheme of the URI, then it will use a type assertion to check if the repository implements CopyableRepository. If so, the Copy() function will be run from the repository, otherwise storage.Copy() will return NotSupportedError. This works similarly for all other methods in repository-related interfaces.\nNote that a repository can be registered for multiple URI schemes. In such cases, the repository must internally select and implement the correct behavior for each URI scheme.\nA repository will only ever need to handle URIs with schemes for which it was registered, with the exception that functions with more than 1 operand such as Copy() and Move(), in which cases only the first operand is guaranteed to match a scheme for which the repository is registered.\nNOTE: most developers who use Fyne should not generally attempt to call repository methods directly. You should use the methods in the storage package, which will automatically detect the scheme of a URI and call into the appropriate repository.\nSince: \r2.0\rfunc ForScheme\r#\r\rfunc ForScheme(scheme string) (Repository, error) ForScheme returns the Repository instance which is registered to handle URIs of the given scheme.\nNOTE: this function is intended to be used specifically by the storage package. It generally should not be used outside of the fyne package - instead you should use the methods in the storage package.\nSince: \r2.0\rfunc ForURI\r#\r\rfunc ForURI(u fyne.URI) (Repository, error) ForURI returns the Repository instance which is registered to handle URIs of the given scheme. This is a helper method that calls ForScheme() on the scheme of the given URI.\nNOTE: this function is intended to be used specifically by the storage package. It generally should not be used outside of the fyne package - instead you should use the methods in the storage package.\nSince: \r2.0\r"},{"id":244,"href":"/fyne/docs/api/storage/repository/writablerepository/","title":"repository.WritableRepository\"","section":"repository","content":"repository.WritableRepository\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\r\rtype WritableRepository\r#\r\rtype WritableRepository interface { \tRepository  \t// Writer will be used to implement calls to storage.WriterTo() for \t// the registered scheme of this repository. \t// \t// Since: 2.0 \tWriter(u fyne.URI) (fyne.URIWriteCloser, error)  \t// CanWrite will be used to implement calls to storage.CanWrite() for \t// the registered scheme of this repository. \t// \t// Since: 2.0 \tCanWrite(u fyne.URI) (bool, error)  \t// Delete will be used to implement calls to storage.Delete() for the \t// registered scheme of this repository. \t// \t// Since: 2.0 \tDelete(u fyne.URI) error } WritableRepository is an extension of the Repository interface which also supports obtaining a writer for URIs of the scheme it is registered to.\nSince: \r2.0\r"},{"id":245,"href":"/fyne/docs/api/storage/repository/","title":"repository\"","section":"repository","content":"repository\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\r\rvar ( \t// ErrOperationNotSupported may be thrown by certain functions in the storage \t// or repository packages which operate on URIs if an operation is attempted \t// that is not supported for the scheme relevant to the URI, normally because \t// the underlying repository has either not implemented the relevant function, \t// or has explicitly returned this error. \t// \t// Since: 2.0 \tErrOperationNotSupported = errors.New(\u0026#34;operation not supported for this URI\u0026#34;)  \t// ErrURIRoot should be thrown by fyne.URI implementations when the caller \t// attempts to take the parent of the root. This way, downstream code that \t// wants to programmatically walk up a URIs parent\u0026#39;s will know when to stop \t// iterating. \t// \t// Since: 2.0 \tErrURIRoot = errors.New(\u0026#34;cannot take the parent of the root element in a URI\u0026#34;) ) func GenericChild\r#\r\rfunc GenericChild(u fyne.URI, component string) (fyne.URI, error) GenericChild can be used as a common-case implementation of HierarchicalRepository.Child(). It will create a child URI by separating the URI into it\u0026rsquo;s component parts as described in IETF RFC 3986, then appending \u0026ldquo;/\u0026rdquo; + component to the path, then concatenating the result and parsing it as a new URI.\nNOTE: this function should not be called except by an implementation of the Repository interface - using this for unknown URIs may break.\nSince: \r2.0\rfunc GenericCopy\r#\r\rfunc GenericCopy(source fyne.URI, destination fyne.URI) error GenericCopy can be used a common-case implementation of CopyableRepository.Copy(). It will perform the copy by obtaining a reader for the source URI, a writer for the destination URI, then writing the contents of the source to the destination.\nFor obvious reasons, the destination URI must have a registered WritableRepository.\nNOTE: this function should not be called except by an implementation of the Repository interface - using this for unknown URIs may break.\nSince: \r2.0\rfunc GenericMove\r#\r\rfunc GenericMove(source fyne.URI, destination fyne.URI) error GenericMove can be used a common-case implementation of MovableRepository.Move(). It will perform the move by obtaining a reader for the source URI, a writer for the destination URI, then writing the contents of the source to the destination. Following this, the source will be deleted using WritableRepository.Delete.\nFor obvious reasons, the source and destination URIs must both be writable.\nNOTE: this function should not be called except by an implementation of the Repository interface - using this for unknown URIs may break.\nSince: \r2.0\rfunc GenericParent\r#\r\rfunc GenericParent(u fyne.URI) (fyne.URI, error) GenericParent can be used as a common-case implementation of HierarchicalRepository.Parent(). It will create a parent URI based on IETF RFC3986.\nIn short, the URI is separated into it\u0026rsquo;s component parts, the path component is split along instances of \u0026lsquo;/\u0026rsquo;, and the trailing element is removed. The result is concatenated and parsed as a new URI.\nIf the URI path is empty or \u0026lsquo;/\u0026rsquo;, then a nil URI is returned, along with ErrURIRoot.\nNOTE: this function should not be called except by an implementation of the Repository interface - using this for unknown URIs may break.\nSince: \r2.0\rfunc NewFileURI\r#\r\rfunc NewFileURI(path string) fyne.URI NewFileURI implements the back-end logic to storage.NewFileURI, which you should use instead. This is only here because other functions in repository need to call it, and it prevents a circular import.\nSince: \r2.0\rfunc ParseURI\r#\r\rfunc ParseURI(s string) (fyne.URI, error) ParseURI implements the back-end logic for storage.ParseURI, which you should use instead. This is only here because other functions in repository need to call it, and it prevents a circular import.\nSince: \r2.0\rfunc Register\r#\r\rfunc Register(scheme string, repository Repository) Register registers a storage repository so that operations on URIs of the registered scheme will use methods implemented by the relevant repository implementation.\nSince: \r2.0\rtypes\r#\r\r \rCopyableRepository \rCustomURIRepository \rHierarchicalRepository \rListableRepository \rMovableRepository \rRepository \rWritableRepository  "},{"id":246,"href":"/fyne/docs/api/driver/software/","title":"software","section":"driver","content":"\r\rsoftware\r\rsoftware\r#\rimport \u0026#34;fyne.io/fyne/v2/driver/software\u0026#34; Usage\r#\rfunc NewCanvas\r#\rfunc NewCanvas() test.WindowlessCanvas NewCanvas creates a new canvas in memory that can render without hardware support func Render\r#\rfunc Render(obj fyne.CanvasObject, t fyne.Theme) image.Image Render takes a canvas object and renders it to a regular Go image using the provided Theme. The returned image will be set to the object\u0026rsquo;s minimum size. Use the theme.LightTheme() or theme.\r\r\r"},{"id":247,"href":"/fyne/docs/api/driver/software/","title":"software","section":"software","content":"software\r#\r\r import \u0026#34;fyne.io/fyne/v2/driver/software\u0026#34; Usage\r#\r\rfunc NewCanvas\r#\r\rfunc NewCanvas() test.WindowlessCanvas NewCanvas creates a new canvas in memory that can render without hardware support\nfunc Render\r#\r\rfunc Render(obj fyne.CanvasObject, t fyne.Theme) image.Image Render takes a canvas object and renders it to a regular Go image using the provided Theme. The returned image will be set to the object\u0026rsquo;s minimum size. Use the theme.LightTheme() or theme.DarkTheme() to access the builtin themes.\nfunc RenderCanvas\r#\r\rfunc RenderCanvas(c fyne.Canvas, t fyne.Theme) image.Image RenderCanvas takes a canvas and renders it to a regular Go image using the provided Theme. This is the same as setting the application theme and then calling Canvas.Capture().\ntypes\r#\r\r"},{"id":248,"href":"/fyne/docs/api/storage/","title":"storage","section":"API Documentation","content":"\r\rrepository\r\rrepository.CopyableRepository\u0026#34;\rrepository.CopyableRepository\r#\rimport \u0026#34;fyne.io/fyne/v2/storage/repository\u0026#34; Usage\r#\rtype CopyableRepository\r#\rtype CopyableRepository interface { Repository // Copy will be used to implement calls to storage.Copy() for the // registered scheme of this repository. // // A generic implementation is provided by GenericCopy(). // // NOTE: the first parameter is the source, the second is the // destination. // // NOTE: if storage.\rrepository.CustomURIRepository\u0026#34;\rrepository.CustomURIRepository\r#\rimport \u0026#34;fyne.\r\r\rstorage\r\rstorage\r#\rimport \u0026#34;fyne.io/fyne/v2/storage\u0026#34; Package storage provides storage access and management functionality. Usage\r#\rvar URIRootError = repository.ErrURIRoot URIRootError is a wrapper for repository.URIRootError Deprecated - use repository.ErrURIRoot instead func CanList\r#\rfunc CanList(u fyne.URI) (bool, error) CanList will determine if the URI is listable or not. This method may fail in several ways: Different permissions or credentials are required to check if the URI supports listing.\r\r\rstorage.ExtensionFileFilter\r\rstorage.ExtensionFileFilter\r#\rimport \u0026#34;fyne.io/fyne/v2/storage\u0026#34; Usage\r#\rtype ExtensionFileFilter\r#\rtype ExtensionFileFilter struct { Extensions []string } ExtensionFileFilter represents a file filter based on the the ending of file names, for example \u0026ldquo;.txt\u0026rdquo; and \u0026ldquo;.png\u0026rdquo;. func (*ExtensionFileFilter) Matches\r#\rfunc (e *ExtensionFileFilter) Matches(uri fyne.URI) bool Matches returns true if a file URI has one of the filtered extensions.\r\r\rstorage.FileFilter\r\rstorage.FileFilter\r#\rimport \u0026#34;fyne.io/fyne/v2/storage\u0026#34; Usage\r#\rtype FileFilter\r#\rtype FileFilter interface { Matches(fyne.URI) bool } FileFilter is an interface that can be implemented to provide a filter to a file dialog. func NewExtensionFileFilter\r#\rfunc NewExtensionFileFilter(extensions []string) FileFilter NewExtensionFileFilter takes a string slice of extensions with a leading . and creates a filter for the file dialog. Example: .jpg, .mp3, .txt, .sh func NewMimeTypeFileFilter\r#\rfunc NewMimeTypeFileFilter(mimeTypes []string) FileFilter NewMimeTypeFileFilter takes a string slice of mimetypes, including globs, and creates a filter for the file dialog.\r\r\rstorage.MimeTypeFileFilter\r\rstorage.MimeTypeFileFilter\r#\rimport \u0026#34;fyne.io/fyne/v2/storage\u0026#34; Usage\r#\rtype MimeTypeFileFilter\r#\rtype MimeTypeFileFilter struct { MimeTypes []string } MimeTypeFileFilter represents a file filter based on the files mime type, for example \u0026ldquo;image/*\u0026rdquo;, \u0026ldquo;audio/mp3\u0026rdquo;. func (*MimeTypeFileFilter) Matches\r#\rfunc (mt *MimeTypeFileFilter) Matches(uri fyne.URI) bool Matches returns true if a file URI has one of the filtered mimetypes.\r\r\r"},{"id":249,"href":"/fyne/docs/api/storage/","title":"storage","section":"storage","content":"storage\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage\u0026#34; Package storage provides storage access and management functionality.\nUsage\r#\r\rvar URIRootError = repository.ErrURIRoot URIRootError is a wrapper for repository.URIRootError\nDeprecated - use repository.ErrURIRoot instead\nfunc CanList\r#\r\rfunc CanList(u fyne.URI) (bool, error) CanList will determine if the URI is listable or not.\nThis method may fail in several ways:\n Different permissions or credentials are required to check if the   URI supports listing.  This URI scheme could represent some resources that can be listed,   but this specific URI is not one of them (e.g. a file on a  filesystem, as opposed to a directory).  Checking for listability depended on a lower level operation   such as network or filesystem access that has failed in some way.  If the scheme of the given URI does not have a registered   ListableRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. CanList is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nSince: \r2.0\rfunc CanRead\r#\r\rfunc CanRead(u fyne.URI) (bool, error) CanRead determines if a given URI could be written to using the Reader() method. It is preferred to check if a URI is readable using this method before calling Reader(), because the underlying operations required to attempt to read and then report an error may be slower than the operations needed to test if a URI is readable. Keep in mind however that even if CanRead returns true, you must still do appropriate error handling for Reader(), as the underlying filesystem may have changed since you called CanRead.\nThe non-existence of a resource should not be treated as an error. In other words, a Repository implementation which for some URI u returns false, nil for Exists(u), CanRead(u) should also return false, nil.\nCanRead is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nSince: \r2.0\rfunc CanWrite\r#\r\rfunc CanWrite(u fyne.URI) (bool, error) CanWrite is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nSince: \r2.0\rfunc Child\r#\r\rfunc Child(u fyne.URI, component string) (fyne.URI, error) Child returns a URI referencing a resource nested hierarchically below the given URI, identified by a string. For example, the child with the string component \u0026lsquo;quux\u0026rsquo; of \u0026lsquo;file://foo/bar\u0026rsquo; is \u0026lsquo;file://foo/bar/quux\u0026rsquo;.\nThis can fail in several ways:\n If the URI refers to a resource which does not exist in a hierarchical   context (e.g. the URI references something which does not have a  semantically meaningful \u0026#34;child\u0026#34;), the Child() implementation may return an  error.  If generating a reference to a child of the referenced resource requires   interfacing with some external system, failures may propagate through the  Child() implementation. It is expected that this case would occur very  rarely if ever.  If the scheme of the given URI does not have a registered   HierarchicalRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. NOTE: since v2.0.0, Child() is backed by the repository system - this function is a helper which calls into an appropriate repository instance for the scheme of the URI it is given.\nSince: \r1.4\rfunc Copy\r#\r\rfunc Copy(source fyne.URI, destination fyne.URI) error Copy given two URIs, \u0026lsquo;src\u0026rsquo;, and \u0026lsquo;dest\u0026rsquo; both of the same scheme, will copy one to the other. If the source and destination are of different schemes, then the Copy implementation for the storage repository registered to the scheme of the source will be used. Implementations are recommended to use repository.GenericCopy() as a fail-over in the case that they do not understand how to operate on the scheme of the destination URI. However, the behavior of calling Copy() on URIs of non-matching schemes is ultimately defined by the storage repository registered to the scheme of the source URI.\nThis method may fail in several ways:\n Different permissions or credentials are required to perform the   copy operation.  This URI scheme could represent some resources that can be copied,   but either the source, destination, or both are not resources  that support copying.  Performing the copy operation depended on a lower level operation   such as network or filesystem access that has failed in some way.  If the scheme of the given URI does not have a registered   CopyableRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. Copy is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nSince: \r2.0\rfunc CreateListable\r#\r\rfunc CreateListable(u fyne.URI) error CreateListable creates a new listable resource referenced by the given URI. CreateListable will error if the URI already references an extant resource. This method is used for storage repositories where listable resources are of a different underlying type than other resources - for example, in a typical filesystem (\u0026lsquo;file://\u0026rsquo;), CreateListable() corresponds to directory creation, and Writer() implies file creation for non-extant operands.\nFor storage repositories where listable and non-listable resources are the of the same underlying type, CreateListable should be equivalent to calling Writer(), writing zero bytes, and then closing the `URIWriteCloser - in filesystem terms, the same as calling \u0026rsquo;touch;\u0026rsquo;.\nStorage repositories which support listing, but not creation of listable objects may return repository.ErrOperationNotSupported.\nCreateListable should generally fail if the parent of it\u0026rsquo;s operand does not exist, however this can vary by the implementation details of the specific storage repository. In filesystem terms, this function is \u0026ldquo;mkdir\u0026rdquo; not \u0026ldquo;mkdir -p\u0026rdquo;.\nThis method may fail in several ways:\n Different permissions or credentials are required to create the requested   resource.  Creating the resource depended on a lower level operation such as network   or filesystem access that has failed in some way.  If the scheme of the given URI does not have a registered   ListableRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. CreateListable is backed by the repository system - this function either calls into a scheme-specific implementation from a registered repository, or fails with a URIOperationNotSupported error.\nSince: \r2.0\rfunc Delete\r#\r\rfunc Delete(u fyne.URI) error Delete destroys, deletes, or otherwise removes the resource referenced by the URI.\nThis can fail in several ways:\n If removing the resource requires interfacing with some external system,   failures may propagate through Destroy(). For example, deleting a file may  fail with a permissions error.  If the referenced resource does not exist, attempting to destroy it should   throw an error.  If the scheme of the given URI does not have a registered   WritableRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. Delete is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nSince: \r2.0\rfunc Exists\r#\r\rfunc Exists(u fyne.URI) (bool, error) Exists determines if the resource referenced by the URI exists.\nThis can fail in several ways:\n If checking the existence of a resource requires interfacing with some   external system, then failures may propagate through Exists(). For  example, checking the existence of a resource requires reading a directory  may result in a permissions error. It is understood that a non-nil error value signals that the existence or non-existence of the resource cannot be determined and is undefined.\nNOTE: since v2.0.0, Exists is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nExists may call into either a generic implementation, or into a scheme-specific implementation depending on which storage repositories have been registered.\nSince: \r1.4\rfunc List\r#\r\rfunc List(u fyne.URI) ([]fyne.URI, error) List returns a list of URIs that reference resources which are nested below the resource referenced by the argument. For example, listing a directory on a filesystem should return a list of files and directories it contains.\nThis method may fail in several ways:\n Different permissions or credentials are required to obtain a   listing for the given URI.  This URI scheme could represent some resources that can be listed,   but this specific URI is not one of them (e.g. a file on a  filesystem, as opposed to a directory). This can be tested in advance  using the Listable() function.  Obtaining the listing depended on a lower level operation such as   network or filesystem access that has failed in some way.  If the scheme of the given URI does not have a registered   ListableRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. List is backed by the repository system - this function either calls into a scheme-specific implementation from a registered repository, or fails with a URIOperationNotSupported error.\nSince: \r2.0\rfunc ListerForURI\r#\r\rfunc ListerForURI(uri fyne.URI) (fyne.ListableURI, error) ListerForURI will attempt to use the application\u0026rsquo;s driver to convert a standard URI into a listable URI.\nSince: \r1.4\rfunc LoadResourceFromURI\r#\r\rfunc LoadResourceFromURI(u fyne.URI) (fyne.Resource, error) LoadResourceFromURI creates a new StaticResource in memory using the contents of the specified URI. The URI will be opened using the current driver, so valid schemas will vary from platform to platform. The file:// schema will always work.\nfunc Move\r#\r\rfunc Move(source fyne.URI, destination fyne.URI) error Move returns a method that given two URIs, \u0026lsquo;src\u0026rsquo; and \u0026lsquo;dest\u0026rsquo; both of the same scheme this will move src to dest. This means the resource referenced by src will be copied into the resource referenced by dest, and the resource referenced by src will no longer exist after the operation is complete.\nIf the source and destination are of different schemes, then the Move implementation for the storage repository registered to the scheme of the source will be used. Implementations are recommended to use repository.GenericMove() as a fail-over in the case that they do not understand how to operate on the scheme of the destination URI. However, the behavior of calling Move() on URIs of non-matching schemes is ultimately defined by the storage repository registered to the scheme of the source URI.\nThis method may fail in several ways:\n Different permissions or credentials are required to perform the   rename operation.  This URI scheme could represent some resources that can be renamed,   but either the source, destination, or both are not resources  that support renaming.  Performing the rename operation depended on a lower level operation   such as network or filesystem access that has failed in some way.  If the scheme of the given URI does not have a registered   MovableRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. Move is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nSince: \r2.0\rfunc NewFileURI\r#\r\rfunc NewFileURI(path string) fyne.URI NewFileURI creates a new URI from the given file path.\nfunc NewURI\r#\r\rfunc NewURI(s string) fyne.URI NewURI creates a new URI from the given string representation. This could be a URI from an external source or one saved from URI.String()\nDeprecated: use ParseURI instead\rfunc OpenFileFromURI\r#\r\rfunc OpenFileFromURI(uri fyne.URI) (fyne.URIReadCloser, error) OpenFileFromURI loads a file read stream from a resource identifier. This is mostly provided so that file references can be saved using their URI and loaded again later.\nDeprecated: this has been replaced by storage.Reader(URI)\rfunc Parent\r#\r\rfunc Parent(u fyne.URI) (fyne.URI, error) Parent returns a URI referencing the parent resource of the resource referenced by the URI. For example, the Parent() of \u0026lsquo;file://foo/bar.baz\u0026rsquo; is \u0026lsquo;file://foo\u0026rsquo;. The URI which is returned will be listable.\nNOTE: it is not a given that Parent() return a parent URI with the same Scheme(), though this will normally be the case.\nThis can fail in several ways:\n If the URI refers to a filesystem root, then the Parent() implementation   must return (nil, URIRootError).  If the URI refers to a resource which does not exist in a hierarchical   context (e.g. the URI references something which does not have a  semantically meaningful \u0026#34;parent\u0026#34;), the Parent() implementation may return  an error.  If determining the parent of the referenced resource requires   interfacing with some external system, failures may propagate  through the Parent() implementation. For example if determining  the parent of a file:// URI requires reading information from  the filesystem, it could fail with a permission error.  If the scheme of the given URI does not have a registered   HierarchicalRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. NOTE: since v2.0.0, Parent() is backed by the repository system - this function is a helper which calls into an appropriate repository instance for the scheme of the URI it is given.\nSince: \r1.4\rfunc ParseURI\r#\r\rfunc ParseURI(s string) (fyne.URI, error) ParseURI creates a new URI instance by parsing a URI string.\nParse URI will parse up to the first \u0026lsquo;:\u0026rsquo; present in the URI string to extract the scheme, and then delegate further parsing to the registered repository for the given scheme. If no repository is registered for that scheme, the URI is parsed on a best-effort basis using net/url.\nAs a special exception, URIs beginning with \u0026lsquo;file:\u0026rsquo; are always parsed using NewFileURI(), which will correctly handle back-slashes appearing in the URI path component on Windows.\nSince: \r2.0\rfunc Reader\r#\r\rfunc Reader(u fyne.URI) (fyne.URIReadCloser, error) Reader returns URIReadCloser set up to read from the resource that the URI references.\nThis method can fail in several ways:\n Different permissions or credentials are required to read the   referenced resource.  This URI scheme could represent some resources that can be read,   but this particular URI references a resources that is not  something that can be read.  Attempting to set up the reader depended on a lower level   operation such as a network or filesystem access that has failed  in some way. Reader is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nSince: \r2.0\rfunc SaveFileToURI\r#\r\rfunc SaveFileToURI(uri fyne.URI) (fyne.URIWriteCloser, error) SaveFileToURI loads a file write stream to a resource identifier. This is mostly provided so that file references can be saved using their URI and written to again later.\nDeprecated: this has been replaced by storage.Writer(URI)\rfunc Writer\r#\r\rfunc Writer(u fyne.URI) (fyne.URIWriteCloser, error) Writer returns URIWriteCloser set up to write to the resource that the URI references.\nWriting to a non-extant resource should create that resource if possible (and if not possible, this should be reflected in the return of CanWrite()). Writing to an extant resource should overwrite it in-place. At present, this API does not provide a mechanism for appending to an already-extant resource, except for reading it in and writing all the data back out.\nThis method can fail in several ways:\n Different permissions or credentials are required to write to the   referenced resource.  This URI scheme could represent some resources that can be   written, but this particular URI references a resources that is  not something that can be written.  Attempting to set up the writer depended on a lower level   operation such as a network or filesystem access that has failed  in some way.  If the scheme of the given URI does not have a registered   WritableRepository instance, then this method will fail with a  repository.ErrOperationNotSupported. Writer is backed by the repository system - this function calls into a scheme-specific implementation from a registered repository.\nSince: \r2.0\rtypes\r#\r\r \rExtensionFileFilter \rFileFilter \rMimeTypeFileFilter  "},{"id":250,"href":"/fyne/docs/api/storage/extensionfilefilter/","title":"storage.ExtensionFileFilter","section":"storage","content":"storage.ExtensionFileFilter\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage\u0026#34; Usage\r#\r\rtype ExtensionFileFilter\r#\r\rtype ExtensionFileFilter struct { \tExtensions []string } ExtensionFileFilter represents a file filter based on the the ending of file names, for example \u0026ldquo;.txt\u0026rdquo; and \u0026ldquo;.png\u0026rdquo;.\nfunc (*ExtensionFileFilter) Matches\r#\r\rfunc (e *ExtensionFileFilter) Matches(uri fyne.URI) bool Matches returns true if a file URI has one of the filtered extensions.\n"},{"id":251,"href":"/fyne/docs/api/storage/filefilter/","title":"storage.FileFilter","section":"storage","content":"storage.FileFilter\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage\u0026#34; Usage\r#\r\rtype FileFilter\r#\r\rtype FileFilter interface { \tMatches(fyne.URI) bool } FileFilter is an interface that can be implemented to provide a filter to a file dialog.\nfunc NewExtensionFileFilter\r#\r\rfunc NewExtensionFileFilter(extensions []string) FileFilter NewExtensionFileFilter takes a string slice of extensions with a leading . and creates a filter for the file dialog. Example: .jpg, .mp3, .txt, .sh\nfunc NewMimeTypeFileFilter\r#\r\rfunc NewMimeTypeFileFilter(mimeTypes []string) FileFilter NewMimeTypeFileFilter takes a string slice of mimetypes, including globs, and creates a filter for the file dialog. Example: image/, audio/mp3, text/plain, application/\n"},{"id":252,"href":"/fyne/docs/api/storage/mimetypefilefilter/","title":"storage.MimeTypeFileFilter","section":"storage","content":"storage.MimeTypeFileFilter\r#\r\r import \u0026#34;fyne.io/fyne/v2/storage\u0026#34; Usage\r#\r\rtype MimeTypeFileFilter\r#\r\rtype MimeTypeFileFilter struct { \tMimeTypes []string } MimeTypeFileFilter represents a file filter based on the files mime type, for example \u0026ldquo;image/*\u0026rdquo;, \u0026ldquo;audio/mp3\u0026rdquo;.\nfunc (*MimeTypeFileFilter) Matches\r#\r\rfunc (mt *MimeTypeFileFilter) Matches(uri fyne.URI) bool Matches returns true if a file URI has one of the filtered mimetypes.\n"},{"id":253,"href":"/fyne/docs/api/test/","title":"test","section":"API Documentation","content":"\r\rtest\r\rtest\r#\rimport \u0026#34;fyne.io/fyne/v2/test\u0026#34; Package test provides utility drivers for running UI tests without rendering Usage\r#\rfunc ApplyTheme\r#\rfunc ApplyTheme(t *testing.T, theme fyne.Theme) ApplyTheme sets the given theme and waits for it to be applied to the current app. func AssertCanvasTappableAt\r#\rfunc AssertCanvasTappableAt(t *testing.T, c fyne.Canvas, pos fyne.Position) bool AssertCanvasTappableAt asserts that the canvas is tappable at the given position. func AssertImageMatches\r#\rfunc AssertImageMatches(t *testing.\r\r\rtest.SoftwarePainter\r\rtest.SoftwarePainter\r#\rimport \u0026#34;fyne.io/fyne/v2/test\u0026#34; Usage\r#\rtype SoftwarePainter\r#\rtype SoftwarePainter interface { Paint(fyne.Canvas) image.Image } SoftwarePainter describes a simple type that can render canvases\r\r\rtest.WindowlessCanvas\r\rtest.WindowlessCanvas\r#\rimport \u0026#34;fyne.io/fyne/v2/test\u0026#34; Usage\r#\rtype WindowlessCanvas\r#\rtype WindowlessCanvas interface { fyne.Canvas Padded() bool Resize(fyne.Size) SetPadded(bool) SetScale(float32) } WindowlessCanvas provides functionality for a canvas to operate without a window func NewCanvas\r#\rfunc NewCanvas() WindowlessCanvas NewCanvas returns a single use in-memory canvas used for testing func NewCanvasWithPainter\r#\rfunc NewCanvasWithPainter(painter SoftwarePainter) WindowlessCanvas NewCanvasWithPainter allows creation of an in-memory canvas with a specific painter.\r\r\r"},{"id":254,"href":"/fyne/docs/api/test/","title":"test","section":"test","content":"test\r#\r\r import \u0026#34;fyne.io/fyne/v2/test\u0026#34; Package test provides utility drivers for running UI tests without rendering\nUsage\r#\r\rfunc ApplyTheme\r#\r\rfunc ApplyTheme(t *testing.T, theme fyne.Theme) ApplyTheme sets the given theme and waits for it to be applied to the current app.\nfunc AssertCanvasTappableAt\r#\r\rfunc AssertCanvasTappableAt(t *testing.T, c fyne.Canvas, pos fyne.Position) bool AssertCanvasTappableAt asserts that the canvas is tappable at the given position.\nfunc AssertImageMatches\r#\r\rfunc AssertImageMatches(t *testing.T, masterFilename string, img image.Image, msgAndArgs ...interface{}) bool AssertImageMatches asserts that the given image is the same as the one stored in the master file. The master filename is relative to the testdata directory which is relative to the test. The test t fails if the given image is not equal to the loaded master image. In this case the given image is written into a file in testdata/failed/\u0026lt;masterFilename\u0026gt; (relative to the test). This path is also reported, thus the file can be used as new master.\nfunc AssertNotificationSent\r#\r\rfunc AssertNotificationSent(t *testing.T, n *fyne.Notification, f func()) AssertNotificationSent allows an app developer to assert that a notification was sent. After the content of f has executed this utility will check that the specified notification was sent.\nfunc AssertRendersToMarkup\r#\r\rfunc AssertRendersToMarkup(t *testing.T, masterFilename string, c fyne.Canvas, msgAndArgs ...interface{}) bool AssertRendersToMarkup asserts that the given canvas renders the same markup as the one stored in the master file. The master filename is relative to the testdata directory which is relative to the test. The test t fails if the rendered markup is not equal to the loaded master markup. In this case the rendered markup is written into a file in testdata/failed/\u0026lt;masterFilename\u0026gt; (relative to the test). This path is also reported, thus the file can be used as new master.\nBe aware, that the indentation has to use tab characters (\u0026rsquo;\\t\u0026rsquo;) instead of spaces. Every element starts on a new line indented one more than its parent. Closing elements stand on their own line, too, using the same indentation as the opening element. The only exception to this are text elements which do not contain line breaks unless the text includes them.\nSince: \r2.0\rfunc Canvas\r#\r\rfunc Canvas() fyne.Canvas Canvas returns a reusable in-memory canvas used for testing\nfunc DoubleTap\r#\r\rfunc DoubleTap(obj fyne.DoubleTappable) DoubleTap simulates a double left mouse click on the specified object.\nfunc Drag\r#\r\rfunc Drag(c fyne.Canvas, pos fyne.Position, deltaX, deltaY float32) Drag drags at an absolute position on the canvas. deltaX/Y is the dragging distance: \u0026lt;0 for dragging up/left, \u0026gt;0 for dragging down/right.\nfunc FocusNext\r#\r\rfunc FocusNext(c fyne.Canvas) FocusNext focuses the next focusable on the canvas.\nfunc FocusPrevious\r#\r\rfunc FocusPrevious(c fyne.Canvas) FocusPrevious focuses the previous focusable on the canvas.\nfunc LaidOutObjects\r#\r\rfunc LaidOutObjects(o fyne.CanvasObject) (objects []fyne.CanvasObject) LaidOutObjects returns all fyne.CanvasObject starting at the given fyne.CanvasObject which is laid out previously.\nfunc MoveMouse\r#\r\rfunc MoveMouse(c fyne.Canvas, pos fyne.Position) MoveMouse simulates a mouse movement to the given position.\nfunc NewApp\r#\r\rfunc NewApp() fyne.App NewApp returns a new dummy app used for testing. It loads a test driver which creates a virtual window in memory for testing.\nfunc NewClipboard\r#\r\rfunc NewClipboard() fyne.Clipboard NewClipboard returns a single use in-memory clipboard used for testing\nfunc NewDriver\r#\r\rfunc NewDriver() fyne.Driver NewDriver sets up and registers a new dummy driver for test purpose\nfunc NewDriverWithPainter\r#\r\rfunc NewDriverWithPainter(painter SoftwarePainter) fyne.Driver NewDriverWithPainter creates a new dummy driver that will pass the given painter to all canvases created\nfunc NewTheme\r#\r\rfunc NewTheme() fyne.Theme NewTheme returns a new testTheme.\nfunc NewWindow\r#\r\rfunc NewWindow(content fyne.CanvasObject) fyne.Window NewWindow creates and registers a new window for test purposes\nfunc Scroll\r#\r\rfunc Scroll(c fyne.Canvas, pos fyne.Position, deltaX, deltaY float32) Scroll scrolls at an absolute position on the canvas. deltaX/Y is the scrolling distance: \u0026lt;0 for scrolling up/left, \u0026gt;0 for scrolling down/right.\nfunc Tap\r#\r\rfunc Tap(obj fyne.Tappable) Tap simulates a left mouse click on the specified object.\nfunc TapAt\r#\r\rfunc TapAt(obj fyne.Tappable, pos fyne.Position) TapAt simulates a left mouse click on the passed object at a specified place within it.\nfunc TapCanvas\r#\r\rfunc TapCanvas(c fyne.Canvas, pos fyne.Position) TapCanvas taps at an absolute position on the canvas.\nfunc TapSecondary\r#\r\rfunc TapSecondary(obj fyne.SecondaryTappable) TapSecondary simulates a right mouse click on the specified object.\nfunc TapSecondaryAt\r#\r\rfunc TapSecondaryAt(obj fyne.SecondaryTappable, pos fyne.Position) TapSecondaryAt simulates a right mouse click on the passed object at a specified place within it.\nfunc Theme\r#\r\rfunc Theme() fyne.Theme Theme returns a theme useful for image based tests.\nfunc Type\r#\r\rfunc Type(obj fyne.Focusable, chars string) Type performs a series of key events to simulate typing of a value into the specified object. The focusable object will be focused before typing begins. The chars parameter will be input one rune at a time to the focused object.\nfunc TypeOnCanvas\r#\r\rfunc TypeOnCanvas(c fyne.Canvas, chars string) TypeOnCanvas is like the Type function but it passes the key events to the canvas object rather than a focusable widget.\nfunc WidgetRenderer\r#\r\rfunc WidgetRenderer(wid fyne.Widget) fyne.WidgetRenderer WidgetRenderer allows test scripts to gain access to the current renderer for a widget. This can be used for verifying correctness of rendered components for a widget in unit tests.\nfunc WithTestTheme\r#\r\rfunc WithTestTheme(t *testing.T, f func()) WithTestTheme runs a function with the testTheme temporarily set.\ntypes\r#\r\r \rSoftwarePainter \rWindowlessCanvas  "},{"id":255,"href":"/fyne/docs/api/test/softwarepainter/","title":"test.SoftwarePainter","section":"test","content":"test.SoftwarePainter\r#\r\r import \u0026#34;fyne.io/fyne/v2/test\u0026#34; Usage\r#\r\rtype SoftwarePainter\r#\r\rtype SoftwarePainter interface { \tPaint(fyne.Canvas) image.Image } SoftwarePainter describes a simple type that can render canvases\n"},{"id":256,"href":"/fyne/docs/api/test/windowlesscanvas/","title":"test.WindowlessCanvas","section":"test","content":"test.WindowlessCanvas\r#\r\r import \u0026#34;fyne.io/fyne/v2/test\u0026#34; Usage\r#\r\rtype WindowlessCanvas\r#\r\rtype WindowlessCanvas interface { \tfyne.Canvas  \tPadded() bool \tResize(fyne.Size) \tSetPadded(bool) \tSetScale(float32) } WindowlessCanvas provides functionality for a canvas to operate without a window\nfunc NewCanvas\r#\r\rfunc NewCanvas() WindowlessCanvas NewCanvas returns a single use in-memory canvas used for testing\nfunc NewCanvasWithPainter\r#\r\rfunc NewCanvasWithPainter(painter SoftwarePainter) WindowlessCanvas NewCanvasWithPainter allows creation of an in-memory canvas with a specific painter. The painter will be used to render in the Capture() call.\n"},{"id":257,"href":"/fyne/docs/api/theme/","title":"theme","section":"widget","content":"theme\r#\r\r import \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Package theme defines how a Fyne app should look when rendered\nUsage\r#\r\rconst ( \t// IconNameCancel is the name of theme lookup for cancel icon. \t// \t// Since: 2.0 \tIconNameCancel fyne.ThemeIconName = \u0026#34;cancel\u0026#34;  \t// IconNameConfirm is the name of theme lookup for confirm icon. \t// \t// Since: 2.0 \tIconNameConfirm fyne.ThemeIconName = \u0026#34;confirm\u0026#34;  \t// IconNameDelete is the name of theme lookup for delete icon. \t// \t// Since: 2.0 \tIconNameDelete fyne.ThemeIconName = \u0026#34;delete\u0026#34;  \t// IconNameSearch is the name of theme lookup for search icon. \t// \t// Since: 2.0 \tIconNameSearch fyne.ThemeIconName = \u0026#34;search\u0026#34;  \t// IconNameSearchReplace is the name of theme lookup for search and replace icon. \t// \t// Since: 2.0 \tIconNameSearchReplace fyne.ThemeIconName = \u0026#34;searchReplace\u0026#34;  \t// IconNameMenu is the name of theme lookup for menu icon. \t// \t// Since: 2.0 \tIconNameMenu fyne.ThemeIconName = \u0026#34;menu\u0026#34;  \t// IconNameMenuExpand is the name of theme lookup for menu expansion icon. \t// \t// Since: 2.0 \tIconNameMenuExpand fyne.ThemeIconName = \u0026#34;menuExpand\u0026#34;  \t// IconNameCheckButtonChecked is the name of theme lookup for checked check button icon. \t// \t// Since: 2.0 \tIconNameCheckButtonChecked fyne.ThemeIconName = \u0026#34;checked\u0026#34;  \t// IconNameCheckButton is the name of theme lookup for unchecked check button icon. \t// \t// Since: 2.0 \tIconNameCheckButton fyne.ThemeIconName = \u0026#34;unchecked\u0026#34;  \t// IconNameRadioButton is the name of theme lookup for radio button unchecked icon. \t// \t// Since: 2.0 \tIconNameRadioButton fyne.ThemeIconName = \u0026#34;radioButton\u0026#34;  \t// IconNameRadioButtonChecked is the name of theme lookup for radio button checked icon. \t// \t// Since: 2.0 \tIconNameRadioButtonChecked fyne.ThemeIconName = \u0026#34;radioButtonChecked\u0026#34;  \t// IconNameColorAchromatic is the name of theme lookup for greyscale color icon. \t// \t// Since: 2.0 \tIconNameColorAchromatic fyne.ThemeIconName = \u0026#34;colorAchromatic\u0026#34;  \t// IconNameColorChromatic is the name of theme lookup for full color icon. \t// \t// Since: 2.0 \tIconNameColorChromatic fyne.ThemeIconName = \u0026#34;colorChromatic\u0026#34;  \t// IconNameColorPalette is the name of theme lookup for color palette icon. \t// \t// Since: 2.0 \tIconNameColorPalette fyne.ThemeIconName = \u0026#34;colorPalette\u0026#34;  \t// IconNameContentAdd is the name of theme lookup for content add icon. \t// \t// Since: 2.0 \tIconNameContentAdd fyne.ThemeIconName = \u0026#34;contentAdd\u0026#34;  \t// IconNameContentRemove is the name of theme lookup for content remove icon. \t// \t// Since: 2.0 \tIconNameContentRemove fyne.ThemeIconName = \u0026#34;contentRemove\u0026#34;  \t// IconNameContentCut is the name of theme lookup for content cut icon. \t// \t// Since: 2.0 \tIconNameContentCut fyne.ThemeIconName = \u0026#34;contentCut\u0026#34;  \t// IconNameContentCopy is the name of theme lookup for content copy icon. \t// \t// Since: 2.0 \tIconNameContentCopy fyne.ThemeIconName = \u0026#34;contentCopy\u0026#34;  \t// IconNameContentPaste is the name of theme lookup for content paste icon. \t// \t// Since: 2.0 \tIconNameContentPaste fyne.ThemeIconName = \u0026#34;contentPaste\u0026#34;  \t// IconNameContentClear is the name of theme lookup for content clear icon. \t// \t// Since: 2.0 \tIconNameContentClear fyne.ThemeIconName = \u0026#34;contentClear\u0026#34;  \t// IconNameContentRedo is the name of theme lookup for content redo icon. \t// \t// Since: 2.0 \tIconNameContentRedo fyne.ThemeIconName = \u0026#34;contentRedo\u0026#34;  \t// IconNameContentUndo is the name of theme lookup for content undo icon. \t// \t// Since: 2.0 \tIconNameContentUndo fyne.ThemeIconName = \u0026#34;contentUndo\u0026#34;  \t// IconNameInfo is the name of theme lookup for info icon. \t// \t// Since: 2.0 \tIconNameInfo fyne.ThemeIconName = \u0026#34;info\u0026#34;  \t// IconNameQuestion is the name of theme lookup for question icon. \t// \t// Since: 2.0 \tIconNameQuestion fyne.ThemeIconName = \u0026#34;question\u0026#34;  \t// IconNameWarning is the name of theme lookup for warning icon. \t// \t// Since: 2.0 \tIconNameWarning fyne.ThemeIconName = \u0026#34;warning\u0026#34;  \t// IconNameError is the name of theme lookup for error icon. \t// \t// Since: 2.0 \tIconNameError fyne.ThemeIconName = \u0026#34;error\u0026#34;  \t// IconNameDocument is the name of theme lookup for document icon. \t// \t// Since: 2.0 \tIconNameDocument fyne.ThemeIconName = \u0026#34;document\u0026#34;  \t// IconNameDocumentCreate is the name of theme lookup for document create icon. \t// \t// Since: 2.0 \tIconNameDocumentCreate fyne.ThemeIconName = \u0026#34;documentCreate\u0026#34;  \t// IconNameDocumentPrint is the name of theme lookup for document print icon. \t// \t// Since: 2.0 \tIconNameDocumentPrint fyne.ThemeIconName = \u0026#34;documentPrint\u0026#34;  \t// IconNameDocumentSave is the name of theme lookup for document save icon. \t// \t// Since: 2.0 \tIconNameDocumentSave fyne.ThemeIconName = \u0026#34;documentSave\u0026#34;  \t// IconNameMoreHorizontal is the name of theme lookup for horizontal more. \t// \t// Since 2.0 \tIconNameMoreHorizontal fyne.ThemeIconName = \u0026#34;moreHorizontal\u0026#34;  \t// IconNameMoreVertical is the name of theme lookup for vertical more. \t// \t// Since 2.0 \tIconNameMoreVertical fyne.ThemeIconName = \u0026#34;moreVertical\u0026#34;  \t// IconNameMailAttachment is the name of theme lookup for mail attachment icon. \t// \t// Since: 2.0 \tIconNameMailAttachment fyne.ThemeIconName = \u0026#34;mailAttachment\u0026#34;  \t// IconNameMailCompose is the name of theme lookup for mail compose icon. \t// \t// Since: 2.0 \tIconNameMailCompose fyne.ThemeIconName = \u0026#34;mailCompose\u0026#34;  \t// IconNameMailForward is the name of theme lookup for mail forward icon. \t// \t// Since: 2.0 \tIconNameMailForward fyne.ThemeIconName = \u0026#34;mailForward\u0026#34;  \t// IconNameMailReply is the name of theme lookup for mail reply icon. \t// \t// Since: 2.0 \tIconNameMailReply fyne.ThemeIconName = \u0026#34;mailReply\u0026#34;  \t// IconNameMailReplyAll is the name of theme lookup for mail reply-all icon. \t// \t// Since: 2.0 \tIconNameMailReplyAll fyne.ThemeIconName = \u0026#34;mailReplyAll\u0026#34;  \t// IconNameMailSend is the name of theme lookup for mail send icon. \t// \t// Since: 2.0 \tIconNameMailSend fyne.ThemeIconName = \u0026#34;mailSend\u0026#34;  \t// IconNameMediaMusic is the name of theme lookup for media music icon. \t// \t// Since: 2.1 \tIconNameMediaMusic fyne.ThemeIconName = \u0026#34;mediaMusic\u0026#34;  \t// IconNameMediaPhoto is the name of theme lookup for media photo icon. \t// \t// Since: 2.1 \tIconNameMediaPhoto fyne.ThemeIconName = \u0026#34;mediaPhoto\u0026#34;  \t// IconNameMediaVideo is the name of theme lookup for media video icon. \t// \t// Since: 2.1 \tIconNameMediaVideo fyne.ThemeIconName = \u0026#34;mediaVideo\u0026#34;  \t// IconNameMediaFastForward is the name of theme lookup for media fast-forward icon. \t// \t// Since: 2.0 \tIconNameMediaFastForward fyne.ThemeIconName = \u0026#34;mediaFastForward\u0026#34;  \t// IconNameMediaFastRewind is the name of theme lookup for media fast-rewind icon. \t// \t// Since: 2.0 \tIconNameMediaFastRewind fyne.ThemeIconName = \u0026#34;mediaFastRewind\u0026#34;  \t// IconNameMediaPause is the name of theme lookup for media pause icon. \t// \t// Since: 2.0 \tIconNameMediaPause fyne.ThemeIconName = \u0026#34;mediaPause\u0026#34;  \t// IconNameMediaPlay is the name of theme lookup for media play icon. \t// \t// Since: 2.0 \tIconNameMediaPlay fyne.ThemeIconName = \u0026#34;mediaPlay\u0026#34;  \t// IconNameMediaRecord is the name of theme lookup for media record icon. \t// \t// Since: 2.0 \tIconNameMediaRecord fyne.ThemeIconName = \u0026#34;mediaRecord\u0026#34;  \t// IconNameMediaReplay is the name of theme lookup for media replay icon. \t// \t// Since: 2.0 \tIconNameMediaReplay fyne.ThemeIconName = \u0026#34;mediaReplay\u0026#34;  \t// IconNameMediaSkipNext is the name of theme lookup for media skip next icon. \t// \t// Since: 2.0 \tIconNameMediaSkipNext fyne.ThemeIconName = \u0026#34;mediaSkipNext\u0026#34;  \t// IconNameMediaSkipPrevious is the name of theme lookup for media skip previous icon. \t// \t// Since: 2.0 \tIconNameMediaSkipPrevious fyne.ThemeIconName = \u0026#34;mediaSkipPrevious\u0026#34;  \t// IconNameMediaStop is the name of theme lookup for media stop icon. \t// \t// Since: 2.0 \tIconNameMediaStop fyne.ThemeIconName = \u0026#34;mediaStop\u0026#34;  \t// IconNameMoveDown is the name of theme lookup for move down icon. \t// \t// Since: 2.0 \tIconNameMoveDown fyne.ThemeIconName = \u0026#34;arrowDown\u0026#34;  \t// IconNameMoveUp is the name of theme lookup for move up icon. \t// \t// Since: 2.0 \tIconNameMoveUp fyne.ThemeIconName = \u0026#34;arrowUp\u0026#34;  \t// IconNameNavigateBack is the name of theme lookup for navigate back icon. \t// \t// Since: 2.0 \tIconNameNavigateBack fyne.ThemeIconName = \u0026#34;arrowBack\u0026#34;  \t// IconNameNavigateNext is the name of theme lookup for navigate next icon. \t// \t// Since: 2.0 \tIconNameNavigateNext fyne.ThemeIconName = \u0026#34;arrowForward\u0026#34;  \t// IconNameArrowDropDown is the name of theme lookup for drop-down arrow icon. \t// \t// Since: 2.0 \tIconNameArrowDropDown fyne.ThemeIconName = \u0026#34;arrowDropDown\u0026#34;  \t// IconNameArrowDropUp is the name of theme lookup for drop-up arrow icon. \t// \t// Since: 2.0 \tIconNameArrowDropUp fyne.ThemeIconName = \u0026#34;arrowDropUp\u0026#34;  \t// IconNameFile is the name of theme lookup for file icon. \t// \t// Since: 2.0 \tIconNameFile fyne.ThemeIconName = \u0026#34;file\u0026#34;  \t// IconNameFileApplication is the name of theme lookup for file application icon. \t// \t// Since: 2.0 \tIconNameFileApplication fyne.ThemeIconName = \u0026#34;fileApplication\u0026#34;  \t// IconNameFileAudio is the name of theme lookup for file audio icon. \t// \t// Since: 2.0 \tIconNameFileAudio fyne.ThemeIconName = \u0026#34;fileAudio\u0026#34;  \t// IconNameFileImage is the name of theme lookup for file image icon. \t// \t// Since: 2.0 \tIconNameFileImage fyne.ThemeIconName = \u0026#34;fileImage\u0026#34;  \t// IconNameFileText is the name of theme lookup for file text icon. \t// \t// Since: 2.0 \tIconNameFileText fyne.ThemeIconName = \u0026#34;fileText\u0026#34;  \t// IconNameFileVideo is the name of theme lookup for file video icon. \t// \t// Since: 2.0 \tIconNameFileVideo fyne.ThemeIconName = \u0026#34;fileVideo\u0026#34;  \t// IconNameFolder is the name of theme lookup for folder icon. \t// \t// Since: 2.0 \tIconNameFolder fyne.ThemeIconName = \u0026#34;folder\u0026#34;  \t// IconNameFolderNew is the name of theme lookup for folder new icon. \t// \t// Since: 2.0 \tIconNameFolderNew fyne.ThemeIconName = \u0026#34;folderNew\u0026#34;  \t// IconNameFolderOpen is the name of theme lookup for folder open icon. \t// \t// Since: 2.0 \tIconNameFolderOpen fyne.ThemeIconName = \u0026#34;folderOpen\u0026#34;  \t// IconNameHelp is the name of theme lookup for help icon. \t// \t// Since: 2.0 \tIconNameHelp fyne.ThemeIconName = \u0026#34;help\u0026#34;  \t// IconNameHistory is the name of theme lookup for history icon. \t// \t// Since: 2.0 \tIconNameHistory fyne.ThemeIconName = \u0026#34;history\u0026#34;  \t// IconNameHome is the name of theme lookup for home icon. \t// \t// Since: 2.0 \tIconNameHome fyne.ThemeIconName = \u0026#34;home\u0026#34;  \t// IconNameSettings is the name of theme lookup for settings icon. \t// \t// Since: 2.0 \tIconNameSettings fyne.ThemeIconName = \u0026#34;settings\u0026#34;  \t// IconNameStorage is the name of theme lookup for storage icon. \t// \t// Since: 2.0 \tIconNameStorage fyne.ThemeIconName = \u0026#34;storage\u0026#34;  \t// IconNameUpload is the name of theme lookup for upload icon. \t// \t// Since: 2.0 \tIconNameUpload fyne.ThemeIconName = \u0026#34;upload\u0026#34;  \t// IconNameViewFullScreen is the name of theme lookup for view fullscreen icon. \t// \t// Since: 2.0 \tIconNameViewFullScreen fyne.ThemeIconName = \u0026#34;viewFullScreen\u0026#34;  \t// IconNameViewRefresh is the name of theme lookup for view refresh icon. \t// \t// Since: 2.0 \tIconNameViewRefresh fyne.ThemeIconName = \u0026#34;viewRefresh\u0026#34;  \t// IconNameViewZoomFit is the name of theme lookup for view zoom fit icon. \t// \t// Since: 2.0 \tIconNameViewZoomFit fyne.ThemeIconName = \u0026#34;viewZoomFit\u0026#34;  \t// IconNameViewZoomIn is the name of theme lookup for view zoom in icon. \t// \t// Since: 2.0 \tIconNameViewZoomIn fyne.ThemeIconName = \u0026#34;viewZoomIn\u0026#34;  \t// IconNameViewZoomOut is the name of theme lookup for view zoom out icon. \t// \t// Since: 2.0 \tIconNameViewZoomOut fyne.ThemeIconName = \u0026#34;viewZoomOut\u0026#34;  \t// IconNameViewRestore is the name of theme lookup for view restore icon. \t// \t// Since: 2.0 \tIconNameViewRestore fyne.ThemeIconName = \u0026#34;viewRestore\u0026#34;  \t// IconNameVisibility is the name of theme lookup for visibility icon. \t// \t// Since: 2.0 \tIconNameVisibility fyne.ThemeIconName = \u0026#34;visibility\u0026#34;  \t// IconNameVisibilityOff is the name of theme lookup for invisibility icon. \t// \t// Since: 2.0 \tIconNameVisibilityOff fyne.ThemeIconName = \u0026#34;visibilityOff\u0026#34;  \t// IconNameVolumeDown is the name of theme lookup for volume down icon. \t// \t// Since: 2.0 \tIconNameVolumeDown fyne.ThemeIconName = \u0026#34;volumeDown\u0026#34;  \t// IconNameVolumeMute is the name of theme lookup for volume mute icon. \t// \t// Since: 2.0 \tIconNameVolumeMute fyne.ThemeIconName = \u0026#34;volumeMute\u0026#34;  \t// IconNameVolumeUp is the name of theme lookup for volume up icon. \t// \t// Since: 2.0 \tIconNameVolumeUp fyne.ThemeIconName = \u0026#34;volumeUp\u0026#34;  \t// IconNameDownload is the name of theme lookup for download icon. \t// \t// Since: 2.0 \tIconNameDownload fyne.ThemeIconName = \u0026#34;download\u0026#34;  \t// IconNameComputer is the name of theme lookup for computer icon. \t// \t// Since: 2.0 \tIconNameComputer fyne.ThemeIconName = \u0026#34;computer\u0026#34;  \t// IconNameAccount is the name of theme lookup for account icon. \t// \t// Since: 2.1 \tIconNameAccount fyne.ThemeIconName = \u0026#34;account\u0026#34;  \t// IconNameLogin is the name of theme lookup for login icon. \t// \t// Since: 2.1 \tIconNameLogin fyne.ThemeIconName = \u0026#34;login\u0026#34;  \t// IconNameLogout is the name of theme lookup for logout icon. \t// \t// Since: 2.1 \tIconNameLogout fyne.ThemeIconName = \u0026#34;logout\u0026#34;  \t// IconNameList is the name of theme lookup for list icon. \t// \t// Since: 2.1 \tIconNameList fyne.ThemeIconName = \u0026#34;list\u0026#34;  \t// IconNameGrid is the name of theme lookup for grid icon. \t// \t// Since: 2.1 \tIconNameGrid fyne.ThemeIconName = \u0026#34;grid\u0026#34; ) const ( \t// ColorRed is the red primary color name \t// \t// Since: 1.4 \tColorRed = \u0026#34;red\u0026#34; \t// ColorOrange is the orange primary color name \t// \t// Since: 1.4 \tColorOrange = \u0026#34;orange\u0026#34; \t// ColorYellow is the yellow primary color name \t// \t// Since: 1.4 \tColorYellow = \u0026#34;yellow\u0026#34; \t// ColorGreen is the green primary color name \t// \t// Since: 1.4 \tColorGreen = \u0026#34;green\u0026#34; \t// ColorBlue is the blue primary color name \t// \t// Since: 1.4 \tColorBlue = \u0026#34;blue\u0026#34; \t// ColorPurple is the purple primary color name \t// \t// Since: 1.4 \tColorPurple = \u0026#34;purple\u0026#34; \t// ColorBrown is the brown primary color name \t// \t// Since: 1.4 \tColorBrown = \u0026#34;brown\u0026#34; \t// ColorGray is the gray primary color name \t// \t// Since: 1.4 \tColorGray = \u0026#34;gray\u0026#34;  \t// ColorNameBackground is the name of theme lookup for background color. \t// \t// Since: 2.0 \tColorNameBackground fyne.ThemeColorName = \u0026#34;background\u0026#34;  \t// ColorNameButton is the name of theme lookup for button color. \t// \t// Since: 2.0 \tColorNameButton fyne.ThemeColorName = \u0026#34;button\u0026#34;  \t// ColorNameDisabledButton is the name of theme lookup for disabled button color. \t// \t// Since: 2.0 \tColorNameDisabledButton fyne.ThemeColorName = \u0026#34;disabledButton\u0026#34;  \t// ColorNameDisabled is the name of theme lookup for disabled foreground color. \t// \t// Since: 2.0 \tColorNameDisabled fyne.ThemeColorName = \u0026#34;disabled\u0026#34;  \t// ColorNameError is the name of theme lookup for foreground error color. \t// \t// Since: 2.0 \tColorNameError fyne.ThemeColorName = \u0026#34;error\u0026#34;  \t// ColorNameFocus is the name of theme lookup for focus color. \t// \t// Since: 2.0 \tColorNameFocus fyne.ThemeColorName = \u0026#34;focus\u0026#34;  \t// ColorNameForeground is the name of theme lookup for foreground color. \t// \t// Since: 2.0 \tColorNameForeground fyne.ThemeColorName = \u0026#34;foreground\u0026#34;  \t// ColorNameHover is the name of theme lookup for hover color. \t// \t// Since: 2.0 \tColorNameHover fyne.ThemeColorName = \u0026#34;hover\u0026#34;  \t// ColorNameInputBackground is the name of theme lookup for background color of an input field. \t// \t// Since: 2.0 \tColorNameInputBackground fyne.ThemeColorName = \u0026#34;inputBackground\u0026#34;  \t// ColorNamePlaceHolder is the name of theme lookup for placeholder text color. \t// \t// Since: 2.0 \tColorNamePlaceHolder fyne.ThemeColorName = \u0026#34;placeholder\u0026#34;  \t// ColorNamePressed is the name of theme lookup for the tap overlay color. \t// \t// Since: 2.0 \tColorNamePressed fyne.ThemeColorName = \u0026#34;pressed\u0026#34;  \t// ColorNamePrimary is the name of theme lookup for primary color. \t// \t// Since: 2.0 \tColorNamePrimary fyne.ThemeColorName = \u0026#34;primary\u0026#34;  \t// ColorNameScrollBar is the name of theme lookup for scrollbar color. \t// \t// Since: 2.0 \tColorNameScrollBar fyne.ThemeColorName = \u0026#34;scrollBar\u0026#34;  \t// ColorNameSelection is the name of theme lookup for selection color. \t// \t// Since: 2.1 \tColorNameSelection fyne.ThemeColorName = \u0026#34;selection\u0026#34;  \t// ColorNameShadow is the name of theme lookup for shadow color. \t// \t// Since: 2.0 \tColorNameShadow fyne.ThemeColorName = \u0026#34;shadow\u0026#34;  \t// SizeNameCaptionText is the name of theme lookup for helper text size, normally smaller than regular text size. \t// \t// Since: 2.0 \tSizeNameCaptionText fyne.ThemeSizeName = \u0026#34;helperText\u0026#34;  \t// SizeNameInlineIcon is the name of theme lookup for inline icons size. \t// \t// Since: 2.0 \tSizeNameInlineIcon fyne.ThemeSizeName = \u0026#34;iconInline\u0026#34;  \t// SizeNamePadding is the name of theme lookup for padding size. \t// \t// Since: 2.0 \tSizeNamePadding fyne.ThemeSizeName = \u0026#34;padding\u0026#34;  \t// SizeNameScrollBar is the name of theme lookup for the scrollbar size. \t// \t// Since: 2.0 \tSizeNameScrollBar fyne.ThemeSizeName = \u0026#34;scrollBar\u0026#34;  \t// SizeNameScrollBarSmall is the name of theme lookup for the shrunk scrollbar size. \t// \t// Since: 2.0 \tSizeNameScrollBarSmall fyne.ThemeSizeName = \u0026#34;scrollBarSmall\u0026#34;  \t// SizeNameSeparatorThickness is the name of theme lookup for the thickness of a separator. \t// \t// Since: 2.0 \tSizeNameSeparatorThickness fyne.ThemeSizeName = \u0026#34;separator\u0026#34;  \t// SizeNameText is the name of theme lookup for text size. \t// \t// Since: 2.0 \tSizeNameText fyne.ThemeSizeName = \u0026#34;text\u0026#34;  \t// SizeNameHeadingText is the name of theme lookup for text size of a heading. \t// \t// Since: 2.1 \tSizeNameHeadingText fyne.ThemeSizeName = \u0026#34;headingText\u0026#34;  \t// SizeNameSubHeadingText is the name of theme lookup for text size of a sub-heading. \t// \t// Since: 2.1 \tSizeNameSubHeadingText fyne.ThemeSizeName = \u0026#34;subHeadingText\u0026#34;  \t// SizeNameInputBorder is the name of theme lookup for input border size. \t// \t// Since: 2.0 \tSizeNameInputBorder fyne.ThemeSizeName = \u0026#34;inputBorder\u0026#34;  \t// VariantDark is the version of a theme that satisfies a user preference for a light look. \t// \t// Since: 2.0 \tVariantDark fyne.ThemeVariant = 0  \t// VariantLight is the version of a theme that satisfies a user preference for a dark look. \t// \t// Since: 2.0 \tVariantLight fyne.ThemeVariant = 1 ) func AccountIcon\r#\r\rfunc AccountIcon() fyne.Resource AccountIcon returns a resource containing the standard account icon for the current theme\nfunc BackgroundColor\r#\r\rfunc BackgroundColor() color.Color BackgroundColor returns the theme\u0026rsquo;s background color\nfunc ButtonColor\r#\r\rfunc ButtonColor() color.Color ButtonColor returns the theme\u0026rsquo;s standard button color.\nfunc CancelIcon\r#\r\rfunc CancelIcon() fyne.Resource CancelIcon returns a resource containing the standard cancel icon for the current theme\nfunc CaptionTextSize\r#\r\rfunc CaptionTextSize() float32 CaptionTextSize returns the size for caption text.\nfunc CheckButtonCheckedIcon\r#\r\rfunc CheckButtonCheckedIcon() fyne.Resource CheckButtonCheckedIcon returns a resource containing the standard checkbox checked icon for the current theme\nfunc CheckButtonIcon\r#\r\rfunc CheckButtonIcon() fyne.Resource CheckButtonIcon returns a resource containing the standard checkbox icon for the current theme\nfunc ColorAchromaticIcon\r#\r\rfunc ColorAchromaticIcon() fyne.Resource ColorAchromaticIcon returns a resource containing the standard achromatic color icon for the current theme\nfunc ColorChromaticIcon\r#\r\rfunc ColorChromaticIcon() fyne.Resource ColorChromaticIcon returns a resource containing the standard chromatic color icon for the current theme\nfunc ColorPaletteIcon\r#\r\rfunc ColorPaletteIcon() fyne.Resource ColorPaletteIcon returns a resource containing the standard color palette icon for the current theme\nfunc ComputerIcon\r#\r\rfunc ComputerIcon() fyne.Resource ComputerIcon returns a resource containing the standard computer icon for the current theme\nfunc ConfirmIcon\r#\r\rfunc ConfirmIcon() fyne.Resource ConfirmIcon returns a resource containing the standard confirm icon for the current theme\nfunc ContentAddIcon\r#\r\rfunc ContentAddIcon() fyne.Resource ContentAddIcon returns a resource containing the standard content add icon for the current theme\nfunc ContentClearIcon\r#\r\rfunc ContentClearIcon() fyne.Resource ContentClearIcon returns a resource containing the standard content clear icon for the current theme\nfunc ContentCopyIcon\r#\r\rfunc ContentCopyIcon() fyne.Resource ContentCopyIcon returns a resource containing the standard content copy icon for the current theme\nfunc ContentCutIcon\r#\r\rfunc ContentCutIcon() fyne.Resource ContentCutIcon returns a resource containing the standard content cut icon for the current theme\nfunc ContentPasteIcon\r#\r\rfunc ContentPasteIcon() fyne.Resource ContentPasteIcon returns a resource containing the standard content paste icon for the current theme\nfunc ContentRedoIcon\r#\r\rfunc ContentRedoIcon() fyne.Resource ContentRedoIcon returns a resource containing the standard content redo icon for the current theme\nfunc ContentRemoveIcon\r#\r\rfunc ContentRemoveIcon() fyne.Resource ContentRemoveIcon returns a resource containing the standard content remove icon for the current theme\nfunc ContentUndoIcon\r#\r\rfunc ContentUndoIcon() fyne.Resource ContentUndoIcon returns a resource containing the standard content undo icon for the current theme\nfunc DarkTheme\r#\r\rfunc DarkTheme() fyne.Theme DarkTheme defines the built in dark theme colors and sizes.\nDeprecated: This method ignores user preference and should not be used, it will be removed in v3.0.\rfunc DefaultTextBoldFont\r#\r\rfunc DefaultTextBoldFont() fyne.Resource DefaultTextBoldFont returns the font resource for the built-in bold font style\nfunc DefaultTextBoldItalicFont\r#\r\rfunc DefaultTextBoldItalicFont() fyne.Resource DefaultTextBoldItalicFont returns the font resource for the built-in bold and italic font style\nfunc DefaultTextFont\r#\r\rfunc DefaultTextFont() fyne.Resource DefaultTextFont returns the font resource for the built-in regular font style\nfunc DefaultTextItalicFont\r#\r\rfunc DefaultTextItalicFont() fyne.Resource DefaultTextItalicFont returns the font resource for the built-in italic font style\nfunc DefaultTextMonospaceFont\r#\r\rfunc DefaultTextMonospaceFont() fyne.Resource DefaultTextMonospaceFont returns the font resource for the built-in monospace font face\nfunc DefaultTheme\r#\r\rfunc DefaultTheme() fyne.Theme DefaultTheme returns a built-in theme that can adapt to the user preference of light or dark colors.\nSince: \r2.0\rfunc DeleteIcon\r#\r\rfunc DeleteIcon() fyne.Resource DeleteIcon returns a resource containing the standard delete icon for the current theme\nfunc DisabledButtonColor\r#\r\rfunc DisabledButtonColor() color.Color DisabledButtonColor returns the theme\u0026rsquo;s disabled button color.\nfunc DisabledColor\r#\r\rfunc DisabledColor() color.Color DisabledColor returns the foreground color for a disabled UI element\nSince: \r2.0\rfunc DisabledTextColor\r#\r\rfunc DisabledTextColor() color.Color DisabledTextColor returns the theme\u0026rsquo;s disabled text color - this is actually the disabled color since 1.4.\nDeprecated: Use theme.DisabledColor() colour instead\rfunc DocumentCreateIcon\r#\r\rfunc DocumentCreateIcon() fyne.Resource DocumentCreateIcon returns a resource containing the standard document create icon for the current theme\nfunc DocumentIcon\r#\r\rfunc DocumentIcon() fyne.Resource DocumentIcon returns a resource containing the standard document icon for the current theme\nfunc DocumentPrintIcon\r#\r\rfunc DocumentPrintIcon() fyne.Resource DocumentPrintIcon returns a resource containing the standard document print icon for the current theme\nfunc DocumentSaveIcon\r#\r\rfunc DocumentSaveIcon() fyne.Resource DocumentSaveIcon returns a resource containing the standard document save icon for the current theme\nfunc DownloadIcon\r#\r\rfunc DownloadIcon() fyne.Resource DownloadIcon returns a resource containing the standard download icon for the current theme\nfunc ErrorColor\r#\r\rfunc ErrorColor() color.Color ErrorColor returns the theme\u0026rsquo;s error text color\nSince: \r2.0\rfunc ErrorIcon\r#\r\rfunc ErrorIcon() fyne.Resource ErrorIcon returns a resource containing the standard dialog error icon for the current theme\nfunc FileApplicationIcon\r#\r\rfunc FileApplicationIcon() fyne.Resource FileApplicationIcon returns a resource containing the file icon representing application files for the current theme\nfunc FileAudioIcon\r#\r\rfunc FileAudioIcon() fyne.Resource FileAudioIcon returns a resource containing the file icon representing audio files for the current theme\nfunc FileIcon\r#\r\rfunc FileIcon() fyne.Resource FileIcon returns a resource containing the appropriate file icon for the current theme\nfunc FileImageIcon\r#\r\rfunc FileImageIcon() fyne.Resource FileImageIcon returns a resource containing the file icon representing image files for the current theme\nfunc FileTextIcon\r#\r\rfunc FileTextIcon() fyne.Resource FileTextIcon returns a resource containing the file icon representing text files for the current theme\nfunc FileVideoIcon\r#\r\rfunc FileVideoIcon() fyne.Resource FileVideoIcon returns a resource containing the file icon representing video files for the current theme\nfunc FocusColor\r#\r\rfunc FocusColor() color.Color FocusColor returns the color used to highlight a focused widget\nfunc FolderIcon\r#\r\rfunc FolderIcon() fyne.Resource FolderIcon returns a resource containing the standard folder icon for the current theme\nfunc FolderNewIcon\r#\r\rfunc FolderNewIcon() fyne.Resource FolderNewIcon returns a resource containing the standard folder creation icon for the current theme\nfunc FolderOpenIcon\r#\r\rfunc FolderOpenIcon() fyne.Resource FolderOpenIcon returns a resource containing the standard folder open icon for the current theme\nfunc ForegroundColor\r#\r\rfunc ForegroundColor() color.Color ForegroundColor returns the theme\u0026rsquo;s standard foreground color for text and icons\nSince: \r2.0\rfunc FromLegacy\r#\r\rfunc FromLegacy(t fyne.LegacyTheme) fyne.Theme FromLegacy returns a 2.0 Theme created from the given LegacyTheme data. This is a transition path and will be removed in the future (probably version 3.0).\nSince: \r2.0\rfunc FyneLogo\r#\r\rfunc FyneLogo() fyne.Resource FyneLogo returns a resource containing the Fyne logo\nfunc GridIcon\r#\r\rfunc GridIcon() fyne.Resource GridIcon returns a resource containing the standard grid icon for the current theme\nfunc HelpIcon\r#\r\rfunc HelpIcon() fyne.Resource HelpIcon returns a resource containing the standard help icon for the current theme\nfunc HistoryIcon\r#\r\rfunc HistoryIcon() fyne.Resource HistoryIcon returns a resource containing the standard history icon for the current theme\nfunc HomeIcon\r#\r\rfunc HomeIcon() fyne.Resource HomeIcon returns a resource containing the standard home folder icon for the current theme\nfunc HoverColor\r#\r\rfunc HoverColor() color.Color HoverColor returns the color used to highlight interactive elements currently under a cursor\nfunc IconInlineSize\r#\r\rfunc IconInlineSize() float32 IconInlineSize is the standard size of icons which appear within buttons, labels etc.\nfunc InfoIcon\r#\r\rfunc InfoIcon() fyne.Resource InfoIcon returns a resource containing the standard dialog info icon for the current theme\nfunc InputBackgroundColor\r#\r\rfunc InputBackgroundColor() color.Color InputBackgroundColor returns the color used to draw underneath input elements.\nfunc InputBorderSize\r#\r\rfunc InputBorderSize() float32 InputBorderSize returns the input border size (or underline size for an entry).\nSince: \r2.0\rfunc LightTheme\r#\r\rfunc LightTheme() fyne.Theme LightTheme defines the built in light theme colors and sizes.\nDeprecated: This method ignores user preference and should not be used, it will be removed in v3.0.\rfunc ListIcon\r#\r\rfunc ListIcon() fyne.Resource ListIcon returns a resource containing the standard list icon for the current theme\nfunc LoginIcon\r#\r\rfunc LoginIcon() fyne.Resource LoginIcon returns a resource containing the standard login icon for the current theme\nfunc LogoutIcon\r#\r\rfunc LogoutIcon() fyne.Resource LogoutIcon returns a resource containing the standard logout icon for the current theme\nfunc MailAttachmentIcon\r#\r\rfunc MailAttachmentIcon() fyne.Resource MailAttachmentIcon returns a resource containing the standard mail attachment icon for the current theme\nfunc MailComposeIcon\r#\r\rfunc MailComposeIcon() fyne.Resource MailComposeIcon returns a resource containing the standard mail compose icon for the current theme\nfunc MailForwardIcon\r#\r\rfunc MailForwardIcon() fyne.Resource MailForwardIcon returns a resource containing the standard mail forward icon for the current theme\nfunc MailReplyAllIcon\r#\r\rfunc MailReplyAllIcon() fyne.Resource MailReplyAllIcon returns a resource containing the standard mail reply all icon for the current theme\nfunc MailReplyIcon\r#\r\rfunc MailReplyIcon() fyne.Resource MailReplyIcon returns a resource containing the standard mail reply icon for the current theme\nfunc MailSendIcon\r#\r\rfunc MailSendIcon() fyne.Resource MailSendIcon returns a resource containing the standard mail send icon for the current theme\nfunc MediaFastForwardIcon\r#\r\rfunc MediaFastForwardIcon() fyne.Resource MediaFastForwardIcon returns a resource containing the standard media fast-forward icon for the current theme\nfunc MediaFastRewindIcon\r#\r\rfunc MediaFastRewindIcon() fyne.Resource MediaFastRewindIcon returns a resource containing the standard media fast-rewind icon for the current theme\nfunc MediaMusicIcon\r#\r\rfunc MediaMusicIcon() fyne.Resource MediaMusicIcon returns a resource containing the standard media music icon for the current theme\nSince: \r2.1\rfunc MediaPauseIcon\r#\r\rfunc MediaPauseIcon() fyne.Resource MediaPauseIcon returns a resource containing the standard media pause icon for the current theme\nfunc MediaPhotoIcon\r#\r\rfunc MediaPhotoIcon() fyne.Resource MediaPhotoIcon returns a resource containing the standard media photo icon for the current theme\nSince: \r2.1\rfunc MediaPlayIcon\r#\r\rfunc MediaPlayIcon() fyne.Resource MediaPlayIcon returns a resource containing the standard media play icon for the current theme\nfunc MediaRecordIcon\r#\r\rfunc MediaRecordIcon() fyne.Resource MediaRecordIcon returns a resource containing the standard media record icon for the current theme\nfunc MediaReplayIcon\r#\r\rfunc MediaReplayIcon() fyne.Resource MediaReplayIcon returns a resource containing the standard media replay icon for the current theme\nfunc MediaSkipNextIcon\r#\r\rfunc MediaSkipNextIcon() fyne.Resource MediaSkipNextIcon returns a resource containing the standard media skip next icon for the current theme\nfunc MediaSkipPreviousIcon\r#\r\rfunc MediaSkipPreviousIcon() fyne.Resource MediaSkipPreviousIcon returns a resource containing the standard media skip previous icon for the current theme\nfunc MediaStopIcon\r#\r\rfunc MediaStopIcon() fyne.Resource MediaStopIcon returns a resource containing the standard media stop icon for the current theme\nfunc MediaVideoIcon\r#\r\rfunc MediaVideoIcon() fyne.Resource MediaVideoIcon returns a resource containing the standard media video icon for the current theme\nSince: \r2.1\rfunc MenuDropDownIcon\r#\r\rfunc MenuDropDownIcon() fyne.Resource MenuDropDownIcon returns a resource containing the standard menu drop down icon for the current theme\nfunc MenuDropUpIcon\r#\r\rfunc MenuDropUpIcon() fyne.Resource MenuDropUpIcon returns a resource containing the standard menu drop up icon for the current theme\nfunc MenuExpandIcon\r#\r\rfunc MenuExpandIcon() fyne.Resource MenuExpandIcon returns a resource containing the standard (mobile) expand \u0026ldquo;submenu icon for the current theme\nfunc MenuIcon\r#\r\rfunc MenuIcon() fyne.Resource MenuIcon returns a resource containing the standard (mobile) menu icon for the current theme\nfunc MoreHorizontalIcon\r#\r\rfunc MoreHorizontalIcon() fyne.Resource MoreHorizontalIcon returns a resource containing the standard horizontal more icon for the current theme\nfunc MoreVerticalIcon\r#\r\rfunc MoreVerticalIcon() fyne.Resource MoreVerticalIcon returns a resource containing the standard vertical more icon for the current theme\nfunc MoveDownIcon\r#\r\rfunc MoveDownIcon() fyne.Resource MoveDownIcon returns a resource containing the standard down arrow icon for the current theme\nfunc MoveUpIcon\r#\r\rfunc MoveUpIcon() fyne.Resource MoveUpIcon returns a resource containing the standard up arrow icon for the current theme\nfunc NavigateBackIcon\r#\r\rfunc NavigateBackIcon() fyne.Resource NavigateBackIcon returns a resource containing the standard backward navigation icon for the current theme\nfunc NavigateNextIcon\r#\r\rfunc NavigateNextIcon() fyne.Resource NavigateNextIcon returns a resource containing the standard forward navigation icon for the current theme\nfunc Padding\r#\r\rfunc Padding() float32 Padding is the standard gap between elements and the border around interface elements\nfunc PlaceHolderColor\r#\r\rfunc PlaceHolderColor() color.Color PlaceHolderColor returns the theme\u0026rsquo;s standard text color\nfunc PressedColor\r#\r\rfunc PressedColor() color.Color PressedColor returns the color used to overlap tapped features\nSince: \r2.0\rfunc PrimaryColor\r#\r\rfunc PrimaryColor() color.Color PrimaryColor returns the color used to highlight primary features\nfunc PrimaryColorNamed\r#\r\rfunc PrimaryColorNamed(name string) color.Color PrimaryColorNamed returns a theme specific color value for a named primary color.\nSince: \r1.4\rfunc PrimaryColorNames\r#\r\rfunc PrimaryColorNames() []string PrimaryColorNames returns a list of the standard primary color options.\nSince: \r1.4\rfunc QuestionIcon\r#\r\rfunc QuestionIcon() fyne.Resource QuestionIcon returns a resource containing the standard dialog question icon for the current theme\nfunc RadioButtonCheckedIcon\r#\r\rfunc RadioButtonCheckedIcon() fyne.Resource RadioButtonCheckedIcon returns a resource containing the standard radio button checked icon for the current theme\nfunc RadioButtonIcon\r#\r\rfunc RadioButtonIcon() fyne.Resource RadioButtonIcon returns a resource containing the standard radio button icon for the current theme\nfunc ScrollBarColor\r#\r\rfunc ScrollBarColor() color.Color ScrollBarColor returns the color (and translucency) for a scrollBar\nfunc ScrollBarSize\r#\r\rfunc ScrollBarSize() float32 ScrollBarSize is the width (or height) of the bars on a ScrollContainer\nfunc ScrollBarSmallSize\r#\r\rfunc ScrollBarSmallSize() float32 ScrollBarSmallSize is the width (or height) of the minimized bars on a ScrollContainer\nfunc SearchIcon\r#\r\rfunc SearchIcon() fyne.Resource SearchIcon returns a resource containing the standard search icon for the current theme\nfunc SearchReplaceIcon\r#\r\rfunc SearchReplaceIcon() fyne.Resource SearchReplaceIcon returns a resource containing the standard search and replace icon for the current theme\nfunc SelectionColor\r#\r\rfunc SelectionColor() color.Color SelectionColor returns the color for a selected element.\nSince: \r2.1\rfunc SeparatorThicknessSize\r#\r\rfunc SeparatorThicknessSize() float32 SeparatorThicknessSize is the standard thickness of the separator widget.\nSince: \r2.0\rfunc SettingsIcon\r#\r\rfunc SettingsIcon() fyne.Resource SettingsIcon returns a resource containing the standard settings icon for the current theme\nfunc ShadowColor\r#\r\rfunc ShadowColor() color.Color ShadowColor returns the color (and translucency) for shadows used for indicating elevation\nfunc StorageIcon\r#\r\rfunc StorageIcon() fyne.Resource StorageIcon returns a resource containing the standard storage icon for the current theme\nfunc TextBoldFont\r#\r\rfunc TextBoldFont() fyne.Resource TextBoldFont returns the font resource for the bold font style\nfunc TextBoldItalicFont\r#\r\rfunc TextBoldItalicFont() fyne.Resource TextBoldItalicFont returns the font resource for the bold and italic font style\nfunc TextColor\r#\r\rfunc TextColor() color.Color TextColor returns the theme\u0026rsquo;s standard text color - this is actually the foreground color since 1.4.\nDeprecated: Use theme.ForegroundColor() colour instead\rfunc TextFont\r#\r\rfunc TextFont() fyne.Resource TextFont returns the font resource for the regular font style\nfunc TextHeadingSize\r#\r\rfunc TextHeadingSize() float32 TextHeadingSize returns the text size for header text.\nSince: \r2.1\rfunc TextItalicFont\r#\r\rfunc TextItalicFont() fyne.Resource TextItalicFont returns the font resource for the italic font style\nfunc TextMonospaceFont\r#\r\rfunc TextMonospaceFont() fyne.Resource TextMonospaceFont returns the font resource for the monospace font face\nfunc TextSize\r#\r\rfunc TextSize() float32 TextSize returns the standard text size\nfunc TextSubHeadingSize\r#\r\rfunc TextSubHeadingSize() float32 TextSubHeadingSize returns the text size for sub-header text.\nSince: \r2.1\rfunc UploadIcon\r#\r\rfunc UploadIcon() fyne.Resource UploadIcon returns a resource containing the standard upload icon for the current theme\nfunc ViewFullScreenIcon\r#\r\rfunc ViewFullScreenIcon() fyne.Resource ViewFullScreenIcon returns a resource containing the standard fullscreen icon for the current theme\nfunc ViewRefreshIcon\r#\r\rfunc ViewRefreshIcon() fyne.Resource ViewRefreshIcon returns a resource containing the standard refresh icon for the current theme\nfunc ViewRestoreIcon\r#\r\rfunc ViewRestoreIcon() fyne.Resource ViewRestoreIcon returns a resource containing the standard exit fullscreen icon for the current theme\nfunc VisibilityIcon\r#\r\rfunc VisibilityIcon() fyne.Resource VisibilityIcon returns a resource containing the standard visibility icon for the current theme\nfunc VisibilityOffIcon\r#\r\rfunc VisibilityOffIcon() fyne.Resource VisibilityOffIcon returns a resource containing the standard visibility off icon for the current theme\nfunc VolumeDownIcon\r#\r\rfunc VolumeDownIcon() fyne.Resource VolumeDownIcon returns a resource containing the standard volume down icon for the current theme\nfunc VolumeMuteIcon\r#\r\rfunc VolumeMuteIcon() fyne.Resource VolumeMuteIcon returns a resource containing the standard volume mute icon for the current theme\nfunc VolumeUpIcon\r#\r\rfunc VolumeUpIcon() fyne.Resource VolumeUpIcon returns a resource containing the standard volume up icon for the current theme\nfunc WarningIcon\r#\r\rfunc WarningIcon() fyne.Resource WarningIcon returns a resource containing the standard dialog warning icon for the current theme\nfunc ZoomFitIcon\r#\r\rfunc ZoomFitIcon() fyne.Resource ZoomFitIcon returns a resource containing the standard zoom fit icon for the current theme\nfunc ZoomInIcon\r#\r\rfunc ZoomInIcon() fyne.Resource ZoomInIcon returns a resource containing the standard zoom in icon for the current theme\nfunc ZoomOutIcon\r#\r\rfunc ZoomOutIcon() fyne.Resource ZoomOutIcon returns a resource containing the standard zoom out icon for the current theme\ntypes\r#\r\r \rDisabledResource \rErrorThemedResource \rInvertedThemedResource \rPrimaryThemedResource \rThemedResource  "},{"id":258,"href":"/fyne/docs/api/widget/","title":"theme","section":"API Documentation","content":"\r\rwidget\r\rwidget\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Package widget defines the UI widgets within the Fyne toolkit Usage\r#\rvar ( // RichTextStyleBlockquote represents a quote presented in an indented block. // // Since: 2.1 RichTextStyleBlockquote = RichTextStyle{ ColorName: theme.ColorNameForeground, Inline: false, SizeName: theme.SizeNameText, TextStyle: fyne.TextStyle{Italic: true}, } // RichTextStyleCodeBlock represents a code blog segment. // // Since: 2.\r\r\rwidget.Accordion\r\rwidget.Accordion\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Accordion\r#\rtype Accordion struct { BaseWidget Items []*AccordionItem MultiOpen bool } Accordion displays a list of AccordionItems. Each item is represented by a button that reveals a detailed view when tapped. func NewAccordion\r#\rfunc NewAccordion(items ...*AccordionItem) *Accordion NewAccordion creates a new accordion widget. func (*Accordion) Append\r#\rfunc (a *Accordion) Append(item *AccordionItem) Append adds the given item to this Accordion.\r\r\rwidget.AccordionItem\r\rwidget.AccordionItem\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype AccordionItem\r#\rtype AccordionItem struct { Title string Detail fyne.CanvasObject Open bool } AccordionItem represents a single item in an Accordion. func NewAccordionItem\r#\rfunc NewAccordionItem(title string, detail fyne.CanvasObject) *AccordionItem NewAccordionItem creates a new item for an Accordion.\r\r\rwidget.BaseWidget\r\rwidget.BaseWidget\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype BaseWidget\r#\rtype BaseWidget struct { Hidden bool } BaseWidget provides a helper that handles basic widget behaviours. func (*BaseWidget) ExtendBaseWidget\r#\rfunc (w *BaseWidget) ExtendBaseWidget(wid fyne.Widget) ExtendBaseWidget is used by an extending widget to make use of BaseWidget functionality. func (*BaseWidget) Hide\r#\rfunc (w *BaseWidget) Hide() Hide this widget so it is no longer visible\r\r\rwidget.Button\r\rwidget.Button\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Button\r#\rtype Button struct { DisableableWidget Text string Icon fyne.Resource // Specify how prominent the button should be, High will highlight the button and Low will remove some decoration. // // Since: 1.4 Importance ButtonImportance Alignment ButtonAlign IconPlacement ButtonIconPlacement OnTapped func() `json:\u0026#34;-\u0026#34;` } Button widget has a text label and triggers an event func when clicked\r\r\rwidget.ButtonAlign\r\rwidget.ButtonAlign\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ButtonAlign\r#\rtype ButtonAlign int ButtonAlign represents the horizontal alignment of a button. const ( // ButtonAlignCenter aligns the icon and the text centrally. ButtonAlignCenter ButtonAlign = iota // ButtonAlignLeading aligns the icon and the text with the leading edge. ButtonAlignLeading // ButtonAlignTrailing aligns the icon and the text with the trailing edge. ButtonAlignTrailing ) \r\rwidget.ButtonIconPlacement\r\rwidget.ButtonIconPlacement\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ButtonIconPlacement\r#\rtype ButtonIconPlacement int ButtonIconPlacement represents the ordering of icon \u0026amp; text within a button. const ( // ButtonIconLeadingText aligns the icon on the leading edge of the text. ButtonIconLeadingText ButtonIconPlacement = iota // ButtonIconTrailingText aligns the icon on the trailing edge of the text. ButtonIconTrailingText ) \r\rwidget.ButtonImportance\r\rwidget.ButtonImportance\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ButtonImportance\r#\rtype ButtonImportance int ButtonImportance represents how prominent the button should appear Since: 1.4\rconst ( // MediumImportance applies a standard appearance. MediumImportance ButtonImportance = iota // HighImportance applies a prominent appearance. HighImportance // LowImportance applies a subtle appearance. LowImportance ) \r\rwidget.ButtonStyle\r\rwidget.ButtonStyle\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ButtonStyle\r#\rtype ButtonStyle int ButtonStyle determines the behaviour and rendering of a button.\r\r\rwidget.Card\r\rwidget.Card\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Card\r#\rtype Card struct { BaseWidget Title, Subtitle string Image *canvas.Image Content fyne.CanvasObject } Card widget groups title, subtitle with content and a header image Since: 1.4\rfunc NewCard\r#\rfunc NewCard(title, subtitle string, content fyne.CanvasObject) *Card NewCard creates a new card widget with the specified title, subtitle and content (all optional).\r\r\rwidget.Check\r\rwidget.Check\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Check\r#\rtype Check struct { DisableableWidget Text string Checked bool OnChanged func(bool) `json:\u0026#34;-\u0026#34;` } Check widget has a text label and a checked (or unchecked) icon and triggers an event func when toggled func NewCheck\r#\rfunc NewCheck(label string, changed func(bool)) *Check NewCheck creates a new check widget with the set label and change handler\r\r\rwidget.CheckGroup\r\rwidget.CheckGroup\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype CheckGroup\r#\rtype CheckGroup struct { DisableableWidget Horizontal bool Required bool OnChanged func([]string) `json:\u0026#34;-\u0026#34;` Options []string Selected []string } CheckGroup widget has a list of text labels and checkbox icons next to each. Changing the selection (any number can be selected) will trigger the changed func. Since: 2.1\rfunc NewCheckGroup\r#\rfunc NewCheckGroup(options []string, changed func([]string)) *CheckGroup NewCheckGroup creates a new check group widget with the set options and change handler\r\r\rwidget.CustomTextGridStyle\r\rwidget.CustomTextGridStyle\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype CustomTextGridStyle\r#\rtype CustomTextGridStyle struct { FGColor, BGColor color.Color } CustomTextGridStyle is a utility type for those not wanting to define their own style types. func (*CustomTextGridStyle) BackgroundColor\r#\rfunc (c *CustomTextGridStyle) BackgroundColor() color.Color BackgroundColor is the color a cell should use for the background. func (*CustomTextGridStyle) TextColor\r#\rfunc (c *CustomTextGridStyle) TextColor() color.Color TextColor is the color a cell should use for the text.\r\r\rwidget.DisableableWidget\r\rwidget.DisableableWidget\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype DisableableWidget\r#\rtype DisableableWidget struct { BaseWidget } DisableableWidget describes an extension to BaseWidget which can be disabled. Disabled widgets should have a visually distinct style when disabled, normally using theme.DisabledButtonColor. func (*DisableableWidget) Disable\r#\rfunc (w *DisableableWidget) Disable() Disable this widget so that it cannot be interacted with, updating any style appropriately. func (*DisableableWidget) Disabled\r#\rfunc (w *DisableableWidget) Disabled() bool Disabled returns true if this widget is currently disabled or false if it can currently be interacted with.\r\r\rwidget.Entry\r\rwidget.Entry\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Entry\r#\rtype Entry struct { DisableableWidget Text string // Since: 2.0 TextStyle fyne.TextStyle PlaceHolder string OnChanged func(string) `json:\u0026#34;-\u0026#34;` // Since: 2.0 OnSubmitted func(string) `json:\u0026#34;-\u0026#34;` Password bool MultiLine bool Wrapping fyne.TextWrap // Set a validator that this entry will check against // Since: 1.4 Validator fyne.\r\r\rwidget.FileIcon\r\rwidget.FileIcon\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype FileIcon\r#\rtype FileIcon struct { BaseWidget Selected bool URI fyne.URI } FileIcon is an adaption of widget.Icon for showing files and folders Since: 1.4\rfunc NewFileIcon\r#\rfunc NewFileIcon(uri fyne.URI) *FileIcon NewFileIcon takes a filepath and creates an icon with an overlaid label using the detected mimetype and extension Since: 1.4\rfunc (*FileIcon) CreateRenderer\r#\rfunc (i *FileIcon) CreateRenderer() fyne.\r\r\rwidget.Form\r\rwidget.Form\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Form\r#\rtype Form struct { BaseWidget Items []*FormItem OnSubmit func() OnCancel func() SubmitText string CancelText string } Form widget is two column grid where each row has a label and a widget (usually an input). The last row of the grid will contain the appropriate form control buttons if any should be shown.\r\r\rwidget.FormItem\r\rwidget.FormItem\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype FormItem\r#\rtype FormItem struct { Text string Widget fyne.CanvasObject // Since: 2.0 HintText string } FormItem provides the details for a row in a form func NewFormItem\r#\rfunc NewFormItem(text string, widget fyne.CanvasObject) *FormItem NewFormItem creates a new form item with the specified label text and input widget\r\r\rwidget.Hyperlink\r\rwidget.Hyperlink\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Hyperlink\r#\rtype Hyperlink struct { BaseWidget Text string URL *url.URL Alignment fyne.TextAlign // The alignment of the Text Wrapping fyne.TextWrap // The wrapping of the Text TextStyle fyne.TextStyle // The style of the hyperlink text } Hyperlink widget is a text component with appropriate padding and layout. When clicked, the default web browser should open with a URL\r\r\rwidget.HyperlinkSegment\r\rwidget.HyperlinkSegment\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype HyperlinkSegment\r#\rtype HyperlinkSegment struct { Alignment fyne.TextAlign Text string URL *url.URL } HyperlinkSegment represents a hyperlink within a rich text widget. Since: 2.1\rfunc (*HyperlinkSegment) Inline\r#\rfunc (h *HyperlinkSegment) Inline() bool Inline returns true as hyperlinks are inside other elements. func (*HyperlinkSegment) Select\r#\rfunc (h *HyperlinkSegment) Select(begin, end fyne.Position) Select tells the segment that the user is selecting the content between the two positions.\r\r\rwidget.Icon\r\rwidget.Icon\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Icon\r#\rtype Icon struct { BaseWidget Resource fyne.Resource // The resource for this icon } Icon widget is a basic image component that load\u0026rsquo;s its resource to match the theme. func NewIcon\r#\rfunc NewIcon(res fyne.Resource) *Icon NewIcon returns a new icon widget that displays a themed icon resource func (*Icon) CreateRenderer\r#\rfunc (i *Icon) CreateRenderer() fyne.\r\r\rwidget.Label\r\rwidget.Label\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Label\r#\rtype Label struct { BaseWidget Text string Alignment fyne.TextAlign // The alignment of the Text Wrapping fyne.TextWrap // The wrapping of the Text TextStyle fyne.TextStyle // The style of the label text } Label widget is a label component with appropriate padding and layout. func NewLabel\r#\rfunc NewLabel(text string) *Label NewLabel creates a new label widget with the set text content\r\r\rwidget.List\r\rwidget.List\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype List\r#\rtype List struct { BaseWidget Length func() int CreateItem func() fyne.CanvasObject UpdateItem func(id ListItemID, item fyne.CanvasObject) OnSelected func(id ListItemID) OnUnselected func(id ListItemID) } List is a widget that pools list items for performance and lays the items out in a vertical direction inside of a scroller. List requires that all items are the same size.\r\r\rwidget.ListItemID\r\rwidget.ListItemID\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ListItemID\r#\rtype ListItemID = int ListItemID uniquely identifies an item within a list.\r\r\rwidget.ListSegment\r\rwidget.ListSegment\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ListSegment\r#\rtype ListSegment struct { Items []RichTextSegment Ordered bool } ListSegment includes an itemised list with the content set using the Items field. Since: 2.1\rfunc (*ListSegment) Inline\r#\rfunc (l *ListSegment) Inline() bool Inline returns false as a list should be in a block. func (*ListSegment) Segments\r#\rfunc (l *ListSegment) Segments() []RichTextSegment Segments returns the segments required to draw bullets before each item\r\r\rwidget.Menu\r\rwidget.Menu\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Menu\r#\rtype Menu struct { BaseWidget Items []fyne.CanvasObject OnDismiss func() } Menu is a widget for displaying a fyne.Menu. func NewMenu\r#\rfunc NewMenu(menu *fyne.Menu) *Menu NewMenu creates a new Menu. func (*Menu) ActivateLastSubmenu\r#\rfunc (m *Menu) ActivateLastSubmenu() bool ActivateLastSubmenu finds the last active menu item traversing through the open submenus and activates its submenu if any.\r\r\rwidget.Orientation\r\rwidget.Orientation\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Orientation\r#\rtype Orientation int Orientation controls the horizontal/vertical layout of a widget const ( Horizontal Orientation = 0 Vertical Orientation = 1 ) Orientation constants to control widget layout\r\r\rwidget.ParagraphSegment\r\rwidget.ParagraphSegment\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ParagraphSegment\r#\rtype ParagraphSegment struct { Texts []RichTextSegment } ParagraphSegment wraps a number of text elements in a paragraph. It is similar to using a list of text elements when the final style is RichTextStyleParagraph. Since: 2.1\rfunc (*ParagraphSegment) Inline\r#\rfunc (p *ParagraphSegment) Inline() bool Inline returns false as a paragraph should be in a block.\r\r\rwidget.PopUp\r\rwidget.PopUp\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype PopUp\r#\rtype PopUp struct { BaseWidget Content fyne.CanvasObject Canvas fyne.Canvas } PopUp is a widget that can float above the user interface. It wraps any standard elements with padding and a shadow. If it is modal then the shadow will cover the entire canvas it hovers over and block interactions. func NewModalPopUp\r#\rfunc NewModalPopUp(content fyne.\r\r\rwidget.PopUpMenu\r\rwidget.PopUpMenu\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype PopUpMenu\r#\rtype PopUpMenu struct { *Menu } PopUpMenu is a Menu which displays itself in an OverlayContainer. func NewPopUpMenu\r#\rfunc NewPopUpMenu(menu *fyne.Menu, c fyne.Canvas) *PopUpMenu NewPopUpMenu creates a new, reusable popup menu. You can show it using ShowAtPosition. Since: 2.0\rfunc (*PopUpMenu) FocusGained\r#\rfunc (p *PopUpMenu) FocusGained() FocusGained is triggered when the object gained focus.\r\r\rwidget.ProgressBar\r\rwidget.ProgressBar\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ProgressBar\r#\rtype ProgressBar struct { BaseWidget Min, Max, Value float64 // TextFormatter can be used to have a custom format of progress text. // If set, it overrides the percentage readout and runs each time the value updates. // // Since: 1.4 TextFormatter func() string } ProgressBar widget creates a horizontal panel that indicates progress\r\r\rwidget.ProgressBarInfinite\r\rwidget.ProgressBarInfinite\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ProgressBarInfinite\r#\rtype ProgressBarInfinite struct { BaseWidget } ProgressBarInfinite widget creates a horizontal panel that indicates waiting indefinitely An infinite progress bar loops 0% -\u0026gt; 100% repeatedly until Stop() is called func NewProgressBarInfinite\r#\rfunc NewProgressBarInfinite() *ProgressBarInfinite NewProgressBarInfinite creates a new progress bar widget that loops indefinitely from 0% -\u0026gt; 100% SetValue() is not defined for infinite progress bar To stop the looping progress and set the progress bar to 100%, call ProgressBarInfinite.\r\r\rwidget.RadioGroup\r\rwidget.RadioGroup\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype RadioGroup\r#\rtype RadioGroup struct { DisableableWidget Horizontal bool Required bool OnChanged func(string) `json:\u0026#34;-\u0026#34;` Options []string Selected string } RadioGroup widget has a list of text labels and checks check icons next to each. Changing the selection (only one can be selected) will trigger the changed func. Since: 1.4\rfunc NewRadioGroup\r#\rfunc NewRadioGroup(options []string, changed func(string)) *RadioGroup NewRadioGroup creates a new radio group widget with the set options and change handler\r\r\rwidget.RichText\r\rwidget.RichText\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype RichText\r#\rtype RichText struct { BaseWidget Segments []RichTextSegment Wrapping fyne.TextWrap Scroll widget.ScrollDirection } RichText represents the base element for a rich text-based widget. Since: 2.1\rfunc NewRichText\r#\rfunc NewRichText(segments ...RichTextSegment) *RichText NewRichText returns a new RichText widget that renders the given text and segments. If no segments are specified it will be converted to a single segment using the default text settings.\r\r\rwidget.RichTextBlock\r\rwidget.RichTextBlock\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype RichTextBlock\r#\rtype RichTextBlock interface { Segments() []RichTextSegment } RichTextBlock is an extension of a text segment that contains other segments Since: 2.1\r\r\rwidget.RichTextSegment\r\rwidget.RichTextSegment\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype RichTextSegment\r#\rtype RichTextSegment interface { Inline() bool Textual() string Update(fyne.CanvasObject) Visual() fyne.CanvasObject Select(pos1, pos2 fyne.Position) SelectedText() string Unselect() } RichTextSegment describes any element that can be rendered in a RichText widget. Since: 2.1\r\r\rwidget.RichTextStyle\r\rwidget.RichTextStyle\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype RichTextStyle\r#\rtype RichTextStyle struct { Alignment fyne.TextAlign ColorName fyne.ThemeColorName Inline bool SizeName fyne.ThemeSizeName TextStyle fyne.TextStyle } RichTextStyle describes the details of a text object inside a RichText widget. Since: 2.1\r\r\rwidget.Select\r\rwidget.Select\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Select\r#\rtype Select struct { DisableableWidget // Alignment sets the text alignment of the select and its list of options. // // Since: 2.1 Alignment fyne.TextAlign Selected string Options []string PlaceHolder string OnChanged func(string) `json:\u0026#34;-\u0026#34;` } Select widget has a list of options, with the current one shown, and triggers an event func when clicked\r\r\rwidget.SelectEntry\r\rwidget.SelectEntry\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype SelectEntry\r#\rtype SelectEntry struct { Entry } SelectEntry is an input field which supports selecting from a fixed set of options. func NewSelectEntry\r#\rfunc NewSelectEntry(options []string) *SelectEntry NewSelectEntry creates a SelectEntry. func (*SelectEntry) CreateRenderer\r#\rfunc (e *SelectEntry) CreateRenderer() fyne.WidgetRenderer CreateRenderer returns a new renderer for this select entry. Implements: fyne.Widget\rfunc (*SelectEntry) Disable\r#\rfunc (e *SelectEntry) Disable() Disable this widget so that it cannot be interacted with, updating any style appropriately.\r\r\rwidget.Separator\r\rwidget.Separator\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Separator\r#\rtype Separator struct { BaseWidget } Separator is a widget for displaying a separator with themeable color. Since: 1.4\rfunc NewSeparator\r#\rfunc NewSeparator() *Separator NewSeparator creates a new separator. Since: 1.4\rfunc (*Separator) CreateRenderer\r#\rfunc (s *Separator) CreateRenderer() fyne.WidgetRenderer CreateRenderer returns a new renderer for the separator. Implements: fyne.Widget\rfunc (*Separator) MinSize\r#\rfunc (s *Separator) MinSize() fyne.\r\r\rwidget.SeparatorSegment\r\rwidget.SeparatorSegment\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype SeparatorSegment\r#\rtype SeparatorSegment struct { } SeparatorSegment includes a horizontal separator in a rich text widget. Since: 2.1\rfunc (*SeparatorSegment) Inline\r#\rfunc (s *SeparatorSegment) Inline() bool Inline returns false as a separator should be full width. func (*SeparatorSegment) Select\r#\rfunc (s *SeparatorSegment) Select(_, _ fyne.Position) Select does nothing for a separator. func (*SeparatorSegment) SelectedText\r#\rfunc (s *SeparatorSegment) SelectedText() string SelectedText returns the empty string for this separator.\r\r\rwidget.Slider\r\rwidget.Slider\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Slider\r#\rtype Slider struct { BaseWidget Value float64 Min float64 Max float64 Step float64 Orientation Orientation OnChanged func(float64) } Slider is a widget that can slide between two fixed values. func NewSlider\r#\rfunc NewSlider(min, max float64) *Slider NewSlider returns a basic slider. func NewSliderWithData\r#\rfunc NewSliderWithData(min, max float64, data binding.\r\r\rwidget.Table\r\rwidget.Table\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Table\r#\rtype Table struct { BaseWidget Length func() (int, int) CreateCell func() fyne.CanvasObject UpdateCell func(id TableCellID, template fyne.CanvasObject) OnSelected func(id TableCellID) OnUnselected func(id TableCellID) } Table widget is a grid of items that can be scrolled and a cell selected. It\u0026rsquo;s performance is provided by caching cell templates created with CreateCell and re-using them with UpdateCell.\r\r\rwidget.TableCellID\r\rwidget.TableCellID\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype TableCellID\r#\rtype TableCellID struct { Row int Col int } TableCellID is a type that represents a cell\u0026rsquo;s position in a table based on it\u0026rsquo;s row and column location.\r\r\rwidget.TextGrid\r\rwidget.TextGrid\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype TextGrid\r#\rtype TextGrid struct { BaseWidget Rows []TextGridRow ShowLineNumbers bool ShowWhitespace bool TabWidth int // If set to 0 the fyne.DefaultTabWidth is used } TextGrid is a monospaced grid of characters. This is designed to be used by a text editor, code preview or terminal emulator. func NewTextGrid\r#\rfunc NewTextGrid() *TextGrid NewTextGrid creates a new empty TextGrid widget.\r\r\rwidget.TextGridCell\r\rwidget.TextGridCell\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype TextGridCell\r#\rtype TextGridCell struct { Rune rune Style TextGridStyle } TextGridCell represents a single cell in a text grid. It has a rune for the text content and a style associated with it.\r\r\rwidget.TextGridRow\r\rwidget.TextGridRow\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype TextGridRow\r#\rtype TextGridRow struct { Cells []TextGridCell Style TextGridStyle } TextGridRow represents a row of cells cell in a text grid. It contains the cells for the row and an optional style.\r\r\rwidget.TextGridStyle\r\rwidget.TextGridStyle\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype TextGridStyle\r#\rtype TextGridStyle interface { TextColor() color.Color BackgroundColor() color.Color } TextGridStyle defines a style that can be applied to a TextGrid cell. var ( // TextGridStyleDefault is a default style for test grid cells TextGridStyleDefault TextGridStyle // TextGridStyleWhitespace is the style used for whitespace characters, if enabled TextGridStyleWhitespace TextGridStyle ) \r\rwidget.TextSegment\r\rwidget.TextSegment\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype TextSegment\r#\rtype TextSegment struct { Style RichTextStyle Text string } TextSegment represents the styling for a segment of rich text. Since: 2.1\rfunc (*TextSegment) Inline\r#\rfunc (t *TextSegment) Inline() bool Inline should return true if this text can be included within other elements, or false if it creates a new block. func (*TextSegment) Select\r#\rfunc (t *TextSegment) Select(begin, end fyne.\r\r\rwidget.Toolbar\r\rwidget.Toolbar\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Toolbar\r#\rtype Toolbar struct { BaseWidget Items []ToolbarItem } Toolbar widget creates a horizontal list of tool buttons func NewToolbar\r#\rfunc NewToolbar(items ...ToolbarItem) *Toolbar NewToolbar creates a new toolbar widget. func (*Toolbar) Append\r#\rfunc (t *Toolbar) Append(item ToolbarItem) Append a new ToolbarItem to the end of this Toolbar func (*Toolbar) CreateRenderer\r#\rfunc (t *Toolbar) CreateRenderer() fyne.\r\r\rwidget.ToolbarAction\r\rwidget.ToolbarAction\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ToolbarAction\r#\rtype ToolbarAction struct { Icon fyne.Resource OnActivated func() `json:\u0026#34;-\u0026#34;` } ToolbarAction is push button style of ToolbarItem func (*ToolbarAction) ToolbarObject\r#\rfunc (t *ToolbarAction) ToolbarObject() fyne.CanvasObject ToolbarObject gets a button to render this ToolbarAction\r\r\rwidget.ToolbarItem\r\rwidget.ToolbarItem\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ToolbarItem\r#\rtype ToolbarItem interface { ToolbarObject() fyne.CanvasObject } ToolbarItem represents any interface element that can be added to a toolbar func NewToolbarAction\r#\rfunc NewToolbarAction(icon fyne.Resource, onActivated func()) ToolbarItem NewToolbarAction returns a new push button style ToolbarItem func NewToolbarSeparator\r#\rfunc NewToolbarSeparator() ToolbarItem NewToolbarSeparator returns a new separator item for a Toolbar to assist with ToolbarItem grouping\r\r\rwidget.ToolbarSeparator\r\rwidget.ToolbarSeparator\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ToolbarSeparator\r#\rtype ToolbarSeparator struct { } ToolbarSeparator is a thin, visible divide that can be added to a Toolbar. This is typically used to assist visual grouping of ToolbarItems. func (*ToolbarSeparator) ToolbarObject\r#\rfunc (t *ToolbarSeparator) ToolbarObject() fyne.CanvasObject ToolbarObject gets the visible line object for this ToolbarSeparator\r\r\rwidget.ToolbarSpacer\r\rwidget.ToolbarSpacer\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype ToolbarSpacer\r#\rtype ToolbarSpacer struct { } ToolbarSpacer is a blank, stretchable space for a toolbar. This is typically used to assist layout if you wish some left and some right aligned items. Space will be split evebly amongst all the spacers on a toolbar. func (*ToolbarSpacer) ToolbarObject\r#\rfunc (t *ToolbarSpacer) ToolbarObject() fyne.CanvasObject ToolbarObject gets the actual spacer object for this ToolbarSpacer\r\r\rwidget.Tree\r\rwidget.Tree\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype Tree\r#\rtype Tree struct { BaseWidget Root TreeNodeID ChildUIDs func(uid TreeNodeID) (c []TreeNodeID) // Return a sorted slice of Children TreeNodeIDs for the given Node TreeNodeID CreateNode func(branch bool) (o fyne.CanvasObject) // Return a CanvasObject that can represent a Branch (if branch is true), or a Leaf (if branch is false) IsBranch func(uid TreeNodeID) (ok bool) // Return true if the given TreeNodeID represents a Branch OnBranchClosed func(uid TreeNodeID) // Called when a Branch is closed OnBranchOpened func(uid TreeNodeID) // Called when a Branch is opened OnSelected func(uid TreeNodeID) // Called when the Node with the given TreeNodeID is selected.\r\r\rwidget.TreeNodeID\r\rwidget.TreeNodeID\r#\rimport \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\rtype TreeNodeID\r#\rtype TreeNodeID = string TreeNodeID represents the unique id of a tree node.\r\r\r"},{"id":259,"href":"/fyne/docs/api/theme/disabledresource/","title":"theme.DisabledResource","section":"widget","content":"theme.DisabledResource\r#\r\r import \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\r\rtype DisabledResource\r#\r\rtype DisabledResource struct { } DisabledResource is a resource wrapper that will return an appropriate resource colorized by the current theme\u0026rsquo;s DisabledIconColor color.\nfunc NewDisabledResource\r#\r\rfunc NewDisabledResource(res fyne.Resource) *DisabledResource NewDisabledResource creates a resource that adapts to the current theme\u0026rsquo;s DisabledIconColor setting.\nfunc (*DisabledResource) Content\r#\r\rfunc (res *DisabledResource) Content() []byte Content returns the disabled style content of the correct resource for the current theme\nfunc (*DisabledResource) Name\r#\r\rfunc (res *DisabledResource) Name() string Name returns the resource source name prefixed with disabled_ (used for caching)\n"},{"id":260,"href":"/fyne/docs/api/theme/errorthemedresource/","title":"theme.ErrorThemedResource","section":"widget","content":"theme.ErrorThemedResource\r#\r\r import \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\r\rtype ErrorThemedResource\r#\r\rtype ErrorThemedResource struct { } ErrorThemedResource is a resource wrapper that will return a version of the resource with the main color changed to indicate an error.\nfunc NewErrorThemedResource\r#\r\rfunc NewErrorThemedResource(orig fyne.Resource) *ErrorThemedResource NewErrorThemedResource creates a resource that adapts to the error color for the current theme.\nfunc (*ErrorThemedResource) Content\r#\r\rfunc (res *ErrorThemedResource) Content() []byte Content returns the underlying content of the resource adapted to the current background color.\nfunc (*ErrorThemedResource) Name\r#\r\rfunc (res *ErrorThemedResource) Name() string Name returns the underlying resource name (used for caching).\nfunc (*ErrorThemedResource) Original\r#\r\rfunc (res *ErrorThemedResource) Original() fyne.Resource Original returns the underlying resource that this error themed resource was adapted from\n"},{"id":261,"href":"/fyne/docs/api/theme/invertedthemedresource/","title":"theme.InvertedThemedResource","section":"widget","content":"theme.InvertedThemedResource\r#\r\r import \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\r\rtype InvertedThemedResource\r#\r\rtype InvertedThemedResource struct { } InvertedThemedResource is a resource wrapper that will return a version of the resource with the main color changed for use over highlighted elements.\nfunc NewInvertedThemedResource\r#\r\rfunc NewInvertedThemedResource(orig fyne.Resource) *InvertedThemedResource NewInvertedThemedResource creates a resource that adapts to the current theme for use over highlighted elements.\nfunc (*InvertedThemedResource) Content\r#\r\rfunc (res *InvertedThemedResource) Content() []byte Content returns the underlying content of the resource adapted to the current background color.\nfunc (*InvertedThemedResource) Name\r#\r\rfunc (res *InvertedThemedResource) Name() string Name returns the underlying resource name (used for caching).\nfunc (*InvertedThemedResource) Original\r#\r\rfunc (res *InvertedThemedResource) Original() fyne.Resource Original returns the underlying resource that this inverted themed resource was adapted from\n"},{"id":262,"href":"/fyne/docs/api/theme/primarythemedresource/","title":"theme.PrimaryThemedResource","section":"widget","content":"theme.PrimaryThemedResource\r#\r\r import \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\r\rtype PrimaryThemedResource\r#\r\rtype PrimaryThemedResource struct { } PrimaryThemedResource is a resource wrapper that will return a version of the resource with the main color changed to the theme primary color.\nfunc NewPrimaryThemedResource\r#\r\rfunc NewPrimaryThemedResource(orig fyne.Resource) *PrimaryThemedResource NewPrimaryThemedResource creates a resource that adapts to the primary color for the current theme.\nfunc (*PrimaryThemedResource) Content\r#\r\rfunc (res *PrimaryThemedResource) Content() []byte Content returns the underlying content of the resource adapted to the current background color.\nfunc (*PrimaryThemedResource) Name\r#\r\rfunc (res *PrimaryThemedResource) Name() string Name returns the underlying resource name (used for caching).\nfunc (*PrimaryThemedResource) Original\r#\r\rfunc (res *PrimaryThemedResource) Original() fyne.Resource Original returns the underlying resource that this primary themed resource was adapted from\n"},{"id":263,"href":"/fyne/docs/api/theme/themedresource/","title":"theme.ThemedResource","section":"widget","content":"theme.ThemedResource\r#\r\r import \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\r\rtype ThemedResource\r#\r\rtype ThemedResource struct { } ThemedResource is a resource wrapper that will return a version of the resource with the main color changed for the currently selected theme.\nfunc NewThemedResource\r#\r\rfunc NewThemedResource(src fyne.Resource) *ThemedResource NewThemedResource creates a resource that adapts to the current theme setting.\nfunc (*ThemedResource) Content\r#\r\rfunc (res *ThemedResource) Content() []byte Content returns the underlying content of the resource adapted to the current text color.\nfunc (*ThemedResource) Error\r#\r\rfunc (res *ThemedResource) Error() *ErrorThemedResource Error returns a different resource for indicating an error.\nfunc (*ThemedResource) Name\r#\r\rfunc (res *ThemedResource) Name() string Name returns the underlying resource name (used for caching).\n"},{"id":264,"href":"/fyne/docs/api/upgrading/","title":"Upgrading to v2.1","section":"API Documentation","content":"The 2.1 release is fully backward compatible with 2.0.4 and earlier, so upgrading is as simple as updating the version of code you compile with. This is different depending on whether or not you use go modules.\nModules\r#\r\rIf your project has a go.mod file then you can edit the require line to use version v2.1.0, or you can execute the following command inside the directory:\ngo get fyne.io/fyne/v2@v2.1.0 The next time you build or run your app it will be using the 2.1 release\nGOPATH\r#\r\rIf you are not using modules then you will need to update the Fyne checkout in your go source code. To do this execute the following command:\ngo get -u fyne.io/fyne/v2 Any apps without a module file will now use the 2.1 release.\nFyne command\r#\r\rAfter a major release of the Fyne toolkit it is advisable to upgrade the fyne commandline tool as well. This will bring new functionality and packaging options, and may be required to deliver certain bug fixes. You can make the upgrade by using the go get command similarly to above:\ngo get -u fyne.io/fyne/v2/cmd/fyne After that completes, check you have the new version installed by running fyne version.\nChanges\r#\r\rAlthough this release is backwards compatible so your code will compile and run as expected, there are some changes which you may notice.\n Focusable items are no longer focused automatically on Tap - you need to handle this in a Tapped function, calling: Canvas.Focus(myObj) if it should gain focus Padding in the collection widgets (List, Table, Tree) has been removed, so cells will be the size of the containing widget theme.LightTheme() and DarkTheme() have been deprecated, in preference to theme.DefaultTheme() if you require overriding user choice you can create a custom theme that extends DefaultTheme and in your Color method delegate to the DefaultTheme.Color and pass the variant you require fyne.TextStyle now has a TabWidth field, if you use unnamed struct initialisation this may require changes in your code  "},{"id":265,"href":"/fyne/docs/api/data/validation/","title":"validation","section":"data","content":"\r\rvalidation\r\rvalidation\r#\rimport \u0026#34;fyne.io/fyne/v2/data/validation\u0026#34; Package validation provides validation for data inside widgets Usage\r#\rfunc NewRegexp\r#\rfunc NewRegexp(regexpstr, reason string) fyne.StringValidator NewRegexp creates a new validator that uses regular expression parsing. The validator will return nil if valid, otherwise returns an error with a reason text. Since: 1.4\rfunc NewTime\r#\rfunc NewTime(format string) fyne.StringValidator NewTime creates a new validator that verifies times using time.\r\r\r"},{"id":266,"href":"/fyne/docs/api/data/validation/","title":"validation","section":"validation","content":"validation\r#\r\r import \u0026#34;fyne.io/fyne/v2/data/validation\u0026#34; Package validation provides validation for data inside widgets\nUsage\r#\r\rfunc NewRegexp\r#\r\rfunc NewRegexp(regexpstr, reason string) fyne.StringValidator NewRegexp creates a new validator that uses regular expression parsing. The validator will return nil if valid, otherwise returns an error with a reason text.\nSince: \r1.4\rfunc NewTime\r#\r\rfunc NewTime(format string) fyne.StringValidator NewTime creates a new validator that verifies times using time.Parse. The validator will return nil if valid, otherwise returns an error with a reason text. The reference time for the format: Mon Jan 2 15:04:05 -0700 MST 2006. See time.Parse() for more information about the reference time: https://pkg.go.dev/time#Parse\nSince: \r2.1\rtypes\r#\r\r"},{"id":267,"href":"/fyne/docs/api/theme/","title":"widget","section":"API Documentation","content":"\r\rtheme\r\rtheme\r#\rimport \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Package theme defines how a Fyne app should look when rendered Usage\r#\rconst ( // IconNameCancel is the name of theme lookup for cancel icon. // // Since: 2.0 IconNameCancel fyne.ThemeIconName = \u0026#34;cancel\u0026#34; // IconNameConfirm is the name of theme lookup for confirm icon. // // Since: 2.0 IconNameConfirm fyne.ThemeIconName = \u0026#34;confirm\u0026#34; // IconNameDelete is the name of theme lookup for delete icon.\r\r\rtheme.DisabledResource\r\rtheme.DisabledResource\r#\rimport \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\rtype DisabledResource\r#\rtype DisabledResource struct { } DisabledResource is a resource wrapper that will return an appropriate resource colorized by the current theme\u0026rsquo;s DisabledIconColor color. func NewDisabledResource\r#\rfunc NewDisabledResource(res fyne.Resource) *DisabledResource NewDisabledResource creates a resource that adapts to the current theme\u0026rsquo;s DisabledIconColor setting. func (*DisabledResource) Content\r#\rfunc (res *DisabledResource) Content() []byte Content returns the disabled style content of the correct resource for the current theme\r\r\rtheme.ErrorThemedResource\r\rtheme.ErrorThemedResource\r#\rimport \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\rtype ErrorThemedResource\r#\rtype ErrorThemedResource struct { } ErrorThemedResource is a resource wrapper that will return a version of the resource with the main color changed to indicate an error. func NewErrorThemedResource\r#\rfunc NewErrorThemedResource(orig fyne.Resource) *ErrorThemedResource NewErrorThemedResource creates a resource that adapts to the error color for the current theme. func (*ErrorThemedResource) Content\r#\rfunc (res *ErrorThemedResource) Content() []byte Content returns the underlying content of the resource adapted to the current background color.\r\r\rtheme.InvertedThemedResource\r\rtheme.InvertedThemedResource\r#\rimport \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\rtype InvertedThemedResource\r#\rtype InvertedThemedResource struct { } InvertedThemedResource is a resource wrapper that will return a version of the resource with the main color changed for use over highlighted elements. func NewInvertedThemedResource\r#\rfunc NewInvertedThemedResource(orig fyne.Resource) *InvertedThemedResource NewInvertedThemedResource creates a resource that adapts to the current theme for use over highlighted elements. func (*InvertedThemedResource) Content\r#\rfunc (res *InvertedThemedResource) Content() []byte Content returns the underlying content of the resource adapted to the current background color.\r\r\rtheme.PrimaryThemedResource\r\rtheme.PrimaryThemedResource\r#\rimport \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\rtype PrimaryThemedResource\r#\rtype PrimaryThemedResource struct { } PrimaryThemedResource is a resource wrapper that will return a version of the resource with the main color changed to the theme primary color. func NewPrimaryThemedResource\r#\rfunc NewPrimaryThemedResource(orig fyne.Resource) *PrimaryThemedResource NewPrimaryThemedResource creates a resource that adapts to the primary color for the current theme. func (*PrimaryThemedResource) Content\r#\rfunc (res *PrimaryThemedResource) Content() []byte Content returns the underlying content of the resource adapted to the current background color.\r\r\rtheme.ThemedResource\r\rtheme.ThemedResource\r#\rimport \u0026#34;fyne.io/fyne/v2/theme\u0026#34; Usage\r#\rtype ThemedResource\r#\rtype ThemedResource struct { } ThemedResource is a resource wrapper that will return a version of the resource with the main color changed for the currently selected theme. func NewThemedResource\r#\rfunc NewThemedResource(src fyne.Resource) *ThemedResource NewThemedResource creates a resource that adapts to the current theme setting. func (*ThemedResource) Content\r#\rfunc (res *ThemedResource) Content() []byte Content returns the underlying content of the resource adapted to the current text color.\r\r\r"},{"id":268,"href":"/fyne/docs/api/widget/","title":"widget","section":"theme","content":"widget\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Package widget defines the UI widgets within the Fyne toolkit\nUsage\r#\r\rvar ( \t// RichTextStyleBlockquote represents a quote presented in an indented block. \t// \t// Since: 2.1 \tRichTextStyleBlockquote = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: false, \tSizeName: theme.SizeNameText, \tTextStyle: fyne.TextStyle{Italic: true}, \t} \t// RichTextStyleCodeBlock represents a code blog segment. \t// \t// Since: 2.1 \tRichTextStyleCodeBlock = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: false, \tSizeName: theme.SizeNameText, \tTextStyle: fyne.TextStyle{Monospace: true}, \t} \t// RichTextStyleCodeInline represents an inline code segment. \t// \t// Since: 2.1 \tRichTextStyleCodeInline = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: true, \tSizeName: theme.SizeNameText, \tTextStyle: fyne.TextStyle{Monospace: true}, \t} \t// RichTextStyleEmphasis represents regular text with emphasis. \t// \t// Since: 2.1 \tRichTextStyleEmphasis = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: true, \tSizeName: theme.SizeNameText, \tTextStyle: fyne.TextStyle{Italic: true}, \t} \t// RichTextStyleHeading represents a heading text that stands on its own line. \t// \t// Since: 2.1 \tRichTextStyleHeading = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: false, \tSizeName: theme.SizeNameHeadingText, \tTextStyle: fyne.TextStyle{Bold: true}, \t} \t// RichTextStyleInline represents standard text that can be surrounded by other elements. \t// \t// Since: 2.1 \tRichTextStyleInline = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: true, \tSizeName: theme.SizeNameText, \t} \t// RichTextStyleParagraph represents standard text that should appear separate from other text. \t// \t// Since: 2.1 \tRichTextStyleParagraph = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: false, \tSizeName: theme.SizeNameText, \t} \t// RichTextStylePassword represents standard sized text where the characters are obscured. \t// \t// Since: 2.1 \tRichTextStylePassword = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: true, \tSizeName: theme.SizeNameText, \t} \t// RichTextStyleStrong represents regular text with a strong emphasis. \t// \t// Since: 2.1 \tRichTextStyleStrong = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: true, \tSizeName: theme.SizeNameText, \tTextStyle: fyne.TextStyle{Bold: true}, \t} \t// RichTextStyleSubHeading represents a sub-heading text that stands on its own line. \t// \t// Since: 2.1 \tRichTextStyleSubHeading = RichTextStyle{ \tColorName: theme.ColorNameForeground, \tInline: false, \tSizeName: theme.SizeNameSubHeadingText, \tTextStyle: fyne.TextStyle{Bold: true}, \t} ) func NewSimpleRenderer\r#\r\rfunc NewSimpleRenderer(object fyne.CanvasObject) fyne.WidgetRenderer NewSimpleRenderer creates a new SimpleRenderer to render a widget using a single fyne.CanvasObject.\nSince: \r2.1\rfunc ShowModalPopUp\r#\r\rfunc ShowModalPopUp(content fyne.CanvasObject, canvas fyne.Canvas) ShowModalPopUp creates a new popUp for the specified content and displays it on the passed canvas. A modal PopUp blocks interactions with underlying elements, covered with a semi-transparent overlay.\nfunc ShowPopUp\r#\r\rfunc ShowPopUp(content fyne.CanvasObject, canvas fyne.Canvas) ShowPopUp creates a new popUp for the specified content and displays it on the passed canvas.\nfunc ShowPopUpAtPosition\r#\r\rfunc ShowPopUpAtPosition(content fyne.CanvasObject, canvas fyne.Canvas, pos fyne.Position) ShowPopUpAtPosition creates a new popUp for the specified content at the specified absolute position. It will then display the popup on the passed canvas.\nfunc ShowPopUpMenuAtPosition\r#\r\rfunc ShowPopUpMenuAtPosition(menu *fyne.Menu, c fyne.Canvas, pos fyne.Position) ShowPopUpMenuAtPosition creates a PopUp menu populated with items from the passed menu structure. It will automatically be positioned at the provided location and shown as an overlay on the specified canvas.\ntypes\r#\r\r \rAccordion \rAccordionItem \rBaseWidget \rButton \rButtonAlign \rButtonIconPlacement \rButtonImportance \rButtonStyle \rCard \rCheck \rCheckGroup \rCustomTextGridStyle \rDisableableWidget \rEntry \rFileIcon \rForm \rFormItem \rHyperlink \rHyperlinkSegment \rIcon \rLabel \rList \rListItemID \rListSegment \rMenu \rOrientation \rParagraphSegment \rPopUp \rPopUpMenu \rProgressBar \rProgressBarInfinite \rRadioGroup \rRichText \rRichTextBlock \rRichTextSegment \rRichTextStyle \rSelect \rSelectEntry \rSeparator \rSeparatorSegment \rSlider \rTable \rTableCellID \rTextGrid \rTextGridCell \rTextGridRow \rTextGridStyle \rTextSegment \rToolbar \rToolbarAction \rToolbarItem \rToolbarSeparator \rToolbarSpacer \rTree \rTreeNodeID  "},{"id":269,"href":"/fyne/docs/api/widget/accordion/","title":"widget.Accordion","section":"theme","content":"widget.Accordion\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Accordion\r#\r\rtype Accordion struct { \tBaseWidget \tItems []*AccordionItem \tMultiOpen bool } Accordion displays a list of AccordionItems. Each item is represented by a button that reveals a detailed view when tapped.\nfunc NewAccordion\r#\r\rfunc NewAccordion(items ...*AccordionItem) *Accordion NewAccordion creates a new accordion widget.\nfunc (*Accordion) Append\r#\r\rfunc (a *Accordion) Append(item *AccordionItem) Append adds the given item to this Accordion.\nfunc (*Accordion) Close\r#\r\rfunc (a *Accordion) Close(index int) Close collapses the item at the given index.\nfunc (*Accordion) CloseAll\r#\r\rfunc (a *Accordion) CloseAll() CloseAll collapses all items.\nfunc (*Accordion) CreateRenderer\r#\r\rfunc (a *Accordion) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Accordion) MinSize\r#\r\rfunc (a *Accordion) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below.\nfunc (*Accordion) Open\r#\r\rfunc (a *Accordion) Open(index int) Open expands the item at the given index.\nfunc (*Accordion) OpenAll\r#\r\rfunc (a *Accordion) OpenAll() OpenAll expands all items.\nfunc (*Accordion) Remove\r#\r\rfunc (a *Accordion) Remove(item *AccordionItem) Remove deletes the given item from this Accordion.\nfunc (*Accordion) RemoveIndex\r#\r\rfunc (a *Accordion) RemoveIndex(index int) RemoveIndex deletes the item at the given index from this Accordion.\n"},{"id":270,"href":"/fyne/docs/api/widget/accordionitem/","title":"widget.AccordionItem","section":"theme","content":"widget.AccordionItem\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype AccordionItem\r#\r\rtype AccordionItem struct { \tTitle string \tDetail fyne.CanvasObject \tOpen bool } AccordionItem represents a single item in an Accordion.\nfunc NewAccordionItem\r#\r\rfunc NewAccordionItem(title string, detail fyne.CanvasObject) *AccordionItem NewAccordionItem creates a new item for an Accordion.\n"},{"id":271,"href":"/fyne/docs/api/widget/basewidget/","title":"widget.BaseWidget","section":"theme","content":"widget.BaseWidget\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype BaseWidget\r#\r\rtype BaseWidget struct { \tHidden bool } BaseWidget provides a helper that handles basic widget behaviours.\nfunc (*BaseWidget) ExtendBaseWidget\r#\r\rfunc (w *BaseWidget) ExtendBaseWidget(wid fyne.Widget) ExtendBaseWidget is used by an extending widget to make use of BaseWidget functionality.\nfunc (*BaseWidget) Hide\r#\r\rfunc (w *BaseWidget) Hide() Hide this widget so it is no longer visible\nfunc (*BaseWidget) MinSize\r#\r\rfunc (w *BaseWidget) MinSize() fyne.Size MinSize for the widget - it should never be resized below this value.\nfunc (*BaseWidget) Move\r#\r\rfunc (w *BaseWidget) Move(pos fyne.Position) Move the widget to a new position, relative to its parent. Note this should not be used if the widget is being managed by a Layout within a Container.\nfunc (*BaseWidget) Position\r#\r\rfunc (w *BaseWidget) Position() fyne.Position Position gets the current position of this widget, relative to its parent.\nfunc (*BaseWidget) Refresh\r#\r\rfunc (w *BaseWidget) Refresh() Refresh causes this widget to be redrawn in it\u0026rsquo;s current state\nfunc (*BaseWidget) Resize\r#\r\rfunc (w *BaseWidget) Resize(size fyne.Size) Resize sets a new size for a widget. Note this should not be used if the widget is being managed by a Layout within a Container.\nfunc (*BaseWidget) Show\r#\r\rfunc (w *BaseWidget) Show() Show this widget so it becomes visible\nfunc (*BaseWidget) Size\r#\r\rfunc (w *BaseWidget) Size() fyne.Size Size gets the current size of this widget.\nfunc (*BaseWidget) Visible\r#\r\rfunc (w *BaseWidget) Visible() bool Visible returns whether or not this widget should be visible. Note that this may not mean it is currently visible if a parent has been hidden.\n"},{"id":272,"href":"/fyne/docs/api/widget/button/","title":"widget.Button","section":"theme","content":"widget.Button\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Button\r#\r\rtype Button struct { \tDisableableWidget \tText string \tIcon fyne.Resource \t// Specify how prominent the button should be, High will highlight the button and Low will remove some decoration. \t// \t// Since: 1.4 \tImportance ButtonImportance \tAlignment ButtonAlign \tIconPlacement ButtonIconPlacement  \tOnTapped func() `json:\u0026#34;-\u0026#34;` } Button widget has a text label and triggers an event func when clicked\nfunc NewButton\r#\r\rfunc NewButton(label string, tapped func()) *Button NewButton creates a new button widget with the set label and tap handler\nfunc NewButtonWithIcon\r#\r\rfunc NewButtonWithIcon(label string, icon fyne.Resource, tapped func()) *Button NewButtonWithIcon creates a new button widget with the specified label, themed icon and tap handler\nfunc (*Button) CreateRenderer\r#\r\rfunc (b *Button) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Button) Cursor\r#\r\rfunc (b *Button) Cursor() desktop.Cursor Cursor returns the cursor type of this widget\nfunc (*Button) FocusGained\r#\r\rfunc (b *Button) FocusGained() FocusGained is a hook called by the focus handling logic after this object gained the focus.\nfunc (*Button) FocusLost\r#\r\rfunc (b *Button) FocusLost() FocusLost is a hook called by the focus handling logic after this object lost the focus.\nfunc (*Button) MinSize\r#\r\rfunc (b *Button) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*Button) MouseIn\r#\r\rfunc (b *Button) MouseIn(*desktop.MouseEvent) MouseIn is called when a desktop pointer enters the widget\nfunc (*Button) MouseMoved\r#\r\rfunc (b *Button) MouseMoved(*desktop.MouseEvent) MouseMoved is called when a desktop pointer hovers over the widget\nfunc (*Button) MouseOut\r#\r\rfunc (b *Button) MouseOut() MouseOut is called when a desktop pointer exits the widget\nfunc (*Button) SetIcon\r#\r\rfunc (b *Button) SetIcon(icon fyne.Resource) SetIcon updates the icon on a label - pass nil to hide an icon\nfunc (*Button) SetText\r#\r\rfunc (b *Button) SetText(text string) SetText allows the button label to be changed\nfunc (*Button) Tapped\r#\r\rfunc (b *Button) Tapped(*fyne.PointEvent) Tapped is called when a pointer tapped event is captured and triggers any tap handler\nfunc (*Button) TypedKey\r#\r\rfunc (b *Button) TypedKey(ev *fyne.KeyEvent) TypedKey is a hook called by the input handling logic on key events if this object is focused.\nfunc (*Button) TypedRune\r#\r\rfunc (b *Button) TypedRune(rune) TypedRune is a hook called by the input handling logic on text input events if this object is focused.\n"},{"id":273,"href":"/fyne/docs/api/widget/buttonalign/","title":"widget.ButtonAlign","section":"theme","content":"widget.ButtonAlign\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ButtonAlign\r#\r\rtype ButtonAlign int ButtonAlign represents the horizontal alignment of a button.\nconst ( \t// ButtonAlignCenter aligns the icon and the text centrally. \tButtonAlignCenter ButtonAlign = iota \t// ButtonAlignLeading aligns the icon and the text with the leading edge. \tButtonAlignLeading \t// ButtonAlignTrailing aligns the icon and the text with the trailing edge. \tButtonAlignTrailing ) "},{"id":274,"href":"/fyne/docs/api/widget/buttoniconplacement/","title":"widget.ButtonIconPlacement","section":"theme","content":"widget.ButtonIconPlacement\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ButtonIconPlacement\r#\r\rtype ButtonIconPlacement int ButtonIconPlacement represents the ordering of icon \u0026amp; text within a button.\nconst ( \t// ButtonIconLeadingText aligns the icon on the leading edge of the text. \tButtonIconLeadingText ButtonIconPlacement = iota \t// ButtonIconTrailingText aligns the icon on the trailing edge of the text. \tButtonIconTrailingText ) "},{"id":275,"href":"/fyne/docs/api/widget/buttonimportance/","title":"widget.ButtonImportance","section":"theme","content":"widget.ButtonImportance\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ButtonImportance\r#\r\rtype ButtonImportance int ButtonImportance represents how prominent the button should appear\nSince: \r1.4\rconst ( \t// MediumImportance applies a standard appearance. \tMediumImportance ButtonImportance = iota \t// HighImportance applies a prominent appearance. \tHighImportance \t// LowImportance applies a subtle appearance. \tLowImportance ) "},{"id":276,"href":"/fyne/docs/api/widget/buttonstyle/","title":"widget.ButtonStyle","section":"theme","content":"widget.ButtonStyle\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ButtonStyle\r#\r\rtype ButtonStyle int ButtonStyle determines the behaviour and rendering of a button.\n"},{"id":277,"href":"/fyne/docs/api/widget/card/","title":"widget.Card","section":"theme","content":"widget.Card\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Card\r#\r\rtype Card struct { \tBaseWidget \tTitle, Subtitle string \tImage *canvas.Image \tContent fyne.CanvasObject } Card widget groups title, subtitle with content and a header image\nSince: \r1.4\rfunc NewCard\r#\r\rfunc NewCard(title, subtitle string, content fyne.CanvasObject) *Card NewCard creates a new card widget with the specified title, subtitle and content (all optional).\nSince: \r1.4\rfunc (*Card) CreateRenderer\r#\r\rfunc (c *Card) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Card) MinSize\r#\r\rfunc (c *Card) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*Card) SetContent\r#\r\rfunc (c *Card) SetContent(obj fyne.CanvasObject) SetContent changes the body of this card to have the specified content.\nfunc (*Card) SetImage\r#\r\rfunc (c *Card) SetImage(img *canvas.Image) SetImage changes the image displayed above the title for this card.\nfunc (*Card) SetSubTitle\r#\r\rfunc (c *Card) SetSubTitle(text string) SetSubTitle updates the secondary title for this card.\nfunc (*Card) SetTitle\r#\r\rfunc (c *Card) SetTitle(text string) SetTitle updates the main title for this card.\n"},{"id":278,"href":"/fyne/docs/api/widget/check/","title":"widget.Check","section":"theme","content":"widget.Check\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Check\r#\r\rtype Check struct { \tDisableableWidget \tText string \tChecked bool  \tOnChanged func(bool) `json:\u0026#34;-\u0026#34;` } Check widget has a text label and a checked (or unchecked) icon and triggers an event func when toggled\nfunc NewCheck\r#\r\rfunc NewCheck(label string, changed func(bool)) *Check NewCheck creates a new check widget with the set label and change handler\nfunc NewCheckWithData\r#\r\rfunc NewCheckWithData(label string, data binding.Bool) *Check NewCheckWithData returns a check widget connected with the specified data source.\nSince: \r2.0\rfunc (*Check) Bind\r#\r\rfunc (c *Check) Bind(data binding.Bool) Bind connects the specified data source to this Check. The current value will be displayed and any changes in the data will cause the widget to update. User interactions with this Check will set the value into the data source.\nSince: \r2.0\rfunc (*Check) CreateRenderer\r#\r\rfunc (c *Check) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Check) FocusGained\r#\r\rfunc (c *Check) FocusGained() FocusGained is called when the Check has been given focus.\nfunc (*Check) FocusLost\r#\r\rfunc (c *Check) FocusLost() FocusLost is called when the Check has had focus removed.\nfunc (*Check) Hide\r#\r\rfunc (c *Check) Hide() Hide this widget, if it was previously visible\nfunc (*Check) MinSize\r#\r\rfunc (c *Check) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*Check) MouseIn\r#\r\rfunc (c *Check) MouseIn(*desktop.MouseEvent) MouseIn is called when a desktop pointer enters the widget\nfunc (*Check) MouseMoved\r#\r\rfunc (c *Check) MouseMoved(*desktop.MouseEvent) MouseMoved is called when a desktop pointer hovers over the widget\nfunc (*Check) MouseOut\r#\r\rfunc (c *Check) MouseOut() MouseOut is called when a desktop pointer exits the widget\nfunc (*Check) SetChecked\r#\r\rfunc (c *Check) SetChecked(checked bool) SetChecked sets the the checked state and refreshes widget\nfunc (*Check) Tapped\r#\r\rfunc (c *Check) Tapped(*fyne.PointEvent) Tapped is called when a pointer tapped event is captured and triggers any change handler\nfunc (*Check) TypedKey\r#\r\rfunc (c *Check) TypedKey(key *fyne.KeyEvent) TypedKey receives key input events when the Check is focused.\nfunc (*Check) TypedRune\r#\r\rfunc (c *Check) TypedRune(r rune) TypedRune receives text input events when the Check is focused.\nfunc (*Check) Unbind\r#\r\rfunc (c *Check) Unbind() Unbind disconnects any configured data source from this Check. The current value will remain at the last value of the data source.\nSince: \r2.0\r"},{"id":279,"href":"/fyne/docs/api/widget/checkgroup/","title":"widget.CheckGroup","section":"theme","content":"widget.CheckGroup\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype CheckGroup\r#\r\rtype CheckGroup struct { \tDisableableWidget \tHorizontal bool \tRequired bool \tOnChanged func([]string) `json:\u0026#34;-\u0026#34;` \tOptions []string \tSelected []string } CheckGroup widget has a list of text labels and checkbox icons next to each. Changing the selection (any number can be selected) will trigger the changed func.\nSince: \r2.1\rfunc NewCheckGroup\r#\r\rfunc NewCheckGroup(options []string, changed func([]string)) *CheckGroup NewCheckGroup creates a new check group widget with the set options and change handler\nSince: \r2.1\rfunc (*CheckGroup) Append\r#\r\rfunc (r *CheckGroup) Append(option string) Append adds a new option to the end of a CheckGroup widget.\nfunc (*CheckGroup) CreateRenderer\r#\r\rfunc (r *CheckGroup) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*CheckGroup) MinSize\r#\r\rfunc (r *CheckGroup) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*CheckGroup) Refresh\r#\r\rfunc (r *CheckGroup) Refresh() Refresh causes this widget to be redrawn in it\u0026rsquo;s current state.\nImplements: \rfyne.CanvasObject\rfunc (*CheckGroup) SetSelected\r#\r\rfunc (r *CheckGroup) SetSelected(options []string) SetSelected sets the checked options, it can be used to set a default option.\n"},{"id":280,"href":"/fyne/docs/api/widget/customtextgridstyle/","title":"widget.CustomTextGridStyle","section":"theme","content":"widget.CustomTextGridStyle\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype CustomTextGridStyle\r#\r\rtype CustomTextGridStyle struct { \tFGColor, BGColor color.Color } CustomTextGridStyle is a utility type for those not wanting to define their own style types.\nfunc (*CustomTextGridStyle) BackgroundColor\r#\r\rfunc (c *CustomTextGridStyle) BackgroundColor() color.Color BackgroundColor is the color a cell should use for the background.\nfunc (*CustomTextGridStyle) TextColor\r#\r\rfunc (c *CustomTextGridStyle) TextColor() color.Color TextColor is the color a cell should use for the text.\n"},{"id":281,"href":"/fyne/docs/api/widget/disableablewidget/","title":"widget.DisableableWidget","section":"theme","content":"widget.DisableableWidget\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype DisableableWidget\r#\r\rtype DisableableWidget struct { \tBaseWidget } DisableableWidget describes an extension to BaseWidget which can be disabled. Disabled widgets should have a visually distinct style when disabled, normally using theme.DisabledButtonColor.\nfunc (*DisableableWidget) Disable\r#\r\rfunc (w *DisableableWidget) Disable() Disable this widget so that it cannot be interacted with, updating any style appropriately.\nfunc (*DisableableWidget) Disabled\r#\r\rfunc (w *DisableableWidget) Disabled() bool Disabled returns true if this widget is currently disabled or false if it can currently be interacted with.\nfunc (*DisableableWidget) Enable\r#\r\rfunc (w *DisableableWidget) Enable() Enable this widget, updating any style or features appropriately.\n"},{"id":282,"href":"/fyne/docs/api/widget/entry/","title":"widget.Entry","section":"theme","content":"widget.Entry\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Entry\r#\r\rtype Entry struct { \tDisableableWidget  \tText string \t// Since: 2.0 \tTextStyle fyne.TextStyle \tPlaceHolder string \tOnChanged func(string) `json:\u0026#34;-\u0026#34;` \t// Since: 2.0 \tOnSubmitted func(string) `json:\u0026#34;-\u0026#34;` \tPassword bool \tMultiLine bool \tWrapping fyne.TextWrap  \t// Set a validator that this entry will check against \t// Since: 1.4 \tValidator fyne.StringValidator `json:\u0026#34;-\u0026#34;`  \tCursorRow, CursorColumn int \tOnCursorChanged func() `json:\u0026#34;-\u0026#34;`  \t// ActionItem is a small item which is displayed at the outer right of the entry (like a password revealer) \tActionItem fyne.CanvasObject `json:\u0026#34;-\u0026#34;` } Entry widget allows simple text to be input when focused.\nfunc NewEntry\r#\r\rfunc NewEntry() *Entry NewEntry creates a new single line entry widget.\nfunc NewEntryWithData\r#\r\rfunc NewEntryWithData(data binding.String) *Entry NewEntryWithData returns an Entry widget connected to the specified data source.\nSince: \r2.0\rfunc NewMultiLineEntry\r#\r\rfunc NewMultiLineEntry() *Entry NewMultiLineEntry creates a new entry that allows multiple lines\nfunc NewPasswordEntry\r#\r\rfunc NewPasswordEntry() *Entry NewPasswordEntry creates a new entry password widget\nfunc (*Entry) AcceptsTab\r#\r\rfunc (e *Entry) AcceptsTab() bool AcceptsTab returns if Entry accepts the Tab key or not.\nImplements: \rfyne.Tabbable\rSince: \r2.1\rfunc (*Entry) Bind\r#\r\rfunc (e *Entry) Bind(data binding.String) Bind connects the specified data source to this Entry. The current value will be displayed and any changes in the data will cause the widget to update. User interactions with this Entry will set the value into the data source.\nSince: \r2.0\rfunc (*Entry) CreateRenderer\r#\r\rfunc (e *Entry) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nImplements: \rfyne.Widget\rfunc (*Entry) Cursor\r#\r\rfunc (e *Entry) Cursor() desktop.Cursor Cursor returns the cursor type of this widget\nImplements: \rdesktop.Cursorable\rfunc (*Entry) Disable\r#\r\rfunc (e *Entry) Disable() Disable this widget so that it cannot be interacted with, updating any style appropriately.\nImplements: \rfyne.Disableable\rfunc (*Entry) Disabled\r#\r\rfunc (e *Entry) Disabled() bool Disabled returns whether the entry is disabled or read-only.\nImplements: \rfyne.Disableable\rfunc (*Entry) DoubleTapped\r#\r\rfunc (e *Entry) DoubleTapped(p *fyne.PointEvent) DoubleTapped is called when this entry has been double tapped so we should select text below the pointer\nImplements: \rfyne.DoubleTappable\rfunc (*Entry) DragEnd\r#\r\rfunc (e *Entry) DragEnd() DragEnd is called at end of a drag event.\nImplements: \rfyne.Draggable\rfunc (*Entry) Dragged\r#\r\rfunc (e *Entry) Dragged(d *fyne.DragEvent) Dragged is called when the pointer moves while a button is held down. It updates the selection accordingly.\nImplements: \rfyne.Draggable\rfunc (*Entry) Enable\r#\r\rfunc (e *Entry) Enable() Enable this widget, updating any style or features appropriately.\nImplements: \rfyne.Disableable\rfunc (*Entry) ExtendBaseWidget\r#\r\rfunc (e *Entry) ExtendBaseWidget(wid fyne.Widget) ExtendBaseWidget is used by an extending widget to make use of BaseWidget functionality.\nfunc (*Entry) FocusGained\r#\r\rfunc (e *Entry) FocusGained() FocusGained is called when the Entry has been given focus.\nImplements: \rfyne.Focusable\rfunc (*Entry) FocusLost\r#\r\rfunc (e *Entry) FocusLost() FocusLost is called when the Entry has had focus removed.\nImplements: \rfyne.Focusable\rfunc (*Entry) Hide\r#\r\rfunc (e *Entry) Hide() Hide hides the entry.\nImplements: \rfyne.Widget\rfunc (*Entry) KeyDown\r#\r\rfunc (e *Entry) KeyDown(key *fyne.KeyEvent) KeyDown handler for keypress events - used to store shift modifier state for text selection\nImplements: \rdesktop.Keyable\rfunc (*Entry) KeyUp\r#\r\rfunc (e *Entry) KeyUp(key *fyne.KeyEvent) KeyUp handler for key release events - used to reset shift modifier state for text selection\nImplements: \rdesktop.Keyable\rfunc (*Entry) Keyboard\r#\r\rfunc (e *Entry) Keyboard() mobile.KeyboardType Keyboard implements the Keyboardable interface\nImplements: \rmobile.Keyboardable\rfunc (*Entry) MinSize\r#\r\rfunc (e *Entry) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below.\nImplements: \rfyne.Widget\rfunc (*Entry) MouseDown\r#\r\rfunc (e *Entry) MouseDown(m *desktop.MouseEvent) MouseDown called on mouse click, this triggers a mouse click which can move the cursor, update the existing selection (if shift is held), or start a selection dragging operation.\nImplements: \rdesktop.Mouseable\rfunc (*Entry) MouseUp\r#\r\rfunc (e *Entry) MouseUp(m *desktop.MouseEvent) MouseUp called on mouse release If a mouse drag event has completed then check to see if it has resulted in an empty selection, if so, and if a text select key isn\u0026rsquo;t held, then disable selecting\nImplements: \rdesktop.Mouseable\rfunc (*Entry) SelectedText\r#\r\rfunc (e *Entry) SelectedText() string SelectedText returns the text currently selected in this Entry. If there is no selection it will return the empty string.\nfunc (*Entry) SetOnValidationChanged\r#\r\rfunc (e *Entry) SetOnValidationChanged(callback func(error)) SetOnValidationChanged is intended for parent widgets or containers to hook into the validation. The function might be overwritten by a parent that cares about child validation (e.g. widget.Form).\nfunc (*Entry) SetPlaceHolder\r#\r\rfunc (e *Entry) SetPlaceHolder(text string) SetPlaceHolder sets the text that will be displayed if the entry is otherwise empty\nfunc (*Entry) SetText\r#\r\rfunc (e *Entry) SetText(text string) SetText manually sets the text of the Entry to the given text value.\nfunc (*Entry) SetValidationError\r#\r\rfunc (e *Entry) SetValidationError(err error) SetValidationError manually updates the validation status until the next input change\nfunc (*Entry) Tapped\r#\r\rfunc (e *Entry) Tapped(ev *fyne.PointEvent) Tapped is called when this entry has been tapped. We update the cursor position in device-specific callbacks (MouseDown() and TouchDown()).\nImplements: \rfyne.Tappable\rfunc (*Entry) TappedSecondary\r#\r\rfunc (e *Entry) TappedSecondary(pe *fyne.PointEvent) TappedSecondary is called when right or alternative tap is invoked.\nOpens the PopUpMenu with Paste item to paste text from the clipboard.\nImplements: \rfyne.SecondaryTappable\rfunc (*Entry) TouchCancel\r#\r\rfunc (e *Entry) TouchCancel(*mobile.TouchEvent) TouchCancel is called when this entry gets a touch cancel event on mobile device (app was removed from focus).\nSince: \r2.1\rImplements: \rmobile.Touchable\rfunc (*Entry) TouchDown\r#\r\rfunc (e *Entry) TouchDown(ev *mobile.TouchEvent) TouchDown is called when this entry gets a touch down event on mobile device, we ensure we have focus.\nSince: \r2.1\rImplements: \rmobile.Touchable\rfunc (*Entry) TouchUp\r#\r\rfunc (e *Entry) TouchUp(*mobile.TouchEvent) TouchUp is called when this entry gets a touch up event on mobile device.\nSince: \r2.1\rImplements: \rmobile.Touchable\rfunc (*Entry) TypedKey\r#\r\rfunc (e *Entry) TypedKey(key *fyne.KeyEvent) TypedKey receives key input events when the Entry widget is focused.\nImplements: \rfyne.Focusable\rfunc (*Entry) TypedRune\r#\r\rfunc (e *Entry) TypedRune(r rune) TypedRune receives text input events when the Entry widget is focused.\nImplements: \rfyne.Focusable\rfunc (*Entry) TypedShortcut\r#\r\rfunc (e *Entry) TypedShortcut(shortcut fyne.Shortcut) TypedShortcut implements the Shortcutable interface\nImplements: \rfyne.Shortcutable\rfunc (*Entry) Unbind\r#\r\rfunc (e *Entry) Unbind() Unbind disconnects any configured data source from this Entry. The current value will remain at the last value of the data source.\nSince: \r2.0\rfunc (*Entry) Validate\r#\r\rfunc (e *Entry) Validate() error Validate validates the current text in the widget\n"},{"id":283,"href":"/fyne/docs/api/widget/fileicon/","title":"widget.FileIcon","section":"theme","content":"widget.FileIcon\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype FileIcon\r#\r\rtype FileIcon struct { \tBaseWidget  \tSelected bool \tURI fyne.URI } FileIcon is an adaption of widget.Icon for showing files and folders\nSince: \r1.4\rfunc NewFileIcon\r#\r\rfunc NewFileIcon(uri fyne.URI) *FileIcon NewFileIcon takes a filepath and creates an icon with an overlaid label using the detected mimetype and extension\nSince: \r1.4\rfunc (*FileIcon) CreateRenderer\r#\r\rfunc (i *FileIcon) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*FileIcon) MinSize\r#\r\rfunc (i *FileIcon) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*FileIcon) SetSelected\r#\r\rfunc (i *FileIcon) SetSelected(selected bool) SetSelected makes the file look like it is selected.\nDeprecated: Selection is now handled externally.\rfunc (*FileIcon) SetURI\r#\r\rfunc (i *FileIcon) SetURI(uri fyne.URI) SetURI changes the URI and makes the icon reflect a different file\n"},{"id":284,"href":"/fyne/docs/api/widget/form/","title":"widget.Form","section":"theme","content":"widget.Form\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Form\r#\r\rtype Form struct { \tBaseWidget  \tItems []*FormItem \tOnSubmit func() \tOnCancel func() \tSubmitText string \tCancelText string } Form widget is two column grid where each row has a label and a widget (usually an input). The last row of the grid will contain the appropriate form control buttons if any should be shown. Setting OnSubmit will set the submit button to be visible and call back the function when tapped. Setting OnCancel will do the same for a cancel button. If you change OnSubmit/OnCancel after the form is created and rendered, you need to call Refresh() to update the form with the correct buttons. Setting OnSubmit/OnCancel to nil will remove the buttons.\nfunc NewForm\r#\r\rfunc NewForm(items ...*FormItem) *Form NewForm creates a new form widget with the specified rows of form items and (if any of them should be shown) a form controls row at the bottom\nfunc (*Form) Append\r#\r\rfunc (f *Form) Append(text string, widget fyne.CanvasObject) Append adds a new row to the form, using the text as a label next to the specified Widget\nfunc (*Form) AppendItem\r#\r\rfunc (f *Form) AppendItem(item *FormItem) AppendItem adds the specified row to the end of the Form\nfunc (*Form) CreateRenderer\r#\r\rfunc (f *Form) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Form) Disable\r#\r\rfunc (f *Form) Disable() Disable disables submitting this form.\nSince: \r2.1\rfunc (*Form) Disabled\r#\r\rfunc (f *Form) Disabled() bool Disabled returns whether submitting the form is disabled. Note that, if the form fails validation, the submit button may be disabled even if this method returns true.\nSince: \r2.1\rfunc (*Form) Enable\r#\r\rfunc (f *Form) Enable() Enable enables submitting this form.\nSince: \r2.1\rfunc (*Form) MinSize\r#\r\rfunc (f *Form) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*Form) Refresh\r#\r\rfunc (f *Form) Refresh() Refresh updates the widget state when requested.\n"},{"id":285,"href":"/fyne/docs/api/widget/formitem/","title":"widget.FormItem","section":"theme","content":"widget.FormItem\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype FormItem\r#\r\rtype FormItem struct { \tText string \tWidget fyne.CanvasObject  \t// Since: 2.0 \tHintText string } FormItem provides the details for a row in a form\nfunc NewFormItem\r#\r\rfunc NewFormItem(text string, widget fyne.CanvasObject) *FormItem NewFormItem creates a new form item with the specified label text and input widget\n"},{"id":286,"href":"/fyne/docs/api/widget/hyperlink/","title":"widget.Hyperlink","section":"theme","content":"widget.Hyperlink\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Hyperlink\r#\r\rtype Hyperlink struct { \tBaseWidget \tText string \tURL *url.URL \tAlignment fyne.TextAlign // The alignment of the Text \tWrapping fyne.TextWrap // The wrapping of the Text \tTextStyle fyne.TextStyle // The style of the hyperlink text } Hyperlink widget is a text component with appropriate padding and layout. When clicked, the default web browser should open with a URL\nfunc NewHyperlink\r#\r\rfunc NewHyperlink(text string, url *url.URL) *Hyperlink NewHyperlink creates a new hyperlink widget with the set text content\nfunc NewHyperlinkWithStyle\r#\r\rfunc NewHyperlinkWithStyle(text string, url *url.URL, alignment fyne.TextAlign, style fyne.TextStyle) *Hyperlink NewHyperlinkWithStyle creates a new hyperlink widget with the set text content\nfunc (*Hyperlink) CreateRenderer\r#\r\rfunc (hl *Hyperlink) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Hyperlink) Cursor\r#\r\rfunc (hl *Hyperlink) Cursor() desktop.Cursor Cursor returns the cursor type of this widget\nfunc (*Hyperlink) FocusGained\r#\r\rfunc (hl *Hyperlink) FocusGained() FocusGained is a hook called by the focus handling logic after this object gained the focus.\nfunc (*Hyperlink) FocusLost\r#\r\rfunc (hl *Hyperlink) FocusLost() FocusLost is a hook called by the focus handling logic after this object lost the focus.\nfunc (*Hyperlink) MinSize\r#\r\rfunc (hl *Hyperlink) MinSize() fyne.Size MinSize returns the smallest size this widget can shrink to\nfunc (*Hyperlink) MouseIn\r#\r\rfunc (hl *Hyperlink) MouseIn(*desktop.MouseEvent) MouseIn is a hook that is called if the mouse pointer enters the element.\nfunc (*Hyperlink) MouseMoved\r#\r\rfunc (hl *Hyperlink) MouseMoved(*desktop.MouseEvent) MouseMoved is a hook that is called if the mouse pointer moved over the element.\nfunc (*Hyperlink) MouseOut\r#\r\rfunc (hl *Hyperlink) MouseOut() MouseOut is a hook that is called if the mouse pointer leaves the element.\nfunc (*Hyperlink) Refresh\r#\r\rfunc (hl *Hyperlink) Refresh() Refresh triggers a redraw of the hyperlink.\nImplements: \rfyne.Widget\rfunc (*Hyperlink) Resize\r#\r\rfunc (hl *Hyperlink) Resize(size fyne.Size) Resize sets a new size for the hyperlink. Note this should not be used if the widget is being managed by a Layout within a Container.\nfunc (*Hyperlink) SetText\r#\r\rfunc (hl *Hyperlink) SetText(text string) SetText sets the text of the hyperlink\nfunc (*Hyperlink) SetURL\r#\r\rfunc (hl *Hyperlink) SetURL(url *url.URL) SetURL sets the URL of the hyperlink, taking in a URL type\nfunc (*Hyperlink) SetURLFromString\r#\r\rfunc (hl *Hyperlink) SetURLFromString(str string) error SetURLFromString sets the URL of the hyperlink, taking in a string type\nfunc (*Hyperlink) Tapped\r#\r\rfunc (hl *Hyperlink) Tapped(*fyne.PointEvent) Tapped is called when a pointer tapped event is captured and triggers any change handler\nfunc (*Hyperlink) TypedKey\r#\r\rfunc (hl *Hyperlink) TypedKey(ev *fyne.KeyEvent) TypedKey is a hook called by the input handling logic on key events if this object is focused.\nfunc (*Hyperlink) TypedRune\r#\r\rfunc (hl *Hyperlink) TypedRune(rune) TypedRune is a hook called by the input handling logic on text input events if this object is focused.\n"},{"id":287,"href":"/fyne/docs/api/widget/hyperlinksegment/","title":"widget.HyperlinkSegment","section":"theme","content":"widget.HyperlinkSegment\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype HyperlinkSegment\r#\r\rtype HyperlinkSegment struct { \tAlignment fyne.TextAlign \tText string \tURL *url.URL } HyperlinkSegment represents a hyperlink within a rich text widget.\nSince: \r2.1\rfunc (*HyperlinkSegment) Inline\r#\r\rfunc (h *HyperlinkSegment) Inline() bool Inline returns true as hyperlinks are inside other elements.\nfunc (*HyperlinkSegment) Select\r#\r\rfunc (h *HyperlinkSegment) Select(begin, end fyne.Position) Select tells the segment that the user is selecting the content between the two positions.\nfunc (*HyperlinkSegment) SelectedText\r#\r\rfunc (h *HyperlinkSegment) SelectedText() string SelectedText should return the text representation of any content currently selected through the Select call.\nfunc (*HyperlinkSegment) Textual\r#\r\rfunc (h *HyperlinkSegment) Textual() string Textual returns the content of this segment rendered to plain text.\nfunc (*HyperlinkSegment) Unselect\r#\r\rfunc (h *HyperlinkSegment) Unselect() Unselect tells the segment that the user is has cancelled the previous selection.\nfunc (*HyperlinkSegment) Update\r#\r\rfunc (h *HyperlinkSegment) Update(o fyne.CanvasObject) Update applies the current state of this hyperlink segment to an existing visual.\nfunc (*HyperlinkSegment) Visual\r#\r\rfunc (h *HyperlinkSegment) Visual() fyne.CanvasObject Visual returns the hyperlink widget required to render this segment.\n"},{"id":288,"href":"/fyne/docs/api/widget/icon/","title":"widget.Icon","section":"theme","content":"widget.Icon\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Icon\r#\r\rtype Icon struct { \tBaseWidget  \tResource fyne.Resource // The resource for this icon } Icon widget is a basic image component that load\u0026rsquo;s its resource to match the theme.\nfunc NewIcon\r#\r\rfunc NewIcon(res fyne.Resource) *Icon NewIcon returns a new icon widget that displays a themed icon resource\nfunc (*Icon) CreateRenderer\r#\r\rfunc (i *Icon) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Icon) MinSize\r#\r\rfunc (i *Icon) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*Icon) SetResource\r#\r\rfunc (i *Icon) SetResource(res fyne.Resource) SetResource updates the resource rendered in this icon widget\n"},{"id":289,"href":"/fyne/docs/api/widget/label/","title":"widget.Label","section":"theme","content":"widget.Label\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Label\r#\r\rtype Label struct { \tBaseWidget \tText string \tAlignment fyne.TextAlign // The alignment of the Text \tWrapping fyne.TextWrap // The wrapping of the Text \tTextStyle fyne.TextStyle // The style of the label text } Label widget is a label component with appropriate padding and layout.\nfunc NewLabel\r#\r\rfunc NewLabel(text string) *Label NewLabel creates a new label widget with the set text content\nfunc NewLabelWithData\r#\r\rfunc NewLabelWithData(data binding.String) *Label NewLabelWithData returns an Label widget connected to the specified data source.\nSince: \r2.0\rfunc NewLabelWithStyle\r#\r\rfunc NewLabelWithStyle(text string, alignment fyne.TextAlign, style fyne.TextStyle) *Label NewLabelWithStyle creates a new label widget with the set text content\nfunc (*Label) Bind\r#\r\rfunc (l *Label) Bind(data binding.String) Bind connects the specified data source to this Label. The current value will be displayed and any changes in the data will cause the widget to update.\nSince: \r2.0\rfunc (*Label) CreateRenderer\r#\r\rfunc (l *Label) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Label) ExtendBaseWidget\r#\r\rfunc (l *Label) ExtendBaseWidget(w fyne.Widget) ExtendBaseWidget is used by an extending widget to make use of BaseWidget functionality.\nfunc (*Label) MinSize\r#\r\rfunc (l *Label) MinSize() fyne.Size MinSize returns the size that this label should not shrink below.\nImplements: \rfyne.Widget\rfunc (*Label) Refresh\r#\r\rfunc (l *Label) Refresh() Refresh triggers a redraw of the label.\nImplements: \rfyne.Widget\rfunc (*Label) Resize\r#\r\rfunc (l *Label) Resize(s fyne.Size) Resize sets a new size for the label. This should only be called if it is not in a container with a layout manager.\nImplements: \rfyne.Widget\rfunc (*Label) SetText\r#\r\rfunc (l *Label) SetText(text string) SetText sets the text of the label\nfunc (*Label) Unbind\r#\r\rfunc (l *Label) Unbind() Unbind disconnects any configured data source from this Label. The current value will remain at the last value of the data source.\nSince: \r2.0\r"},{"id":290,"href":"/fyne/docs/api/widget/list/","title":"widget.List","section":"theme","content":"widget.List\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype List\r#\r\rtype List struct { \tBaseWidget  \tLength func() int \tCreateItem func() fyne.CanvasObject \tUpdateItem func(id ListItemID, item fyne.CanvasObject) \tOnSelected func(id ListItemID) \tOnUnselected func(id ListItemID) } List is a widget that pools list items for performance and lays the items out in a vertical direction inside of a scroller. List requires that all items are the same size.\nSince: \r1.4\rfunc NewList\r#\r\rfunc NewList(length func() int, createItem func() fyne.CanvasObject, updateItem func(ListItemID, fyne.CanvasObject)) *List NewList creates and returns a list widget for displaying items in a vertical layout with scrolling and caching for performance.\nSince: \r1.4\rfunc NewListWithData\r#\r\rfunc NewListWithData(data binding.DataList, createItem func() fyne.CanvasObject, updateItem func(binding.DataItem, fyne.CanvasObject)) *List NewListWithData creates a new list widget that will display the contents of the provided data.\nSince: \r2.0\rfunc (*List) CreateRenderer\r#\r\rfunc (l *List) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer.\nfunc (*List) MinSize\r#\r\rfunc (l *List) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below.\nfunc (*List) Resize\r#\r\rfunc (l *List) Resize(s fyne.Size) Resize is called when this list should change size. We refresh to ensure invisible items are drawn.\nfunc (*List) ScrollTo\r#\r\rfunc (l *List) ScrollTo(id ListItemID) ScrollTo scrolls to the item represented by id\nSince: \r2.1\rfunc (*List) ScrollToBottom\r#\r\rfunc (l *List) ScrollToBottom() ScrollToBottom scrolls to the end of the list\nSince: \r2.1\rfunc (*List) ScrollToTop\r#\r\rfunc (l *List) ScrollToTop() ScrollToTop scrolls to the start of the list\nSince: \r2.1\rfunc (*List) Select\r#\r\rfunc (l *List) Select(id ListItemID) Select add the item identified by the given ID to the selection.\nfunc (*List) Unselect\r#\r\rfunc (l *List) Unselect(id ListItemID) Unselect removes the item identified by the given ID from the selection.\nfunc (*List) UnselectAll\r#\r\rfunc (l *List) UnselectAll() UnselectAll removes all items from the selection.\nSince: \r2.1\r"},{"id":291,"href":"/fyne/docs/api/widget/listitemid/","title":"widget.ListItemID","section":"theme","content":"widget.ListItemID\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ListItemID\r#\r\rtype ListItemID = int ListItemID uniquely identifies an item within a list.\n"},{"id":292,"href":"/fyne/docs/api/widget/listsegment/","title":"widget.ListSegment","section":"theme","content":"widget.ListSegment\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ListSegment\r#\r\rtype ListSegment struct { \tItems []RichTextSegment \tOrdered bool } ListSegment includes an itemised list with the content set using the Items field.\nSince: \r2.1\rfunc (*ListSegment) Inline\r#\r\rfunc (l *ListSegment) Inline() bool Inline returns false as a list should be in a block.\nfunc (*ListSegment) Segments\r#\r\rfunc (l *ListSegment) Segments() []RichTextSegment Segments returns the segments required to draw bullets before each item\nfunc (*ListSegment) Select\r#\r\rfunc (l *ListSegment) Select(_, _ fyne.Position) Select does nothing for a list container.\nfunc (*ListSegment) SelectedText\r#\r\rfunc (l *ListSegment) SelectedText() string SelectedText returns the empty string for this list.\nfunc (*ListSegment) Textual\r#\r\rfunc (l *ListSegment) Textual() string Textual returns no content for a list as the content is in sub-segments.\nfunc (*ListSegment) Unselect\r#\r\rfunc (l *ListSegment) Unselect() Unselect does nothing for a list container.\nfunc (*ListSegment) Update\r#\r\rfunc (l *ListSegment) Update(fyne.CanvasObject) Update doesnt need to change a list visual.\nfunc (*ListSegment) Visual\r#\r\rfunc (l *ListSegment) Visual() fyne.CanvasObject Visual returns no additional elements for this segment.\n"},{"id":293,"href":"/fyne/docs/api/widget/menu/","title":"widget.Menu","section":"theme","content":"widget.Menu\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Menu\r#\r\rtype Menu struct { \tBaseWidget  \tItems []fyne.CanvasObject \tOnDismiss func() } Menu is a widget for displaying a fyne.Menu.\nfunc NewMenu\r#\r\rfunc NewMenu(menu *fyne.Menu) *Menu NewMenu creates a new Menu.\nfunc (*Menu) ActivateLastSubmenu\r#\r\rfunc (m *Menu) ActivateLastSubmenu() bool ActivateLastSubmenu finds the last active menu item traversing through the open submenus and activates its submenu if any. It returns true if there was a submenu and it was activated and false elsewhere. Activating a submenu does show it and activate its first item.\nfunc (*Menu) ActivateNext\r#\r\rfunc (m *Menu) ActivateNext() ActivateNext activates the menu item following the currently active menu item. If there is no menu item active, it activates the first menu item. If there is no menu item after the current active one, it does nothing. If a submenu is open, it delegates the activation to this submenu.\nfunc (*Menu) ActivatePrevious\r#\r\rfunc (m *Menu) ActivatePrevious() ActivatePrevious activates the menu item preceding the currently active menu item. If there is no menu item active, it activates the last menu item. If there is no menu item before the current active one, it does nothing. If a submenu is open, it delegates the activation to this submenu.\nfunc (*Menu) CreateRenderer\r#\r\rfunc (m *Menu) CreateRenderer() fyne.WidgetRenderer CreateRenderer returns a new renderer for the menu.\nImplements: \rfyne.Widget\rfunc (*Menu) DeactivateChild\r#\r\rfunc (m *Menu) DeactivateChild() DeactivateChild deactivates the active menu item and hides its submenu if any.\nfunc (*Menu) DeactivateLastSubmenu\r#\r\rfunc (m *Menu) DeactivateLastSubmenu() bool DeactivateLastSubmenu finds the last open submenu traversing through the open submenus, deactivates its active item and hides it. This also deactivates any submenus of the deactivated submenu. It returns true if there was a submenu open and closed and false elsewhere.\nfunc (*Menu) Dismiss\r#\r\rfunc (m *Menu) Dismiss() Dismiss dismisses the menu by dismissing and hiding the active child and performing OnDismiss.\nfunc (*Menu) MinSize\r#\r\rfunc (m *Menu) MinSize() fyne.Size MinSize returns the minimal size of the menu.\nImplements: \rfyne.Widget\rfunc (*Menu) Refresh\r#\r\rfunc (m *Menu) Refresh() Refresh updates the menu to reflect changes in the data.\nImplements: \rfyne.Widget\rfunc (*Menu) Tapped\r#\r\rfunc (m *Menu) Tapped(*fyne.PointEvent) Tapped catches taps on separators and the menu background. It doesn\u0026rsquo;t perform any action.\nImplements: \rfyne.Tappable\rfunc (*Menu) TriggerLast\r#\r\rfunc (m *Menu) TriggerLast() TriggerLast finds the last active menu item traversing through the open submenus and triggers it.\n"},{"id":294,"href":"/fyne/docs/api/widget/orientation/","title":"widget.Orientation","section":"theme","content":"widget.Orientation\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Orientation\r#\r\rtype Orientation int Orientation controls the horizontal/vertical layout of a widget\nconst ( \tHorizontal Orientation = 0 \tVertical Orientation = 1 ) Orientation constants to control widget layout\n"},{"id":295,"href":"/fyne/docs/api/widget/paragraphsegment/","title":"widget.ParagraphSegment","section":"theme","content":"widget.ParagraphSegment\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ParagraphSegment\r#\r\rtype ParagraphSegment struct { \tTexts []RichTextSegment } ParagraphSegment wraps a number of text elements in a paragraph. It is similar to using a list of text elements when the final style is RichTextStyleParagraph.\nSince: \r2.1\rfunc (*ParagraphSegment) Inline\r#\r\rfunc (p *ParagraphSegment) Inline() bool Inline returns false as a paragraph should be in a block.\nfunc (*ParagraphSegment) Segments\r#\r\rfunc (p *ParagraphSegment) Segments() []RichTextSegment Segments returns the list of text elements in this paragraph.\nfunc (*ParagraphSegment) Select\r#\r\rfunc (p *ParagraphSegment) Select(_, _ fyne.Position) Select does nothing for a paragraph container.\nfunc (*ParagraphSegment) SelectedText\r#\r\rfunc (p *ParagraphSegment) SelectedText() string SelectedText returns the empty string for this paragraph container.\nfunc (*ParagraphSegment) Textual\r#\r\rfunc (p *ParagraphSegment) Textual() string Textual returns no content for a paragraph container.\nfunc (*ParagraphSegment) Unselect\r#\r\rfunc (p *ParagraphSegment) Unselect() Unselect does nothing for a paragraph container.\nfunc (*ParagraphSegment) Update\r#\r\rfunc (p *ParagraphSegment) Update(fyne.CanvasObject) Update doesnt need to change a paragraph container.\nfunc (*ParagraphSegment) Visual\r#\r\rfunc (p *ParagraphSegment) Visual() fyne.CanvasObject Visual returns the no extra elements.\n"},{"id":296,"href":"/fyne/docs/api/widget/popup/","title":"widget.PopUp","section":"theme","content":"widget.PopUp\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype PopUp\r#\r\rtype PopUp struct { \tBaseWidget  \tContent fyne.CanvasObject \tCanvas fyne.Canvas } PopUp is a widget that can float above the user interface. It wraps any standard elements with padding and a shadow. If it is modal then the shadow will cover the entire canvas it hovers over and block interactions.\nfunc NewModalPopUp\r#\r\rfunc NewModalPopUp(content fyne.CanvasObject, canvas fyne.Canvas) *PopUp NewModalPopUp creates a new popUp for the specified content and displays it on the passed canvas. A modal PopUp blocks interactions with underlying elements, covered with a semi-transparent overlay.\nfunc NewPopUp\r#\r\rfunc NewPopUp(content fyne.CanvasObject, canvas fyne.Canvas) *PopUp NewPopUp creates a new popUp for the specified content and displays it on the passed canvas.\nfunc (*PopUp) CreateRenderer\r#\r\rfunc (p *PopUp) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*PopUp) Hide\r#\r\rfunc (p *PopUp) Hide() Hide this widget, if it was previously visible\nfunc (*PopUp) MinSize\r#\r\rfunc (p *PopUp) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*PopUp) Move\r#\r\rfunc (p *PopUp) Move(pos fyne.Position) Move the widget to a new position. A PopUp position is absolute to the top, left of its canvas. For PopUp this actually moves the content so checking Position() will not return the same value as is set here.\nfunc (*PopUp) Resize\r#\r\rfunc (p *PopUp) Resize(size fyne.Size) Resize changes the size of the PopUp\u0026rsquo;s content. PopUps always have the size of their canvas, but this call updates the size of the content portion.\nImplements: \rfyne.Widget\rfunc (*PopUp) Show\r#\r\rfunc (p *PopUp) Show() Show this pop-up as overlay if not already shown.\nfunc (*PopUp) ShowAtPosition\r#\r\rfunc (p *PopUp) ShowAtPosition(pos fyne.Position) ShowAtPosition shows this pop-up at the given position.\nfunc (*PopUp) Tapped\r#\r\rfunc (p *PopUp) Tapped(_ *fyne.PointEvent) Tapped is called when the user taps the popUp background - if not modal then dismiss this widget\nfunc (*PopUp) TappedSecondary\r#\r\rfunc (p *PopUp) TappedSecondary(_ *fyne.PointEvent) TappedSecondary is called when the user right/alt taps the background - if not modal then dismiss this widget\n"},{"id":297,"href":"/fyne/docs/api/widget/popupmenu/","title":"widget.PopUpMenu","section":"theme","content":"widget.PopUpMenu\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype PopUpMenu\r#\r\rtype PopUpMenu struct { \t*Menu } PopUpMenu is a Menu which displays itself in an OverlayContainer.\nfunc NewPopUpMenu\r#\r\rfunc NewPopUpMenu(menu *fyne.Menu, c fyne.Canvas) *PopUpMenu NewPopUpMenu creates a new, reusable popup menu. You can show it using ShowAtPosition.\nSince: \r2.0\rfunc (*PopUpMenu) FocusGained\r#\r\rfunc (p *PopUpMenu) FocusGained() FocusGained is triggered when the object gained focus. For the pop-up menu it does nothing.\nImplements: \rfyne.Focusable\rfunc (*PopUpMenu) FocusLost\r#\r\rfunc (p *PopUpMenu) FocusLost() FocusLost is triggered when the object lost focus. For the pop-up menu it does nothing.\nImplements: \rfyne.Focusable\rfunc (*PopUpMenu) Hide\r#\r\rfunc (p *PopUpMenu) Hide() Hide hides the pop-up menu.\nImplements: \rfyne.Widget\rfunc (*PopUpMenu) Move\r#\r\rfunc (p *PopUpMenu) Move(pos fyne.Position) Move moves the pop-up menu. The position is absolute because pop-up menus are shown in an overlay which covers the whole canvas.\nImplements: \rfyne.Widget\rfunc (*PopUpMenu) Resize\r#\r\rfunc (p *PopUpMenu) Resize(size fyne.Size) Resize changes the size of the pop-up menu.\nImplements: \rfyne.Widget\rfunc (*PopUpMenu) Show\r#\r\rfunc (p *PopUpMenu) Show() Show makes the pop-up menu visible.\nImplements: \rfyne.Widget\rfunc (*PopUpMenu) ShowAtPosition\r#\r\rfunc (p *PopUpMenu) ShowAtPosition(pos fyne.Position) ShowAtPosition shows the pop-up menu at the specified position.\nfunc (*PopUpMenu) TypedKey\r#\r\rfunc (p *PopUpMenu) TypedKey(e *fyne.KeyEvent) TypedKey handles key events. It allows keyboard control of the pop-up menu.\nImplements: \rfyne.Focusable\rfunc (*PopUpMenu) TypedRune\r#\r\rfunc (p *PopUpMenu) TypedRune(rune) TypedRune handles text events. For pop-up menus this does nothing.\nImplements: \rfyne.Focusable\r"},{"id":298,"href":"/fyne/docs/api/widget/progressbar/","title":"widget.ProgressBar","section":"theme","content":"widget.ProgressBar\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ProgressBar\r#\r\rtype ProgressBar struct { \tBaseWidget  \tMin, Max, Value float64  \t// TextFormatter can be used to have a custom format of progress text. \t// If set, it overrides the percentage readout and runs each time the value updates. \t// \t// Since: 1.4 \tTextFormatter func() string } ProgressBar widget creates a horizontal panel that indicates progress\nfunc NewProgressBar\r#\r\rfunc NewProgressBar() *ProgressBar NewProgressBar creates a new progress bar widget. The default Min is 0 and Max is 1, Values set should be between those numbers. The display will convert this to a percentage.\nfunc NewProgressBarWithData\r#\r\rfunc NewProgressBarWithData(data binding.Float) *ProgressBar NewProgressBarWithData returns a progress bar connected with the specified data source.\nSince: \r2.0\rfunc (*ProgressBar) Bind\r#\r\rfunc (p *ProgressBar) Bind(data binding.Float) Bind connects the specified data source to this ProgressBar. The current value will be displayed and any changes in the data will cause the widget to update.\nSince: \r2.0\rfunc (*ProgressBar) CreateRenderer\r#\r\rfunc (p *ProgressBar) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*ProgressBar) MinSize\r#\r\rfunc (p *ProgressBar) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*ProgressBar) SetValue\r#\r\rfunc (p *ProgressBar) SetValue(v float64) SetValue changes the current value of this progress bar (from p.Min to p.Max). The widget will be refreshed to indicate the change.\nfunc (*ProgressBar) Unbind\r#\r\rfunc (p *ProgressBar) Unbind() Unbind disconnects any configured data source from this ProgressBar. The current value will remain at the last value of the data source.\nSince: \r2.0\r"},{"id":299,"href":"/fyne/docs/api/widget/progressbarinfinite/","title":"widget.ProgressBarInfinite","section":"theme","content":"widget.ProgressBarInfinite\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ProgressBarInfinite\r#\r\rtype ProgressBarInfinite struct { \tBaseWidget } ProgressBarInfinite widget creates a horizontal panel that indicates waiting indefinitely An infinite progress bar loops 0% -\u0026gt; 100% repeatedly until Stop() is called\nfunc NewProgressBarInfinite\r#\r\rfunc NewProgressBarInfinite() *ProgressBarInfinite NewProgressBarInfinite creates a new progress bar widget that loops indefinitely from 0% -\u0026gt; 100% SetValue() is not defined for infinite progress bar To stop the looping progress and set the progress bar to 100%, call ProgressBarInfinite.Stop()\nfunc (*ProgressBarInfinite) CreateRenderer\r#\r\rfunc (p *ProgressBarInfinite) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*ProgressBarInfinite) Hide\r#\r\rfunc (p *ProgressBarInfinite) Hide() Hide this widget, if it was previously visible\nfunc (*ProgressBarInfinite) MinSize\r#\r\rfunc (p *ProgressBarInfinite) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*ProgressBarInfinite) Running\r#\r\rfunc (p *ProgressBarInfinite) Running() bool Running returns the current state of the infinite progress animation\nfunc (*ProgressBarInfinite) Show\r#\r\rfunc (p *ProgressBarInfinite) Show() Show this widget, if it was previously hidden\nfunc (*ProgressBarInfinite) Start\r#\r\rfunc (p *ProgressBarInfinite) Start() Start the infinite progress bar animation\nfunc (*ProgressBarInfinite) Stop\r#\r\rfunc (p *ProgressBarInfinite) Stop() Stop the infinite progress bar animation\n"},{"id":300,"href":"/fyne/docs/api/widget/radiogroup/","title":"widget.RadioGroup","section":"theme","content":"widget.RadioGroup\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype RadioGroup\r#\r\rtype RadioGroup struct { \tDisableableWidget \tHorizontal bool \tRequired bool \tOnChanged func(string) `json:\u0026#34;-\u0026#34;` \tOptions []string \tSelected string } RadioGroup widget has a list of text labels and checks check icons next to each. Changing the selection (only one can be selected) will trigger the changed func.\nSince: \r1.4\rfunc NewRadioGroup\r#\r\rfunc NewRadioGroup(options []string, changed func(string)) *RadioGroup NewRadioGroup creates a new radio group widget with the set options and change handler\nSince: \r1.4\rfunc (*RadioGroup) Append\r#\r\rfunc (r *RadioGroup) Append(option string) Append adds a new option to the end of a RadioGroup widget.\nfunc (*RadioGroup) CreateRenderer\r#\r\rfunc (r *RadioGroup) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*RadioGroup) MinSize\r#\r\rfunc (r *RadioGroup) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*RadioGroup) Refresh\r#\r\rfunc (r *RadioGroup) Refresh() Refresh causes this widget to be redrawn in it\u0026rsquo;s current state.\nImplements: \rfyne.CanvasObject\rfunc (*RadioGroup) SetSelected\r#\r\rfunc (r *RadioGroup) SetSelected(option string) SetSelected sets the radio option, it can be used to set a default option.\n"},{"id":301,"href":"/fyne/docs/api/widget/richtext/","title":"widget.RichText","section":"theme","content":"widget.RichText\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype RichText\r#\r\rtype RichText struct { \tBaseWidget \tSegments []RichTextSegment \tWrapping fyne.TextWrap \tScroll widget.ScrollDirection } RichText represents the base element for a rich text-based widget.\nSince: \r2.1\rfunc NewRichText\r#\r\rfunc NewRichText(segments ...RichTextSegment) *RichText NewRichText returns a new RichText widget that renders the given text and segments. If no segments are specified it will be converted to a single segment using the default text settings.\nSince: \r2.1\rfunc NewRichTextFromMarkdown\r#\r\rfunc NewRichTextFromMarkdown(content string) *RichText NewRichTextFromMarkdown configures a RichText widget by parsing the provided markdown content.\nSince: \r2.1\rfunc NewRichTextWithText\r#\r\rfunc NewRichTextWithText(text string) *RichText NewRichTextWithText returns a new RichText widget that renders the given text. The string will be converted to a single text segment using the default text settings.\nSince: \r2.1\rfunc (*RichText) CreateRenderer\r#\r\rfunc (t *RichText) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*RichText) MinSize\r#\r\rfunc (t *RichText) MinSize() fyne.Size MinSize calculates the minimum size of a rich text widget. This is based on the contained text with a standard amount of padding added.\nfunc (*RichText) ParseMarkdown\r#\r\rfunc (t *RichText) ParseMarkdown(content string) ParseMarkdown allows setting the content of this RichText widget from a markdown string. It will replace the content of this widget similarly to SetText, but with the appropriate formatting.\nfunc (*RichText) Refresh\r#\r\rfunc (t *RichText) Refresh() Refresh triggers a redraw of the rich text.\nImplements: \rfyne.Widget\rfunc (*RichText) Resize\r#\r\rfunc (t *RichText) Resize(size fyne.Size) Resize sets a new size for the rich text. This should only be called if it is not in a container with a layout manager.\nImplements: \rfyne.Widget\rfunc (*RichText) String\r#\r\rfunc (t *RichText) String() string String returns the text widget buffer as string\n"},{"id":302,"href":"/fyne/docs/api/widget/richtextblock/","title":"widget.RichTextBlock","section":"theme","content":"widget.RichTextBlock\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype RichTextBlock\r#\r\rtype RichTextBlock interface { \tSegments() []RichTextSegment } RichTextBlock is an extension of a text segment that contains other segments\nSince: \r2.1\r"},{"id":303,"href":"/fyne/docs/api/widget/richtextsegment/","title":"widget.RichTextSegment","section":"theme","content":"widget.RichTextSegment\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype RichTextSegment\r#\r\rtype RichTextSegment interface { \tInline() bool \tTextual() string \tUpdate(fyne.CanvasObject) \tVisual() fyne.CanvasObject  \tSelect(pos1, pos2 fyne.Position) \tSelectedText() string \tUnselect() } RichTextSegment describes any element that can be rendered in a RichText widget.\nSince: \r2.1\r"},{"id":304,"href":"/fyne/docs/api/widget/richtextstyle/","title":"widget.RichTextStyle","section":"theme","content":"widget.RichTextStyle\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype RichTextStyle\r#\r\rtype RichTextStyle struct { \tAlignment fyne.TextAlign \tColorName fyne.ThemeColorName \tInline bool \tSizeName fyne.ThemeSizeName \tTextStyle fyne.TextStyle } RichTextStyle describes the details of a text object inside a RichText widget.\nSince: \r2.1\r"},{"id":305,"href":"/fyne/docs/api/widget/select/","title":"widget.Select","section":"theme","content":"widget.Select\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Select\r#\r\rtype Select struct { \tDisableableWidget  \t// Alignment sets the text alignment of the select and its list of options. \t// \t// Since: 2.1 \tAlignment fyne.TextAlign \tSelected string \tOptions []string \tPlaceHolder string \tOnChanged func(string) `json:\u0026#34;-\u0026#34;` } Select widget has a list of options, with the current one shown, and triggers an event func when clicked\nfunc NewSelect\r#\r\rfunc NewSelect(options []string, changed func(string)) *Select NewSelect creates a new select widget with the set list of options and changes handler\nfunc (*Select) ClearSelected\r#\r\rfunc (s *Select) ClearSelected() ClearSelected clears the current option of the select widget. After clearing the current option, the Select widget\u0026rsquo;s PlaceHolder will be displayed.\nfunc (*Select) CreateRenderer\r#\r\rfunc (s *Select) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Select) FocusGained\r#\r\rfunc (s *Select) FocusGained() FocusGained is called after this Select has gained focus.\nImplements: \rfyne.Focusable\rfunc (*Select) FocusLost\r#\r\rfunc (s *Select) FocusLost() FocusLost is called after this Select has lost focus.\nImplements: \rfyne.Focusable\rfunc (*Select) Hide\r#\r\rfunc (s *Select) Hide() Hide hides the select.\nImplements: \rfyne.Widget\rfunc (*Select) MinSize\r#\r\rfunc (s *Select) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*Select) MouseIn\r#\r\rfunc (s *Select) MouseIn(*desktop.MouseEvent) MouseIn is called when a desktop pointer enters the widget\nfunc (*Select) MouseMoved\r#\r\rfunc (s *Select) MouseMoved(*desktop.MouseEvent) MouseMoved is called when a desktop pointer hovers over the widget\nfunc (*Select) MouseOut\r#\r\rfunc (s *Select) MouseOut() MouseOut is called when a desktop pointer exits the widget\nfunc (*Select) Move\r#\r\rfunc (s *Select) Move(pos fyne.Position) Move changes the relative position of the select.\nImplements: \rfyne.Widget\rfunc (*Select) Resize\r#\r\rfunc (s *Select) Resize(size fyne.Size) Resize sets a new size for a widget. Note this should not be used if the widget is being managed by a Layout within a Container.\nfunc (*Select) SelectedIndex\r#\r\rfunc (s *Select) SelectedIndex() int SelectedIndex returns the index value of the currently selected item in Options list. It will return -1 if there is no selection.\nfunc (*Select) SetSelected\r#\r\rfunc (s *Select) SetSelected(text string) SetSelected sets the current option of the select widget\nfunc (*Select) SetSelectedIndex\r#\r\rfunc (s *Select) SetSelectedIndex(index int) SetSelectedIndex will set the Selected option from the value in Options list at index position.\nfunc (*Select) Tapped\r#\r\rfunc (s *Select) Tapped(*fyne.PointEvent) Tapped is called when a pointer tapped event is captured and triggers any tap handler\nfunc (*Select) TypedKey\r#\r\rfunc (s *Select) TypedKey(event *fyne.KeyEvent) TypedKey is called if a key event happens while this Select is focused.\nImplements: \rfyne.Focusable\rfunc (*Select) TypedRune\r#\r\rfunc (s *Select) TypedRune(_ rune) TypedRune is called if a text event happens while this Select is focused.\nImplements: \rfyne.Focusable\r"},{"id":306,"href":"/fyne/docs/api/widget/selectentry/","title":"widget.SelectEntry","section":"theme","content":"widget.SelectEntry\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype SelectEntry\r#\r\rtype SelectEntry struct { \tEntry } SelectEntry is an input field which supports selecting from a fixed set of options.\nfunc NewSelectEntry\r#\r\rfunc NewSelectEntry(options []string) *SelectEntry NewSelectEntry creates a SelectEntry.\nfunc (*SelectEntry) CreateRenderer\r#\r\rfunc (e *SelectEntry) CreateRenderer() fyne.WidgetRenderer CreateRenderer returns a new renderer for this select entry.\nImplements: \rfyne.Widget\rfunc (*SelectEntry) Disable\r#\r\rfunc (e *SelectEntry) Disable() Disable this widget so that it cannot be interacted with, updating any style appropriately.\nImplements: \rfyne.DisableableWidget\rfunc (*SelectEntry) Enable\r#\r\rfunc (e *SelectEntry) Enable() Enable this widget, updating any style or features appropriately.\nImplements: \rfyne.DisableableWidget\rfunc (*SelectEntry) MinSize\r#\r\rfunc (e *SelectEntry) MinSize() fyne.Size MinSize returns the minimal size of the select entry.\nImplements: \rfyne.Widget\rfunc (*SelectEntry) Move\r#\r\rfunc (e *SelectEntry) Move(pos fyne.Position) Move changes the relative position of the select entry.\nImplements: \rfyne.Widget\rfunc (*SelectEntry) Resize\r#\r\rfunc (e *SelectEntry) Resize(size fyne.Size) Resize changes the size of the select entry.\nImplements: \rfyne.Widget\rfunc (*SelectEntry) SetOptions\r#\r\rfunc (e *SelectEntry) SetOptions(options []string) SetOptions sets the options the user might select from.\n"},{"id":307,"href":"/fyne/docs/api/widget/separator/","title":"widget.Separator","section":"theme","content":"widget.Separator\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Separator\r#\r\rtype Separator struct { \tBaseWidget } Separator is a widget for displaying a separator with themeable color.\nSince: \r1.4\rfunc NewSeparator\r#\r\rfunc NewSeparator() *Separator NewSeparator creates a new separator.\nSince: \r1.4\rfunc (*Separator) CreateRenderer\r#\r\rfunc (s *Separator) CreateRenderer() fyne.WidgetRenderer CreateRenderer returns a new renderer for the separator.\nImplements: \rfyne.Widget\rfunc (*Separator) MinSize\r#\r\rfunc (s *Separator) MinSize() fyne.Size MinSize returns the minimal size of the separator.\nImplements: \rfyne.Widget\r"},{"id":308,"href":"/fyne/docs/api/widget/separatorsegment/","title":"widget.SeparatorSegment","section":"theme","content":"widget.SeparatorSegment\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype SeparatorSegment\r#\r\rtype SeparatorSegment struct { } SeparatorSegment includes a horizontal separator in a rich text widget.\nSince: \r2.1\rfunc (*SeparatorSegment) Inline\r#\r\rfunc (s *SeparatorSegment) Inline() bool Inline returns false as a separator should be full width.\nfunc (*SeparatorSegment) Select\r#\r\rfunc (s *SeparatorSegment) Select(_, _ fyne.Position) Select does nothing for a separator.\nfunc (*SeparatorSegment) SelectedText\r#\r\rfunc (s *SeparatorSegment) SelectedText() string SelectedText returns the empty string for this separator.\nfunc (*SeparatorSegment) Textual\r#\r\rfunc (s *SeparatorSegment) Textual() string Textual returns no content for a separator element.\nfunc (*SeparatorSegment) Unselect\r#\r\rfunc (s *SeparatorSegment) Unselect() Unselect does nothing for a separator.\nfunc (*SeparatorSegment) Update\r#\r\rfunc (s *SeparatorSegment) Update(fyne.CanvasObject) Update doesnt need to change a separator visual.\nfunc (*SeparatorSegment) Visual\r#\r\rfunc (s *SeparatorSegment) Visual() fyne.CanvasObject Visual returns the separator element for this segment.\n"},{"id":309,"href":"/fyne/docs/api/widget/slider/","title":"widget.Slider","section":"theme","content":"widget.Slider\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Slider\r#\r\rtype Slider struct { \tBaseWidget  \tValue float64 \tMin float64 \tMax float64 \tStep float64  \tOrientation Orientation \tOnChanged func(float64) } Slider is a widget that can slide between two fixed values.\nfunc NewSlider\r#\r\rfunc NewSlider(min, max float64) *Slider NewSlider returns a basic slider.\nfunc NewSliderWithData\r#\r\rfunc NewSliderWithData(min, max float64, data binding.Float) *Slider NewSliderWithData returns a slider connected with the specified data source.\nSince: \r2.0\rfunc (*Slider) Bind\r#\r\rfunc (s *Slider) Bind(data binding.Float) Bind connects the specified data source to this Slider. The current value will be displayed and any changes in the data will cause the widget to update. User interactions with this Slider will set the value into the data source.\nSince: \r2.0\rfunc (*Slider) CreateRenderer\r#\r\rfunc (s *Slider) CreateRenderer() fyne.WidgetRenderer CreateRenderer links this widget to its renderer.\nfunc (*Slider) DragEnd\r#\r\rfunc (s *Slider) DragEnd() DragEnd function.\nfunc (*Slider) Dragged\r#\r\rfunc (s *Slider) Dragged(e *fyne.DragEvent) Dragged function.\nfunc (*Slider) MinSize\r#\r\rfunc (s *Slider) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*Slider) SetValue\r#\r\rfunc (s *Slider) SetValue(value float64) SetValue updates the value of the slider and clamps the value to be within the range.\nfunc (*Slider) Unbind\r#\r\rfunc (s *Slider) Unbind() Unbind disconnects any configured data source from this Slider. The current value will remain at the last value of the data source.\nSince: \r2.0\r"},{"id":310,"href":"/fyne/docs/api/widget/table/","title":"widget.Table","section":"theme","content":"widget.Table\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Table\r#\r\rtype Table struct { \tBaseWidget  \tLength func() (int, int) \tCreateCell func() fyne.CanvasObject \tUpdateCell func(id TableCellID, template fyne.CanvasObject) \tOnSelected func(id TableCellID) \tOnUnselected func(id TableCellID) } Table widget is a grid of items that can be scrolled and a cell selected. It\u0026rsquo;s performance is provided by caching cell templates created with CreateCell and re-using them with UpdateCell. The size of the content rows/columns is returned by the Length callback.\nSince: \r1.4\rfunc NewTable\r#\r\rfunc NewTable(length func() (int, int), create func() fyne.CanvasObject, update func(TableCellID, fyne.CanvasObject)) *Table NewTable returns a new performant table widget defined by the passed functions. The first returns the data size in rows and columns, second parameter is a function that returns cell template objects that can be cached and the third is used to apply data at specified data location to the passed template CanvasObject.\nSince: \r1.4\rfunc (*Table) CreateRenderer\r#\r\rfunc (t *Table) CreateRenderer() fyne.WidgetRenderer CreateRenderer returns a new renderer for the table.\nImplements: \rfyne.Widget\rfunc (*Table) ScrollTo\r#\r\rfunc (t *Table) ScrollTo(id TableCellID) ScrollTo will scroll to the given cell without changing the selection. Attempting to scroll beyond the limits of the table will scroll to the edge of the table instead.\nSince: \r2.1\rfunc (*Table) ScrollToBottom\r#\r\rfunc (t *Table) ScrollToBottom() ScrollToBottom scrolls to the last row in the table\nSince: \r2.1\rfunc (*Table) ScrollToLeading\r#\r\rfunc (t *Table) ScrollToLeading() ScrollToLeading scrolls horizontally to the leading edge of the table\nSince: \r2.1\rfunc (*Table) ScrollToTop\r#\r\rfunc (t *Table) ScrollToTop() ScrollToTop scrolls to the first row in the table\nSince: \r2.1\rfunc (*Table) ScrollToTrailing\r#\r\rfunc (t *Table) ScrollToTrailing() ScrollToTrailing scrolls horizontally to the trailing edge of the table\nSince: \r2.1\rfunc (*Table) Select\r#\r\rfunc (t *Table) Select(id TableCellID) Select will mark the specified cell as selected.\nfunc (*Table) SetColumnWidth\r#\r\rfunc (t *Table) SetColumnWidth(id int, width float32) SetColumnWidth supports changing the width of the specified column. Columns normally take the width of the template cell returned from the CreateCell callback. The width parameter uses the same units as a fyne.Size type and refers to the internal content width not including the divider size.\nSince: \r1.4.1\rfunc (*Table) Unselect\r#\r\rfunc (t *Table) Unselect(id TableCellID) Unselect will mark the cell provided by id as unselected.\nfunc (*Table) UnselectAll\r#\r\rfunc (t *Table) UnselectAll() UnselectAll will mark all cells as unselected.\nSince: \r2.1\r"},{"id":311,"href":"/fyne/docs/api/widget/tablecellid/","title":"widget.TableCellID","section":"theme","content":"widget.TableCellID\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype TableCellID\r#\r\rtype TableCellID struct { \tRow int \tCol int } TableCellID is a type that represents a cell\u0026rsquo;s position in a table based on it\u0026rsquo;s row and column location.\n"},{"id":312,"href":"/fyne/docs/api/widget/textgrid/","title":"widget.TextGrid","section":"theme","content":"widget.TextGrid\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype TextGrid\r#\r\rtype TextGrid struct { \tBaseWidget \tRows []TextGridRow  \tShowLineNumbers bool \tShowWhitespace bool \tTabWidth int // If set to 0 the fyne.DefaultTabWidth is used } TextGrid is a monospaced grid of characters. This is designed to be used by a text editor, code preview or terminal emulator.\nfunc NewTextGrid\r#\r\rfunc NewTextGrid() *TextGrid NewTextGrid creates a new empty TextGrid widget.\nfunc NewTextGridFromString\r#\r\rfunc NewTextGridFromString(content string) *TextGrid NewTextGridFromString creates a new TextGrid widget with the specified string content.\nfunc (*TextGrid) CreateRenderer\r#\r\rfunc (t *TextGrid) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to it\u0026rsquo;s renderer\nfunc (*TextGrid) MinSize\r#\r\rfunc (t *TextGrid) MinSize() fyne.Size MinSize returns the smallest size this widget can shrink to\nfunc (*TextGrid) Resize\r#\r\rfunc (t *TextGrid) Resize(size fyne.Size) Resize is called when this widget changes size. We should make sure that we refresh cells.\nfunc (*TextGrid) Row\r#\r\rfunc (t *TextGrid) Row(row int) TextGridRow Row returns a copy of the content in a specified row as a TextGridRow. If the index is out of bounds it returns an empty row object.\nfunc (*TextGrid) RowText\r#\r\rfunc (t *TextGrid) RowText(row int) string RowText returns a string representation of the content at the row specified. If the index is out of bounds it returns an empty string.\nfunc (*TextGrid) SetCell\r#\r\rfunc (t *TextGrid) SetCell(row, col int, cell TextGridCell) SetCell sets a grid data to the cell at named row and column.\nfunc (*TextGrid) SetRow\r#\r\rfunc (t *TextGrid) SetRow(row int, content TextGridRow) SetRow updates the specified row of the grid\u0026rsquo;s contents using the specified content and style and then refreshes. If the row is beyond the end of the current buffer it will be expanded. Tab characters are not padded with spaces.\nfunc (*TextGrid) SetRowStyle\r#\r\rfunc (t *TextGrid) SetRowStyle(row int, style TextGridStyle) SetRowStyle sets a grid style to all the cells cell at the specified row. Any cells in this row with their own style will override this value when displayed.\nfunc (*TextGrid) SetRune\r#\r\rfunc (t *TextGrid) SetRune(row, col int, r rune) SetRune sets a character to the cell at named row and column.\nfunc (*TextGrid) SetStyle\r#\r\rfunc (t *TextGrid) SetStyle(row, col int, style TextGridStyle) SetStyle sets a grid style to the cell at named row and column.\nfunc (*TextGrid) SetStyleRange\r#\r\rfunc (t *TextGrid) SetStyleRange(startRow, startCol, endRow, endCol int, style TextGridStyle) SetStyleRange sets a grid style to all the cells between the start row and column through to the end row and column.\nfunc (*TextGrid) SetText\r#\r\rfunc (t *TextGrid) SetText(text string) SetText updates the buffer of this textgrid to contain the specified text. New lines and columns will be added as required. Lines are separated by \u0026lsquo;\\n\u0026rsquo;. The grid will use default text style and any previous content and style will be removed. Tab characters are padded with spaces to the next tab stop.\nfunc (*TextGrid) Text\r#\r\rfunc (t *TextGrid) Text() string Text returns the contents of the buffer as a single string (with no style information). It reconstructs the lines by joining with a \\n character. Tab characters have padded spaces removed.\n"},{"id":313,"href":"/fyne/docs/api/widget/textgridcell/","title":"widget.TextGridCell","section":"theme","content":"widget.TextGridCell\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype TextGridCell\r#\r\rtype TextGridCell struct { \tRune rune \tStyle TextGridStyle } TextGridCell represents a single cell in a text grid. It has a rune for the text content and a style associated with it.\n"},{"id":314,"href":"/fyne/docs/api/widget/textgridrow/","title":"widget.TextGridRow","section":"theme","content":"widget.TextGridRow\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype TextGridRow\r#\r\rtype TextGridRow struct { \tCells []TextGridCell \tStyle TextGridStyle } TextGridRow represents a row of cells cell in a text grid. It contains the cells for the row and an optional style.\n"},{"id":315,"href":"/fyne/docs/api/widget/textgridstyle/","title":"widget.TextGridStyle","section":"theme","content":"widget.TextGridStyle\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype TextGridStyle\r#\r\rtype TextGridStyle interface { \tTextColor() color.Color \tBackgroundColor() color.Color } TextGridStyle defines a style that can be applied to a TextGrid cell.\nvar ( \t// TextGridStyleDefault is a default style for test grid cells \tTextGridStyleDefault TextGridStyle \t// TextGridStyleWhitespace is the style used for whitespace characters, if enabled \tTextGridStyleWhitespace TextGridStyle ) "},{"id":316,"href":"/fyne/docs/api/widget/textsegment/","title":"widget.TextSegment","section":"theme","content":"widget.TextSegment\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype TextSegment\r#\r\rtype TextSegment struct { \tStyle RichTextStyle \tText string } TextSegment represents the styling for a segment of rich text.\nSince: \r2.1\rfunc (*TextSegment) Inline\r#\r\rfunc (t *TextSegment) Inline() bool Inline should return true if this text can be included within other elements, or false if it creates a new block.\nfunc (*TextSegment) Select\r#\r\rfunc (t *TextSegment) Select(begin, end fyne.Position) Select tells the segment that the user is selecting the content between the two positions.\nfunc (*TextSegment) SelectedText\r#\r\rfunc (t *TextSegment) SelectedText() string SelectedText should return the text representation of any content currently selected through the Select call.\nfunc (*TextSegment) Textual\r#\r\rfunc (t *TextSegment) Textual() string Textual returns the content of this segment rendered to plain text.\nfunc (*TextSegment) Unselect\r#\r\rfunc (t *TextSegment) Unselect() Unselect tells the segment that the user is has cancelled the previous selection.\nfunc (*TextSegment) Update\r#\r\rfunc (t *TextSegment) Update(o fyne.CanvasObject) Update applies the current state of this text segment to an existing visual.\nfunc (*TextSegment) Visual\r#\r\rfunc (t *TextSegment) Visual() fyne.CanvasObject Visual returns the graphical elements required to render this segment.\n"},{"id":317,"href":"/fyne/docs/api/widget/toolbar/","title":"widget.Toolbar","section":"theme","content":"widget.Toolbar\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Toolbar\r#\r\rtype Toolbar struct { \tBaseWidget \tItems []ToolbarItem } Toolbar widget creates a horizontal list of tool buttons\nfunc NewToolbar\r#\r\rfunc NewToolbar(items ...ToolbarItem) *Toolbar NewToolbar creates a new toolbar widget.\nfunc (*Toolbar) Append\r#\r\rfunc (t *Toolbar) Append(item ToolbarItem) Append a new ToolbarItem to the end of this Toolbar\nfunc (*Toolbar) CreateRenderer\r#\r\rfunc (t *Toolbar) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer\nfunc (*Toolbar) MinSize\r#\r\rfunc (t *Toolbar) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below\nfunc (*Toolbar) Prepend\r#\r\rfunc (t *Toolbar) Prepend(item ToolbarItem) Prepend a new ToolbarItem to the start of this Toolbar\n"},{"id":318,"href":"/fyne/docs/api/widget/toolbaraction/","title":"widget.ToolbarAction","section":"theme","content":"widget.ToolbarAction\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ToolbarAction\r#\r\rtype ToolbarAction struct { \tIcon fyne.Resource \tOnActivated func() `json:\u0026#34;-\u0026#34;` } ToolbarAction is push button style of ToolbarItem\nfunc (*ToolbarAction) ToolbarObject\r#\r\rfunc (t *ToolbarAction) ToolbarObject() fyne.CanvasObject ToolbarObject gets a button to render this ToolbarAction\n"},{"id":319,"href":"/fyne/docs/api/widget/toolbaritem/","title":"widget.ToolbarItem","section":"theme","content":"widget.ToolbarItem\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ToolbarItem\r#\r\rtype ToolbarItem interface { \tToolbarObject() fyne.CanvasObject } ToolbarItem represents any interface element that can be added to a toolbar\nfunc NewToolbarAction\r#\r\rfunc NewToolbarAction(icon fyne.Resource, onActivated func()) ToolbarItem NewToolbarAction returns a new push button style ToolbarItem\nfunc NewToolbarSeparator\r#\r\rfunc NewToolbarSeparator() ToolbarItem NewToolbarSeparator returns a new separator item for a Toolbar to assist with ToolbarItem grouping\nfunc NewToolbarSpacer\r#\r\rfunc NewToolbarSpacer() ToolbarItem NewToolbarSpacer returns a new spacer item for a Toolbar to assist with ToolbarItem alignment\n"},{"id":320,"href":"/fyne/docs/api/widget/toolbarseparator/","title":"widget.ToolbarSeparator","section":"theme","content":"widget.ToolbarSeparator\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ToolbarSeparator\r#\r\rtype ToolbarSeparator struct { } ToolbarSeparator is a thin, visible divide that can be added to a Toolbar. This is typically used to assist visual grouping of ToolbarItems.\nfunc (*ToolbarSeparator) ToolbarObject\r#\r\rfunc (t *ToolbarSeparator) ToolbarObject() fyne.CanvasObject ToolbarObject gets the visible line object for this ToolbarSeparator\n"},{"id":321,"href":"/fyne/docs/api/widget/toolbarspacer/","title":"widget.ToolbarSpacer","section":"theme","content":"widget.ToolbarSpacer\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype ToolbarSpacer\r#\r\rtype ToolbarSpacer struct { } ToolbarSpacer is a blank, stretchable space for a toolbar. This is typically used to assist layout if you wish some left and some right aligned items. Space will be split evebly amongst all the spacers on a toolbar.\nfunc (*ToolbarSpacer) ToolbarObject\r#\r\rfunc (t *ToolbarSpacer) ToolbarObject() fyne.CanvasObject ToolbarObject gets the actual spacer object for this ToolbarSpacer\n"},{"id":322,"href":"/fyne/docs/api/widget/tree/","title":"widget.Tree","section":"theme","content":"widget.Tree\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype Tree\r#\r\rtype Tree struct { \tBaseWidget \tRoot TreeNodeID  \tChildUIDs func(uid TreeNodeID) (c []TreeNodeID) // Return a sorted slice of Children TreeNodeIDs for the given Node TreeNodeID \tCreateNode func(branch bool) (o fyne.CanvasObject) // Return a CanvasObject that can represent a Branch (if branch is true), or a Leaf (if branch is false) \tIsBranch func(uid TreeNodeID) (ok bool) // Return true if the given TreeNodeID represents a Branch \tOnBranchClosed func(uid TreeNodeID) // Called when a Branch is closed \tOnBranchOpened func(uid TreeNodeID) // Called when a Branch is opened \tOnSelected func(uid TreeNodeID) // Called when the Node with the given TreeNodeID is selected. \tOnUnselected func(uid TreeNodeID) // Called when the Node with the given TreeNodeID is unselected. \tUpdateNode func(uid TreeNodeID, branch bool, node fyne.CanvasObject) // Called to update the given CanvasObject to represent the data at the given TreeNodeID } Tree widget displays hierarchical data. Each node of the tree must be identified by a Unique TreeNodeID.\nSince: \r1.4\rfunc NewTree\r#\r\rfunc NewTree(childUIDs func(TreeNodeID) []TreeNodeID, isBranch func(TreeNodeID) bool, create func(bool) fyne.CanvasObject, update func(TreeNodeID, bool, fyne.CanvasObject)) *Tree NewTree returns a new performant tree widget defined by the passed functions. childUIDs returns the child TreeNodeIDs of the given node. isBranch returns true if the given node is a branch, false if it is a leaf. create returns a new template object that can be cached. update is used to apply data at specified data location to the passed template CanvasObject.\nSince: \r1.4\rfunc NewTreeWithStrings\r#\r\rfunc NewTreeWithStrings(data map[string][]string) (t *Tree) NewTreeWithStrings creates a new tree with the given string map. Data must contain a mapping for the root, which defaults to empty string (\u0026quot;\u0026quot;).\nSince: \r1.4\rfunc (*Tree) CloseAllBranches\r#\r\rfunc (t *Tree) CloseAllBranches() CloseAllBranches closes all branches in the tree.\nfunc (*Tree) CloseBranch\r#\r\rfunc (t *Tree) CloseBranch(uid TreeNodeID) CloseBranch closes the branch with the given TreeNodeID.\nfunc (*Tree) CreateRenderer\r#\r\rfunc (t *Tree) CreateRenderer() fyne.WidgetRenderer CreateRenderer is a private method to Fyne which links this widget to its renderer.\nfunc (*Tree) IsBranchOpen\r#\r\rfunc (t *Tree) IsBranchOpen(uid TreeNodeID) bool IsBranchOpen returns true if the branch with the given TreeNodeID is expanded.\nfunc (*Tree) MinSize\r#\r\rfunc (t *Tree) MinSize() fyne.Size MinSize returns the size that this widget should not shrink below.\nfunc (*Tree) OpenAllBranches\r#\r\rfunc (t *Tree) OpenAllBranches() OpenAllBranches opens all branches in the tree.\nfunc (*Tree) OpenBranch\r#\r\rfunc (t *Tree) OpenBranch(uid TreeNodeID) OpenBranch opens the branch with the given TreeNodeID.\nfunc (*Tree) Resize\r#\r\rfunc (t *Tree) Resize(size fyne.Size) Resize sets a new size for a widget.\nfunc (*Tree) ScrollTo\r#\r\rfunc (t *Tree) ScrollTo(uid TreeNodeID) ScrollTo scrolls to the node with the given id.\nSince 2.1\nfunc (*Tree) ScrollToBottom\r#\r\rfunc (t *Tree) ScrollToBottom() ScrollToBottom scrolls to the bottom of the tree.\nSince 2.1\nfunc (*Tree) ScrollToTop\r#\r\rfunc (t *Tree) ScrollToTop() ScrollToTop scrolls to the top of the tree.\nSince 2.1\nfunc (*Tree) Select\r#\r\rfunc (t *Tree) Select(uid TreeNodeID) Select marks the specified node to be selected.\nfunc (*Tree) ToggleBranch\r#\r\rfunc (t *Tree) ToggleBranch(uid string) ToggleBranch flips the state of the branch with the given TreeNodeID.\nfunc (*Tree) Unselect\r#\r\rfunc (t *Tree) Unselect(uid TreeNodeID) Unselect marks the specified node to be not selected.\nfunc (*Tree) UnselectAll\r#\r\rfunc (t *Tree) UnselectAll() UnselectAll sets all nodes to be not selected.\nSince: \r2.1\r"},{"id":323,"href":"/fyne/docs/api/widget/treenodeid/","title":"widget.TreeNodeID","section":"theme","content":"widget.TreeNodeID\r#\r\r import \u0026#34;fyne.io/fyne/v2/widget\u0026#34; Usage\r#\r\rtype TreeNodeID\r#\r\rtype TreeNodeID = string TreeNodeID represents the unique id of a tree node.\n"}]