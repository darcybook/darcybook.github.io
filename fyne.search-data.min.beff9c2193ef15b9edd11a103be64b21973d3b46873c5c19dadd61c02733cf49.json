[{"id":0,"href":"/fyne/docs/explore/canvas/","title":"Canvas and CanvasObject","section":"Exploring Fyne","content":"In Fyne a Canvas is the area which an application is drawn within. Each window has a canvas which you can access with Window.Canvas() but usually you will find functions on Window that avoid accessing the canvas.\nEverything that can be drawn in Fyne is a type of CanvasObject. The example here opens a new window and then shows different types of primitive graphical element by setting the content of the window canvas. There are many ways that each type of object can be customised as shown with the text and circle examples.\nAs well as changing the content shown using Canvas.SetContent() it is possible to change the content that is currently visible. If, for example, you change the FillColour of a rectangle you can request a refresh of this existing component using rect.Refresh().\npackage main  import ( \t\u0026#34;image/color\u0026#34; \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Canvas\u0026#34;) \tmyCanvas := myWindow.Canvas()  \tblue := color.NRGBA{R: 0, G: 0, B: 180, A: 255} \trect := canvas.NewRectangle(blue) \tmyCanvas.SetContent(rect)  \tgo func() { \ttime.Sleep(time.Second) \tgreen := color.NRGBA{R: 0, G: 180, B: 0, A: 255} \trect.FillColor = green \trect.Refresh() \t}()  \tmyWindow.Resize(fyne.NewSize(100, 100)) \tmyWindow.ShowAndRun() } We can draw many different drawing elements in the same way, such as circle and text.\nfunc setContentToText(c fyne.Canvas) { \tgreen := color.NRGBA{R: 0, G: 180, B: 0, A: 255} \ttext := canvas.NewText(\u0026#34;Text\u0026#34;, green) \ttext.TextStyle.Bold = true \tc.SetContent(text) }  func setContentToCircle(c fyne.Canvas) { \tred := color.NRGBA{R: 0xff, G: 0x33, B: 0x33, A: 0xff} \tcircle := canvas.NewCircle(color.White) \tcircle.StrokeWidth = 4 \tcircle.StrokeColor = red \tc.SetContent(circle) } Widget\r#\r\rA fyne.Widget is a special type of canvas object that has interactive elements associated with it. In widgets the logic is separate from the way that it looks (also called the WidgetRenderer).\nWidgets are also types of CanvasObject and so we can set the content of our window to a single widget. See how we create a new widget.Entry and set it as the content of the window in this example.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Widget\u0026#34;)  \tmyWindow.SetContent(widget.NewEntry()) \tmyWindow.ShowAndRun() } "},{"id":1,"href":"/fyne/docs/started/introduction/","title":"Introduction","section":"Getting Started","content":"Getting Started\r#\r\rUsing the Fyne toolkit to build cross platform applications is very simple but does require some tools to be installed before you can begin. If your computer is set up for development with Go then the following steps may not be required, but we advise reading the tips for your operating system just in case. If later steps in this tutorial fail then you should re-visit the prerequisites below.\nPrerequisites\r#\r\rFyne requires 3 basic elements to be present, the Go tools (at least version 1.12), a C compiler (to connect with system graphics drivers) and an system graphics driver. The instructions vary depending on your operating system, choose the appropriate tab below for installation instructions.\nNote that these steps are just required for development - your Fyne applications will not require any setup or dependency installation for end users!\nwindows\r#\r\r Download Go from the download page and follow instructions Install one of the available C compilers for windows, the following are tested with Go and Fyne:  MSYS2 with MingW-w64 - msys2.org TDM-GCC - tdm-gcc.tdragon.net Cygwin - cygwin.com   In Windows your graphics driver will already be installed, but it is recommended to ensure they are up to date.  The steps for installing with MSYS2 (recommended) are as follows:\n  Install MSYS2 from msys2.org\n  Once installed do not use the MSYS terminal that opens\n  Open \u0026ldquo;MSYS2 MinGW 64-bit\u0026rdquo; from the start menu\n  Execute the following commands (if asked for install options be sure to choose \u0026ldquo;all\u0026rdquo;):\n $ pacman -Syu\r$ pacman -S git mingw-w64-x86_64-toolchain\r   You will need to add /c/Program\\ Files/Go/bin and ~/Go/bin to your PATH, for MSYS2 you can paste the following command into your terminal:\n $ echo \u0026quot;export PATH=$PATH:/c/Program\\ Files/Go/bin:~/Go/bin\u0026quot; \u0026gt;\u0026gt; ~/.bashrc\r   macos\r#\r\r Download Go from the download page and follow instructions Install Xcode from the Mac App Store Set up the Xcode command line tools by opening a Terminal window and typing the following: xcode-select --install In macOS the graphics drivers will already be installed.  linux\r#\r\r You will need to install Go, gcc and the graphics library header files using your package manager, one of the following commands will probably work. Debian / Ubuntu: sudo apt-get install golang gcc libgl1-mesa-dev xorg-dev Fedora: sudo dnf install golang gcc libXcursor-devel libXrandr-devel mesa-libGL-devel libXi-devel libXinerama-devel libXxf86vm-devel Arch Linux: sudo pacman -S go xorg-server-devel libxcursor libxrandr libxinerama libxi Solus: sudo eopkg it -c system.devel golang mesalib-devel libxrandr-devel libxcursor-devel libxi-devel libxinerama-devel openSUSE: sudo zypper install go gcc libXcursor-devel libXrandr-devel Mesa-libGL-devel libXi-devel libXinerama-devel libXxf86vm-devel Void Linux: sudo xbps-install -S go base-devel xorg-server-devel libXrandr-devel libXcursor-devel libXinerama-devel  rpi\r#\r\r You will need to install Go, gcc and the graphics library header files using the package manager. sudo apt-get install golang gcc libegl1-mesa-dev xorg-dev  bsd\r#\r\r You will need to install Go, gcc and the graphics library header files using the package manager. FreeBSD: sudo pkg install go gcc xorg pkgconf  android\r#\r\r To develop apps for Android you will first need to install the tools for your current computer (Windows, macOS or Linux) Once complete you will need to install the Android SDK and Android NDK - the recommended approach is to install Android Studio and then go to Tools \u0026gt; SDK Manager and from SDK Tools install the NDK (Side by side) package.  ios\r#\r\r To develop apps for iOS you will need access to an Apple Mac computer, configured according to the macOS tab above. You will also need to create an Apple Developer account and sign up to the developer program (costs apply) to obtain the necessary certificate to run your app on any devices.  function clickTab(tab) {\rdocument.querySelector('li.tabcontrol[data-name=\"'+tab+'\"]').click();\r}\r$(document).ready(function(){\rvar ua = navigator.userAgent || navigator.vendor || window.opera;\rif (/android/i.test(ua)) {\rclickTab(\"android\");\rreturn;\r} else if (/iPad|iPhone|iPod/.test(ua) \u0026\u0026 !window.MSStream) {\rclickTab(\"ios\");\rreturn;\r}\rvar os = window.navigator.platform;\rif (os == \"win32\") {\rclickTab(\"windows\");\r} else if (os == \"MacIntel\") {\rclickTab(\"macos\");\r} else if (os == \"Linux i686\" || os == \"Linux x86_64\") {\rclickTab(\"linux\");\r} else if (os == \"Linux armv7l\") {\rclickTab(\"rpi\");\r} else if (os == \"FreeBSD i386\" || os == \"FreeBSD amd64\" || os == \"OpenBSD i386\" || os == \"OpenBSD amd64\" || os == \"NetBSD i386\" || os == \"NetBSD amd64\") {\rclickTab(\"bsd\");\r}\r});\r Downloading\r#\r\rWhen using Go modules (required with Go 1.16 and later), you will need to set up the module before you can use the package. If you are not using modules or you already have your module initialized, you can skip this to the next step. Run the following command and replace MODULE_NAME with your preferred module name (this should be called in a new folder specific for your application).\n$ cd myapp\r$ go mod init MODULE_NAME\r You now need to download the Fyne module. This will be done using the following command:\n$ go get fyne.io/fyne/v2\r To finish your module\u0026rsquo;s set up, you now need to tidy the module file to correctly reference Fyne as a dependency. You do this by using the following command (can be skipped if you are not using modules):\n$ go mod tidy\r If you are unsure of how Go modules work, consider reading Tutorial: Create a Go module.\nRun the demo\r#\r\rIf you want to see the Fyne toolkit in action before you start to code your own application, you can see our demo app running on your computer by executing:\n$ go run fyne.io/fyne/v2/cmd/fyne_demo\r Please note that the first run has to compile some C-code and can thus take longer than usual. Subsequent builds reuse the cache and will be much faster.\nInstalling\r#\r\rIf you want to, you can also install the demo using the following command (requires Go 1.16 or later):\n$ go install fyne.io/fyne/v2/cmd/fyne_demo@latest\r For earlier versions of Go, you need to use the following command instead:\n$ go get fyne.io/fyne/v2/cmd/fyne_demo\r If your GOBIN environment has been added to path (should be by default on macOS and Windows), you can then run the demo:\n$ fyne_demo\r And that\u0026rsquo;s all there is to it! Now you can write your own Fyne application in your IDE of choice. If you want to see some Fyne code in action then you can read your first application.\n"},{"id":2,"href":"/fyne/docs/started/","title":"Getting Started","section":"Docs","content":"\r\rIntroduction\r\rintroduction\r\r\rHello World\r\rHello World\r\r\rApplication and RunLoop\r\rApplication and RunLoop\r\r\rUpdating Content\r\rUpdating Content\r\r\rWindow Handling\r\rWindow Handling\r\r\rTesting Graphical Apps\r\rTesting Graphical Apps\r\r\rPackaging for Desktop\r\rPackaging for Desktop\r\r\rPackaging Mobile Apps\r\rPackaging Mobile Apps\r\r\rDistributing to App Stores\r\rDistributing to App Stores\r\r\rApp Metadata\r\rApp Metadata\r\r\rCross Compiling\r\rCross Compiling\r\r\r"},{"id":3,"href":"/fyne/docs/explore/container/","title":"Container and Layouts","section":"Exploring Fyne","content":"In the previous example we saw how to set a CanvasObject to the content of a Canvas, but it is not very useful to only show one visual element. To show more than one item we use the Container type.\nAs the fyne.Container also is a fyne.CanvasObject, we can set it to be the content of a fyne.Canvas. In this example we create 3 text objects and then place them in a container using the container.NewWithoutLayout() function. As there is no layout set we can move the elements around like you see with text2.Move().\npackage main  import ( \t\u0026#34;image/color\u0026#34;  \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \t\u0026#34;fyne.io/fyne/v2/container\u0026#34; \t//\u0026#34;fyne.io/fyne/v2/layout\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Container\u0026#34;) \tgreen := color.NRGBA{R: 0, G: 180, B: 0, A: 255}  \ttext1 := canvas.NewText(\u0026#34;Hello\u0026#34;, green) \ttext2 := canvas.NewText(\u0026#34;There\u0026#34;, green) \ttext2.Move(fyne.NewPos(20, 20)) \tcontent := container.NewWithoutLayout(text1, text2) \t// content := container.New(layout.NewGridLayout(2), text1, text2)  \tmyWindow.SetContent(content) \tmyWindow.ShowAndRun() } A fyne.Layout implements a method for organising items within a container. By uncommenting the container.New() line in this example you alter the container to use a grid layout with 2 columns. Run this code and try resizing the window to see how the layout automatically configures the contents of the window. Notice also that the manual position of text2 is ignored by the layout code.\nTo see more you can check out the Layout list.\n"},{"id":4,"href":"/fyne/docs/started/helloword/","title":"Hello World","section":"Getting Started","content":"Create your first Fyne app\r#\r\r Having completed the steps in the getting started document you\u0026rsquo;re ready to build your first app. To illustrate the process we will build a simple hello world application.\nA simple app starts by creating an app instance with app.New() and then opening a window with app.NewWindow(). Then a widget tree is defined that is set as the main content with SetContent() on a window. The app UI is then shown by calling ShowAndRun() on the window.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello World\u0026#34;)  \tw.SetContent(widget.NewLabel(\u0026#34;Hello World!\u0026#34;)) \tw.ShowAndRun() } The code above can be built using the command go build . and then executed either by running the hello command or by double clicking the icon. You could also bypass the compiling step and just run the code directly using go run ..\nEither approach will show a window that looks just like this:\n\rIf you prefer a light theme then just set the environment variable FYNE_THEME=light and you\u0026rsquo;ll get:\n\rThat\u0026rsquo;s all there is to getting started. To learn more you can read the full API documentation.\n"},{"id":5,"href":"/fyne/docs/explore/","title":"Exploring Fyne","section":"Docs","content":"\r\rCanvas and CanvasObject\r\rCanvas and CanvasObject\r\r\rContainer and Layouts\r\rContainer and Layouts\r\r\rWidget List\r\rWidget List\r\r\rAdding Shortcuts to an App\r\rShortcuts are common tasks that can be triggered by keyboard combinations or context menus. Shortcuts, much like keyboard events, can be attached to a focused element or registered on the Canvas to always be available in a Window. Registering with a Canvas\r#\rThere are many standard shortcuts defined (such as fyne.ShortcutCopy) which are connected to standard keyboard shortcuts and right-click menus. The first step to adding a new Shortcut is to define the shortcut.\r\r\rCompile Options\r\rBuild tags\r#\rFyne will typically configure your application appropriately for the target platform by selecting the driver and configuration. The following build tags are supported and can help in your development. For example if you wish to simulate a mobile application whilst running on a desktop computer you could use the following command: go run -tags mobile main.go\rTag Description gles Force use of embedded OpenGL (GLES) instead of full OpenGL.\r\r\rData Binding\r\rData binding was introduced in Fyne v2.0.0 and makes it easier to connect many widgets to a data source that will update over time. the data/binding package has many helpful bindings that can manage most standard types that will be used in an application. A data binding can be managed using the binding API (for example NewString) or it can be connected to an external item of data like (`BindInt(*int)).\r\r\rDialog List\r\rStandard Dialogs\r#\rColor\r#\rAllow users to pick a colour from a standard set (or any color in advanced mode). {% include dialog.html name=\u0026ldquo;color\u0026rdquo; %} Confirm\r#\rAsk for conformation of an action. {% include dialog.html name=\u0026ldquo;confirm\u0026rdquo; %} FileOpen\r#\rPresent this to ask user to choose a file to use inside the app. The actual dialog displayed will depend on the current operating system.\r\r\rLayout List\r\rStandard Layouts\r#\rHorizontal Box (HBox)\r#\rHorizontal Box arranges items in a horizontal row. Every element will have the same height (the height of the tallest item in the container) and objects will be left-aligned at their minimum width. {% include layout.html name=\u0026ldquo;hbox\u0026rdquo; %} Vertical Box (VBox)\r#\rVertical Box arranges items in a vertical column. Every element will have the same width (the width of the widest item in the container) and objects will be top-aligned at their minimum height.\r\r\rUsing the Preferences API\r\rStoring user configurations and values is a common task for application developers, but implementing it across multiple platforms can be tedious and time-consuming. To make it easier, Fyne has an API for storing values on the filesystem in a clean and understandable way while the complex parts are handled for you. Lets start with the setup of the API. It is part of the Preferences interface where storage and loading functions exist for values of Bool, Float, Int and String.\r\r\r"},{"id":6,"href":"/fyne/docs/started/apprun/","title":"Application and RunLoop","section":"Getting Started","content":"For a GUI application to work it needs to run an event loop (sometimes called a runloop) that processes user interactions and drawing events. In Fyne this is started using the App.Run() or Window.ShowAndRun() functions. One of these must be called from the end of your setup code in the main() function.\nAn application should only have one runloop and so you should only call Run() once in your code. Calling it a second time will cause errors.\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \tmyApp := app.New() \tmyWindow := myApp.NewWindow(\u0026#34;Hello\u0026#34;) \tmyWindow.SetContent(widget.NewLabel(\u0026#34;Hello\u0026#34;))  \tmyWindow.Show() \tmyApp.Run() \ttidyUp() }  func tidyUp() { \tfmt.Println(\u0026#34;Exited\u0026#34;) } For desktop runtimes an app can be quit directly by calling App.Quit() (mobile apps do not support this) - normally not needed in developer code. An application will also quit once all the windows are closed. See also that functions executed after Run() will not be called until the application exits.\n"},{"id":7,"href":"/fyne/docs/explore/widgets/","title":"Widget List","section":"Exploring Fyne","content":"Standard Widgets (in widget package)\r#\r\r Accordion\r#\r\rAccordion displays a list of AccordionItems. Each item is represented by a button that reveals a detailed view when tapped.\n\rButton\r#\r\rButton widget has a text label and icon, both are optional.\n\rCard\r#\r\rCard widget groups elements with a header and subheader, all are optional.\n\rCheck\r#\r\rCheck widget has a text label and a checked (or unchecked) icon.\n\rEntry\r#\r\rEntry widget allows simple text to be input when focused.\n\rPasswordEntry widget hides text input and adds a button to display the text.\n\rFileIcon\r#\r\rFileIcon provides helpful standard icons for various types of file. It displays the type of file as an indicator icon and shows the extension of the file type.\n\rForm\r#\r\rForm widget is two column grid where each row has a label and a widget (usually an input). The last row of the grid will contain the appropriate form control buttons if any should be shown.\n\rHyperlink\r#\r\rHyperlink widget is a text component with appropriate padding and layout. When clicked, the URL opens in your default web browser.\n\rIcon\r#\r\rIcon widget is a basic image component that load\u0026rsquo;s its resource to match the theme.\n\rLabel\r#\r\rLabel widget is a label component with appropriate padding and layout.\n\rProgress bar\r#\r\rProgressBar widget creates a horizontal panel that indicates progress.\n\rProgressBarInfinite widget creates a horizontal panel that indicates waiting indefinitely An infinite progress bar loops 0% -\u0026gt; 100% repeatedly until Stop() is called.\n\rRadioGroup\r#\r\rRadioGroup widget has a list of text labels and radio check icons next to each.\n\rSelect\r#\r\rSelect widget has a list of options, with the current one shown, and triggers an event function when clicked.\n\rSelectEntry\r#\r\rSelect entry widget adds an editable component to the select widget. Users can select an option or enter their own value.\n\rSeparator\r#\r\rSeparator widget shows a dividing line between other elements.\n\rSlider\r#\r\rSlider if a widget that can slide between two fixed values.\n\rTextGrid\r#\r\rTextGrid is a monospaced grid of characters. This is designed to be used by a text editor, code preview or terminal emulator.\n\rToolbar\r#\r\rToolbar widget creates a horizontal list of tool buttons.\n\rCollection Widgets (in widget package)\r#\r\rCollection widgets provide advanced caching functionality to provide high performance rendering of massive data. This does lead to a more complex constructor, but is a good balance for the outcome it enables. Each of these widgets uses a series of callbacks, the minimum set is defined by their constructor function, which includes the data size, the creation of template items that can be re-used and finally the function that applies data to a widget as it is about to be added to the display.\nList\r#\r\rList provides a high performance vertical scroll of many sub-items.\n\rTable\r#\r\rTable provides a high performance scrolled two dimensional display of many sub-items. Tree\r#\r\rTree provides a high performance vertical scroll of items that can be expanded to reveal child elements..\n\rContainer Widgets (in container package)\r#\r\rContainer widgets are like regular containers but they provide some additional functionality.\nAppTabs\r#\r\rAppTabs widget allows switching visible content from a list of TabItems. Each item is represented by a button at the top of the widget.\n\rScroll\r#\r\rScrollContainer defines a container that is smaller than the Content.\n\rSplit\r#\r\rSplitContainer defines a container whose size is split between two children.\n\r"},{"id":8,"href":"/fyne/docs/started/updating/","title":"Updating Content","section":"Getting Started","content":"Having completed the hello world tutorial or other examples you will have created a basic user interface. In this page we see how the content of a GUI can be updated from your code.\nThe first step is to assign the widget you want to update to a variable. In the hello world tutorial we passed widget.NewLabel directly into SetContent(), to update it we change that to two different lines, such as:\n\tclock := widget.NewLabel(\u0026#34;\u0026#34;) \tw.SetContent(clock) Once the content has been assigned to a variable we can call functions like SetText(\u0026quot;new text\u0026quot;). For our example we will set the content of our label to the current time, with the help of Time.Format.\n\tformatted := time.Now().Format(\u0026#34;Time: 03:04:05\u0026#34;) \tclock.SetText(formatted) That is all we need to do to change content of a visible item (see below for the full code). However, we can go further and update content on a regular basis.\nRunning in the background\r#\r\rMost applications will need to have processes that run in the background, for example downloading data or responding to events. To simulate this we will extend the code above to run every second.\nLike with most go code we can create a goroutine (using the go keyword) and run our code there. If we move the text update code to a new function it can be called on initial display as well as on a timer for regular updating. By combining a goroutine and the time.Tick inside a for loop we can update the label every second.\n\tgo func() { \tfor range time.Tick(time.Second) { \tupdateTime(clock) \t} \t}() It is important to place this code before ShowAndRun or Run calls because they will not return until the application closes. With all of this together the code will run and update the user interface each second, creating a basic clock widget. The full code is as follows:\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func updateTime(clock *widget.Label) { \tformatted := time.Now().Format(\u0026#34;Time: 03:04:05\u0026#34;) \tclock.SetText(formatted) }  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Clock\u0026#34;)  \tclock := widget.NewLabel(\u0026#34;\u0026#34;) \tupdateTime(clock)  \tw.SetContent(clock) \tgo func() { \tfor range time.Tick(time.Second) { \tupdateTime(clock) \t} \t}() \tw.ShowAndRun() } "},{"id":9,"href":"/fyne/docs/started/windows/","title":"Window Handling","section":"Getting Started","content":"Windows are created using App.NewWindow() and need to be shown using the Show() function. The helper method ShowAndRun() on fyne.Window allows you to show your window and run the application at the same time.\nBy default a window will be the right size to show its content by checking the MinSize() function (more on that in later examples). You can set a larger size by calling the Window.Resize() method. Into this is passed a fyne.Size which contains a width and height using device independent pixels (meaning that it will be the same across different devices), for example to make a window square by default we could:\n\tw.Resize(fyne.NewSize(100, 100)) Be aware that the desktop environment may have constraints that cause windows to be smaller than requested. Mobile devices will typically ignore this as they are only displayed at full-screen.\nIf you wish to show a second window you must only call the Show() function. It can also be helpful to split Window.Show() from App.Run() if you want to open multiple windows when your application starts. The example below shows how to load two windows when starting.\npackage main  import ( \t\u0026#34;fyne.io/fyne/v2\u0026#34; \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello World\u0026#34;)  \tw.SetContent(widget.NewLabel(\u0026#34;Hello World!\u0026#34;)) \tw.Show()  \tw2 := a.NewWindow(\u0026#34;Larger\u0026#34;) \tw2.SetContent(widget.NewLabel(\u0026#34;More content\u0026#34;)) \tw2.Resize(fyne.NewSize(100, 100)) \tw2.Show()  \ta.Run() } The above application will exit when both windows are closed. If your app is arranged so one window is main and the others are accessory views you can set one window to be \u0026ldquo;master\u0026rdquo; so that the app exits if that window is closed. To do this use the SetMaster() function on Window.\nWindows can be created at any time, we could change the code above so that the content of the second window (w2) is a button that opens a new window. You could also load windows from more complex workflows, but be careful because new windows will normally appear above the current active content.\n\tw2.SetContent(widget.NewButton(\u0026#34;Open new\u0026#34;, func() { \tw3 := a.NewWindow(\u0026#34;Third\u0026#34;) \tw3.SetContent(widget.NewLabel(\u0026#34;Third\u0026#34;)) \tw3.Show() \t})) "},{"id":10,"href":"/fyne/docs/started/testing/","title":"Testing Graphical Apps","section":"Getting Started","content":"Part of a good test suite is being able to quickly write tests and run them on a regular basis. Fyne\u0026rsquo;s API is designed to make testing applications easy. By separating component logic from it\u0026rsquo;s rendering definition we can load applications without actually displaying them and test the functionality completely.\nExample\r#\r\rWe can demonstrate unit testing by extending our Hello World app to include space for users to input their name to be greeted. We start by updating the user interface to have two elements, a Label for the greeting and an Entry for the name input. We display them, one above another, using container.NewVBox (a vertical box container). The updated user interface code will look as follows:\nfunc makeUI() (*widget.Label, *widget.Entry) { \treturn widget.NewLabel(\u0026#34;Hello world!\u0026#34;), \twidget.NewEntry() }  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello Person\u0026#34;)  \tw.SetContent(container.NewVBox(makeUI())) \tw.ShowAndRun() } To test this input behaviour we create a new file (with a name ending _test.go to mark it as tests) that defines a TestGreeter function.\npackage main  import (  \u0026#34;testing\u0026#34; )  func TestGreeting(t *testing.T) { } We can add an intial test that verifies the initial state, to do this we test the Text field of the Label that is returned from makeUI and error the test if it is not correct. Add the following code to your test method:\n\tout, in := makeUI()  \tif out.Text != \u0026#34;Hello world!\u0026#34; { \tt.Error(\u0026#34;Incorrect initial greeting\u0026#34;) \t} This test will pass - next we add to the test to validate the greeter. We use the Fyne fyne.io/fyne/v2/test package which assists in test scenarios, calling test.Type to simulate user input. The following test code will check that the output updates when the user\u0026rsquo;s name is input (be sure to add the import as well):\n\ttest.Type(in, \u0026#34;Andy\u0026#34;) \tif out.Text != \u0026#34;Hello Andy!\u0026#34; { \tt.Error(\u0026#34;Incorrect user greeting\u0026#34;) \t} You can run all of these tests using go test . - just like any other tests. Doing so you will now see a failure - because we did not add the greeter logic. Update the makeUI function to the following code:\nfunc makeUI() (*widget.Label, *widget.Entry) { \tout := widget.NewLabel(\u0026#34;Hello world!\u0026#34;) \tin := widget.NewEntry()  \tin.OnChanged = func(content string) { \tout.SetText(\u0026#34;Hello \u0026#34; + content + \u0026#34;!\u0026#34;) \t} \treturn out, in } Doing so you will see that the tests now pass. You can also run the full application (using go run .) and see the greeting update as you enter a name in the Entry field. Notice also that these tests all run without displaying a window or stealing your mouse - this is another benefit of the Fyne unit testing setup.\n"},{"id":11,"href":"/fyne/docs/started/packaging/","title":"Packaging for Desktop","section":"Getting Started","content":"Packaging a graphical app for distribution can be complex. Graphical applications typically have icons and metadata associated with them as well as specific formats required to integrate with each environment. Windows executables need embedded icons, macOS apps are bundles and with Linux there are various metadata files that should get installed. What a hassle!\nThankfully the \u0026ldquo;fyne\u0026rdquo; app has a \u0026ldquo;package\u0026rdquo; command that can handle this automatically. Just specifying the target OS and any required metadata (such as icon) will generate the appropriate package. The icon conversion will be done automatically for .icns or .ico so just provide a .png file :). All you need is to have the application already built for the target platform\u0026hellip;\ngo install fyne.io/fyne/v2/cmd/fyne@latest\rfyne package -os darwin -icon myapp.png If you\u0026rsquo;re using an older version of Go (\u0026lt;1.16), you should install fyne using go get\ngo get fyne.io/fyne/v2/cmd/fyne\rfyne package -os darwin -icon myapp.png Will create myapp.app, a complete bundle structure for distribution to macOS users. You could then build the linux and Windows versions too\u0026hellip;\nfyne package -os linux -icon myapp.png\rfyne package -os windows -icon myapp.png These commands will create:\n myapp.tar.gz that contains a folder structure starting at usr/local/ that a Linux user could expand to the root of their system. myapp.exe (after the second build, which is required for a windows package) will have the icon and app metadata embedded.  If you just want to install the desktop app on your computer then you can make use of the helpful install subcommand. For example to install your current application system wide you could simply execute the following:\nfyne install -icon myapp.png All of these commands also support a default icon file of Icon.png so that you can avoid typing the parameter for each execution. Since Fyne 2.1 there is also a metadata file where you can set default options for your project.\nOf course you can still run your applications using the standard Go tools if you prefer.\n"},{"id":12,"href":"/fyne/docs/started/mobile/","title":"Packaging Mobile Apps","section":"Getting Started","content":"Your Fyne app code will work out of the box as mobile apps, just as it did for desktop. However it is a little more complex to package the code for distribution. This page will explore the process to do just that to get your app on iOS and Android.\nFirstly you will need some more development tools installed for mobile packaging to complete. For Android builds you must have the Android SDK and NDK installed with appropriate environment set up so that the tools (such as adb) can be found on the command line. To build iOS apps you will need Xcode installed on your macOS computer as well as the command line tools optional package.\nOnce you have a working development environment the packaging is simple. To build an application for Android and iOS the following commands will do everything for you. Be sure to have a unique application identifier as it is unwise to change these after your first release.\nfyne package -os android -appID com.example.myapp -icon mobileIcon.png\rfyne package -os ios -appID com.example.myapp -icon mobileIcon.png After these commands have completed (which may take some time on first compilation) you will see two new files in your directory, myapp.apk and myapp.app. You will see that the latter has the same name as a darwin application bundle - don\u0026rsquo;t get them confused as they will not work on the other platform.\nTo install the android app on your phone or a simulator simply call:\nadb install myapp.apk For iOS to install on device open Xcode and choose the \u0026ldquo;Devices and Simulators\u0026rdquo; menu item within the \u0026ldquo;Window\u0026rdquo; menu. Then find your phone and drag the myapp.app icon onto your app list. To install on a simulator you can use the command line tools as follows:\nxcrun simctl install booted myapp.app "},{"id":13,"href":"/fyne/docs/started/distribution/","title":"Distributing to App Stores","section":"Getting Started","content":"Packaging a graphical app as described in the Packaging page provides a file or bundle that could be directly shared or distributed. However signing and uploading to app stores and market places is an additional step that requires platform-specific configuration, which we will cover in this page.\nIn each of these steps we will use a new tool that is part of the fyne command line utilities. The fyne release step handles the signing and preparation for each store, but the parameters vary per-platform, which we see below.\nmacOS App Store (since fyne 1.4.2)\r#\r\rPrerequisites:\n Apple mac running macOS and Xcode Apple Developer account Mac App Store application certificate Mac App Store installer certificate Apple Transporter app from App Store     2. Bundle the completed app for release:\n$ fyne release -appID com.example.myapp -appVersion 1.0 -appBuild 1 -category games 3. Drag the .pkg onto Transporter and tap \u0026ldquo;Deliver\u0026rdquo;.\n4. Go to back to the AppStore Connect website, choose your build for the release and submit for review.\nGoogle Play Store (Android)\r#\r\rPrerequisites:\n Google Play Console account distribution keystore (creation instructions in android docs)  1. Set up your app / version ready for build to be uploaded at Google Play Console. Turn off \u0026ldquo;Play app signing\u0026rdquo; option as we manage it ourselves.\n2. Bundle the completed app for release:\n$ fyne release -os android -appID com.example.myapp -appVersion 1.0 -appBuild 1 3. Drag the .apk file into the build drop zone on the app version page in Play Console\n4. Start rollout of new version.\niOS App Store (since fyne 1.4.1)\r#\r\rPrerequisites:\n Apple mac running macOS and Xcode Apple Developer account iOS App Store distribution certificate Apple Transporter app from App Store  1. Set up your app / version ready for a build to be uploaded at AppStore Connect.\n2. Bundle the completed app for release:\n$ fyne release -os ios -appID com.example.myapp -appVersion 1.0 -appBuild 1 3. Drag the .ipa onto Transporter and tap \u0026ldquo;Deliver\u0026rdquo;.\n4. Go to back to the AppStore Connect website, choose your build for the release and submit for review.\n"},{"id":14,"href":"/fyne/docs/started/metadata/","title":"App Metadata","section":"Getting Started","content":"App Metadata\r#\r\rSince release v2.1.0 of the fyne command we support a metadata file that allows you to store information about your application in the repository. This file is optional, but can help to avoid having to remember specific build parameters for each package and release command.\nThe file should be named FyneApp.toml in the directory where you run the fyne command (this is normally the main package). The contents of the file are as follows:\nWebsite = \u0026#34;https://example.com\u0026#34;  [Details] Icon = \u0026#34;Icon.png\u0026#34; Name = \u0026#34;My App\u0026#34; ID = \u0026#34;com.example.app\u0026#34; Version = \u0026#34;1.0.0\u0026#34; Build = 1 The top portion of the file is metadata that will be used if you upload your app to the https://apps.fyne.io listing page, so it is optional. The [Details] section contains data about your application that are used in the release process by other app stores and operating systems. The fyne tool will use this file if it is found, many mandatory command parameters are not required if the metadata is present. You can still override these values by using command line parameters.\n"},{"id":15,"href":"/fyne/docs/started/cross-compiling/","title":"Cross Compiling","section":"Getting Started","content":"Compiling for different platforms\r#\r\r Cross compiling with Go is designed to be simple - we just set the environment variable GOOS for the target Operating System (and GOARCH if targeting a different architecture). Unfortunately when using native graphics calls the use of CGo in Fyne makes this a little harder.\nCompiling from a development computer\r#\r\rTo cross-compile a Fyne application you will also have to set CGO_ENABLED=1 which tells go to enable the C compiler (this is normally turned off when the target platform is different to the current system). Doing so unfortunately means that you must have a C compiler for the target platform that you are going to compile for. After installing the appropriate compilers you will also need to set the CC environment variable to tell Go which compiler to use.\nThere are many ways to install the required tools - and different tools that can be used. The configuration recommended by the Fyne developers is:\n   GOOS (target) CC provider download notes     darwin o32-clang osxcross \rfrom github.com You will also need to install the macOS SDK (instructions at the download link)   windows x86_64-w64-mingw64-gcc mingw64 package manager For macOS use homebrew   linux gcc or x86_64-linux-musl-gcc gcc or musl-cross \rcygwin or package manager musl-cross is available from homebrew to provide the linux gcc. You will also need to install X11 and mesa headers for compilation.    With the environment variables above set you should be able to compile in the usual manner. If further errors occur it is likely to be due to missing packages. Some target platforms require additional libraries or headers to be installed for the compilation to succeed.\nUsing a virtual environment\r#\r\rAs a Linux system is able to cross compile to macOS and Windows easily it can be simpler to use a virtualised environment when you are not developing from Linux. Docker images are a useful tool for a complex build configuration and this works for Fyne as well. There are different tools that can be used. The tool recommended by the Fyne developers is fyne-cross. It has been inspired by xgo and uses a docker image built on top of the golang-cross image, that includes the MinGW compiler for windows, and a macOS SDK, along with the Fyne requirements.\nfyne-cross allows to build binaries and create distribution packages for the following targets:\n   GOOS GOARCH     darwin amd64   darwin 386   linux amd64   linux 386   linux arm64   linux arm   windows amd64   windows 386   android amd64   android 386   android arm64   android arm   ios    freebsd amd64   freebsd arm64     Note: iOS compilation is supported only on darwin hosts.\n Requirements\r#\r\r go \u0026gt;= 1.13 docker  Installation\r#\r\rgo get github.com/fyne-io/fyne-cross Usage\r#\r\rfyne-cross \u0026lt;command\u0026gt; [options]\rThe commands are:\rdarwin Build and package a fyne application for the darwin OS\rlinux Build and package a fyne application for the linux OS\rwindows Build and package a fyne application for the windows OS\randroid Build and package a fyne application for the android OS\rios Build and package a fyne application for the iOS OS\rfreebsd Build and package a fyne application for the freebsd OS\rversion Print the fyne-cross version information\rUse \u0026#34;fyne-cross \u0026lt;command\u0026gt; -help\u0026#34; for more information about a command. Wildcards\r#\r\rThe arch flag support wildcards in case want to compile against all supported GOARCH for a specified GOOS\nExample:\nfyne-cross windows -arch=* is equivalent to\nfyne-cross windows -arch=amd64,386 Example\r#\r\rThe example below cross compile and package the fyne examples application\ngit clone https://github.com/fyne-io/examples.git\rcd examples Compile and package the main example app\r#\r\rfyne-cross linux  Note: by default fyne-cross will compile the package into the current dir.\nThe command above is equivalent to: fyne-cross linux .\n Compile and package a particular example app\r#\r\rfyne-cross linux -output bugs ./cmd/bugs "},{"id":16,"href":"/fyne/docs/explore/shortcuts/","title":"Adding Shortcuts to an App","section":"Exploring Fyne","content":"Shortcuts are common tasks that can be triggered by keyboard combinations or context menus. Shortcuts, much like keyboard events, can be attached to a focused element or registered on the Canvas to always be available in a Window.\nRegistering with a Canvas\r#\r\rThere are many standard shortcuts defined (such as fyne.ShortcutCopy) which are connected to standard keyboard shortcuts and right-click menus. The first step to adding a new Shortcut is to define the shortcut. For most uses this will be a keyboard triggered shortcut, which is a desktop extension. To do this we use desktop.CustomShortcut, for example to use the Tab key and Control modifier you might do the following:\n\tctrlTab := desktop.CustomShortcut{KeyName: fyne.KeyTab, Modifier: desktop.ControlModifier} Notice that this shortcut can be re-used so you could attach it to menus or other items as well. For this example we want it to be always available, so we register it with our window\u0026rsquo;s Canvas as follows:\n\tctrlTab := desktop.CustomShortcut{KeyName: fyne.KeyTab, Modifier: desktop.ControlModifier} \tw.Canvas().AddShortcut(\u0026amp;ctrlTab, func(shortcut fyne.Shortcut) { \tlog.Println(\u0026#34;We tapped Ctrl+Tab\u0026#34;) \t}) As you can see there are two parts to registering a shortcut in this way - passing the shortcut definition and also a callback function. If the user types the keyboard shortcut then the function will be called and the output printed.\nAdding shortcuts to an Entry\r#\r\rIt can also be helpful to have a shortcut apply only when the current item is focused. This approach can be used for any focusable widget, and is managed by extending that widget and adding a TypedShortcut handler. This is much like adding key handlers, except the value passed in will be a fyne.Shortcut.\ntype myEntry struct { \twidget.Entry }  func (m *myEntry) TypedShortcut(s fyne.Shortcut) { \tif _, ok := s.(*desktop.CustomShortcut); !ok { \tm.Entry.TypedShortcut(s) \treturn \t}  \tlog.Println(\u0026#34;Shortcut typed:\u0026#34;, s) } From the excerpt above you can see how a TypedShortcut handler might be implemented. Inside this function you should check whether the shortcut is of the custom type used earlier. If the shortcut is a standard one it\u0026rsquo;s a good idea to call the original shortcut handler (if the widget had one). With those checks done you can compare the shortcut with the various types you are handling (if there are multiple).\n"},{"id":17,"href":"/fyne/docs/explore/compiling/","title":"Compile Options","section":"Exploring Fyne","content":"Build tags\r#\r\rFyne will typically configure your application appropriately for the target platform by selecting the driver and configuration. The following build tags are supported and can help in your development. For example if you wish to simulate a mobile application whilst running on a desktop computer you could use the following command:\ngo run -tags mobile main.go\r    Tag Description     gles Force use of embedded OpenGL (GLES) instead of full OpenGL. This is normally controlled by the target device and not normally needed.   hints Display developer hints for improvements or optimisations. Running with hints will log when your application does not follow material design or other recommendations.   mobile This tag runs an application in a simulated mobile window. Useful when you want to preview your app on a mobile platform without compiling and installing to the device.   no_native_menus This flag is specifically for macOS and indicates that the application should not use the macOS native menus. Instead menus will be displayed inside the application window. Most useful for testing an application on macOS to simulate the behavior on Windows or Linux.    "},{"id":18,"href":"/fyne/docs/explore/binding/","title":"Data Binding","section":"Exploring Fyne","content":"Data binding was introduced in Fyne v2.0.0 and makes it easier to connect many widgets to a data source that will update over time. the data/binding package has many helpful bindings that can manage most standard types that will be used in an application. A data binding can be managed using the binding API (for example NewString) or it can be connected to an external item of data like (`BindInt(*int)).\nWidgets that support binding typically have a ...WithData constructor to set up the binding when creating the widget. You can also call Bind() and Unbind() to manage the data of an existing widget. The following example shows how you can manage a String data item that is bound to a simple Label widget.\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;fyne.io/fyne/v2/app\u0026#34; \t\u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \t\u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() { \ta := app.New() \tw := a.NewWindow(\u0026#34;Hello\u0026#34;)  \tstr := binding.NewString() \tgo func() { \tdots := \u0026#34;.....\u0026#34; \tfor i := 5; i \u0026gt;= 0; i-- { \tstr.Set(\u0026#34;Count down\u0026#34; + dots[:i]) \ttime.Sleep(time.Second) \t} \tstr.Set(\u0026#34;Blast off!\u0026#34;) \t}()  \tw.SetContent(widget.NewLabelWithData(str)) \tw.ShowAndRun() } You can find out more in the data binding section of this site.\n"},{"id":19,"href":"/fyne/docs/explore/dialogs/","title":"Dialog List","section":"Exploring Fyne","content":"Standard Dialogs\r#\r\r Color\r#\r\rAllow users to pick a colour from a standard set (or any color in advanced mode).\n{% include dialog.html name=\u0026ldquo;color\u0026rdquo; %}\nConfirm\r#\r\rAsk for conformation of an action.\n{% include dialog.html name=\u0026ldquo;confirm\u0026rdquo; %}\nFileOpen\r#\r\rPresent this to ask user to choose a file to use inside the app. The actual dialog displayed will depend on the current operating system.\n{% include dialog.html name=\u0026ldquo;fileopen\u0026rdquo; %}\nForm\r#\r\rGet various input elements in a dialog, with validation.\n{% include dialog.html name=\u0026ldquo;form\u0026rdquo; %}\nInformation\r#\r\rA simple way to present some information to the app user.\n{% include dialog.html name=\u0026ldquo;information\u0026rdquo; %}\nCustom\r#\r\rPresent any content inside a dialog container.\n{% include dialog.html name=\u0026ldquo;custom\u0026rdquo; %}\n"},{"id":20,"href":"/fyne/docs/explore/layouts/","title":"Layout List","section":"Exploring Fyne","content":"Standard Layouts\r#\r\r Horizontal Box (HBox)\r#\r\rHorizontal Box arranges items in a horizontal row. Every element will have the same height (the height of the tallest item in the container) and objects will be left-aligned at their minimum width.\n{% include layout.html name=\u0026ldquo;hbox\u0026rdquo; %}\nVertical Box (VBox)\r#\r\rVertical Box arranges items in a vertical column. Every element will have the same width (the width of the widest item in the container) and objects will be top-aligned at their minimum height.\n{% include layout.html name=\u0026ldquo;vbox\u0026rdquo; %}\nCenter\r#\r\rCenter layout positions all container elements in the center of the container. Every object will be set to it\u0026rsquo;s minimum size.\n{% include layout.html name=\u0026ldquo;center\u0026rdquo; %}\nForm\r#\r\rForm layout arranges items in pairs where the first column is at minimum width. This is normally useful for labelling elements in a form, where the label is in the first column and the item it describes is in the second. You should always add an even number of elements to a form layout.\n{% include layout.html name=\u0026ldquo;form\u0026rdquo; %}\nGrid\r#\r\rGrid layout arranges items equally in the available space. A number of columns is specified, with objects being positioned horizontally until the number of columns is reached at which point a new row is started. All objects have the same size, that is width divided by column total and the height will be total height divided by the number of rows required. Minus padding.\n{% include layout.html name=\u0026ldquo;grid\u0026rdquo; %}\nGridWrap\r#\r\rGridWrap layout arranges all items to flow along a row, wrapping to a new row if there is insufficient space. All objects will be set to the same size, which is the size passed to the layout. This layout may not respect item MinSize to manage this uniform layout. Often used in file managers or image thumbnail lists.\n{% include layout.html name=\u0026ldquo;gridwrap\u0026rdquo; %}\nBorder\r#\r\rBorder layout supports positioning of items at the outside of available space. The border is passed pointers to the objects for (top, left, bottom, right). All items in the container that are not positioned on a border will fill the remaining space.\n{% include layout.html name=\u0026ldquo;border\u0026rdquo; %}\nMax\r#\r\rMax layout positions all container elements to fill the available space. The objects will all be full-sized and drawn in the order they were added to the container (last-most is on top).\n{% include layout.html name=\u0026ldquo;max\u0026rdquo; %}\nPadded\r#\r\rPadded layout positions all container elements to fill the available space but with a small padding around the outside. The size of the padding is theme specific. The objects will all be drawn in the order they were added to the container (last-most is on top).\n{% include layout.html name=\u0026ldquo;padded\u0026rdquo; %}\nCombining Layouts\r#\r\rIt is possible to build up more complex application structures by using multiple layouts. Multiple containers that each have their own layout can be nested to create complete user interface arrangements using only the standard layouts listed above. For example a horizontal box for a header, a vertical box for a left side file panel and a grid wrap layout in the content area - all inside a container using a border layout can build the result illustrated below.\n{% include layout.html name=\u0026ldquo;combined\u0026rdquo; %}\n"},{"id":21,"href":"/fyne/docs/explore/preferences/","title":"Using the Preferences API","section":"Exploring Fyne","content":"Storing user configurations and values is a common task for application developers, but implementing it across multiple platforms can be tedious and time-consuming. To make it easier, Fyne has an API for storing values on the filesystem in a clean and understandable way while the complex parts are handled for you.\nLets start with the setup of the API. It is part of the Preferences interface where storage and loading functions exist for values of Bool, Float, Int and String. They each consist of three different functions, one for loading, one loading with a fallback value and lastly, one for storing values. An example of the three functions and their behaviour can be seen below for the String type:\n// String looks up a string value for the key String(key string) string // StringWithFallback looks up a string value and returns the given fallback if not found StringWithFallback(key, fallback string) string // SetString saves a string value for the given key SetString(key string, value string) These functions can be accessed through the created application variable and calling the Preferences() method on. Please note that it is necessary to create the apps with a unique ID (usually like a reversed url). This means that the application will need to be created using app.NewWithID() to have its own place to store values. It can roughly be used like the example below:\na := app.NewWithID(\u0026#34;com.example.tutorial.preferences\u0026#34;) [...] a.Preferences().SetBool(\u0026#34;Boolean\u0026#34;, true) number := a.Preferences().IntWithFallback(\u0026#34;ApplicationLuckyNumber\u0026#34;, 21) expression := a.Preferences().String(\u0026#34;RegularExpression\u0026#34;) [...] To show this, we are going to build a simple little app that always closes after a set amount of time. This timeout should be user changeable and applied on the next start of the application.\nLet us start by creating a variable called timeout that will be used to store time in the form of time.Duration.\nvar timeout time.Duration Then we could create a select widget to let the user select the timeout from a couple pre-defined strings and then multiplying the timeout by the number of seconds that the string relates to. Lastly, the \u0026quot;AppTimeout\u0026quot; key is used to set the string value to the selected one.\ntimeoutSelector := widget.NewSelect([]string{\u0026#34;10 seconds\u0026#34;, \u0026#34;30 seconds\u0026#34;, \u0026#34;1 minute\u0026#34;}, func(selected string) {  switch selected {  case \u0026#34;10 seconds\u0026#34;:  timeout = 10 * time.Second  case \u0026#34;30 seconds\u0026#34;:  timeout = 30 * time.Second  case \u0026#34;1 minute\u0026#34;:  timeout = time.Minute  }   a.Preferences().SetString(\u0026#34;AppTimeout\u0026#34;, selected) }) Now we want to grab the set value and if none exists, we want to have a fallback that sets the timeout to the shortest one possible to save the user time when waiting. This can be done by setting the selected value of timeoutSelector to the loaded value or the fallback if that happens to be the case. By doing it this way, the code inside the select widget will run for that specific value.\ntimeoutSelector.SetSelected(a.Preferences().StringWithFallback(\u0026#34;AppTimeout\u0026#34;, \u0026#34;10 seconds\u0026#34;)) The last part will just be to have a function that starts in a separate goroutine and tells the application to quit after the selected timeout.\ngo func() {  time.Sleep(timeout)  a.Quit() }() In the end, the resulting code should look something like this:\npackage main  import (  \u0026#34;time\u0026#34;   \u0026#34;fyne.io/fyne/v2/app\u0026#34;  \u0026#34;fyne.io/fyne/v2/widget\u0026#34; )  func main() {  a := app.NewWithID(\u0026#34;com.example.tutorial.preferences\u0026#34;)  w := a.NewWindow(\u0026#34;Timeout\u0026#34;)   var timeout time.Duration   timeoutSelector := widget.NewSelect([]string{\u0026#34;10 seconds\u0026#34;, \u0026#34;30 seconds\u0026#34;, \u0026#34;1 minute\u0026#34;}, func(selected string) {  switch selected {  case \u0026#34;10 seconds\u0026#34;:  timeout = 10 * time.Second  case \u0026#34;30 seconds\u0026#34;:  timeout = 30 * time.Second  case \u0026#34;1 minute\u0026#34;:  timeout = time.Minute  }   a.Preferences().SetString(\u0026#34;AppTimeout\u0026#34;, selected)  })   timeoutSelector.SetSelected(a.Preferences().StringWithFallback(\u0026#34;AppTimeout\u0026#34;, \u0026#34;10 seconds\u0026#34;))   go func() {  time.Sleep(timeout)  a.Quit()  }()   w.SetContent(timeoutSelector)  w.ShowAndRun() } "}]